// NOTE this file is auto-generated by chew
module miniaudio

import miniaudio.c

pub const used_import = c.used_import

//
// miniaudio.h
//

// C typedef aliases used
// ma_bool8 -> ma_uint8 -> u8
pub type C.ma_bool8 = u8 // C.ma_uint8

// ma_bool32 -> ma_uint32 -> u32
pub type C.ma_bool32 = u32 // C.ma_uint32

// ma_handle -> void* -> voidptr
pub type C.ma_handle = voidptr

// ma_ptr -> void* -> voidptr
// wchar_t -> ma_uint16 -> u16
// ma_channel -> ma_uint8 -> u8
pub type C.ma_channel = u8
pub type Channel = u8

// ma_spinlock -> ma_uint32 -> u32
// ma_thread -> ma_pthread_t -> C.ma_pthread_t
pub type C.ma_thread = voidptr // C.ma_pthread_t -> C.ma_handle

// ma_event -> ma_handle -> C.ma_handle
// ma_semaphore -> ma_handle -> C.ma_handle
// ma_resampling_backend -> void ->
// ma_async_notification -> void ->
// ma_data_source -> void ->
// ma_vfs -> void ->
// ma_vfs_file -> ma_handle -> C.ma_handle
pub type C.ma_vfs_file = voidptr // C.ma_handle

// ma_node -> void ->
// ma_sound_group_config -> ma_sound_config -> SoundConfig
pub type C.ma_sound_group_config = C.ma_sound_config

// ma_sound_group -> ma_sound -> Sound
pub type C.ma_sound_group = C.ma_sound

// va_list
@[typedef]
pub struct C.va_list {}

@[typedef]
pub struct C.ma_data_source {}

pub type DataSource = C.ma_data_source

struct C.playback {
pub mut:
	pDeviceID      &DeviceId
	format         Format
	channels       u32
	pChannelMap    &Channel
	channelMixMode ChannelMixMode
	shareMode      ShareMode
}

pub type Playback = C.playback

struct C.capture {
pub mut:
	pDeviceID      &DeviceId
	format         Format
	channels       u32
	pChannelMap    &Channel
	channelMixMode ChannelMixMode
	shareMode      ShareMode
}

pub type Capture = C.capture

/*
TODO Non-numerical: #define miniaudio_h
*/

/*
TODO Non-numerical: #define MA_STRINGIFY(x)     #x
*/

/*
TODO Function: #define MA_XSTRINGIFY(x)    MA_STRINGIFY(x)
*/

pub const version_major = 0

pub const version_minor = 11

pub const version_revision = 11

pub const version_string = '${version_major}.${version_minor}.${version_revision}'

pub const @true = 1

pub const @false = 0

// Proc is currently undocumented
// C: typedef void (* ma_proc)(void);
pub type Proc = fn ()

// Define NULL for some compilers.
pub const null = unsafe { nil }

// SIMD alignment in bytes. Currently set to 32 bytes in preparation for future AVX optimizations.
pub const simd_alignment = 32

// LogLevel is C.ma_log_level
pub enum LogLevel {
	debug   = C.MA_LOG_LEVEL_DEBUG   // 4,
	info    = C.MA_LOG_LEVEL_INFO    // 3,
	warning = C.MA_LOG_LEVEL_WARNING // 2,
	error   = C.MA_LOG_LEVEL_ERROR   // 1,
}

// ChannelPosition is C._ma_channel_position
pub enum ChannelPosition {
	@none              = C.MA_CHANNEL_NONE               // 0,
	mono               = C.MA_CHANNEL_MONO               // 1,
	front_left         = C.MA_CHANNEL_FRONT_LEFT         // 2,
	front_right        = C.MA_CHANNEL_FRONT_RIGHT        // 3,
	front_center       = C.MA_CHANNEL_FRONT_CENTER       // 4,
	lfe                = C.MA_CHANNEL_LFE                // 5,
	back_left          = C.MA_CHANNEL_BACK_LEFT          // 6,
	back_right         = C.MA_CHANNEL_BACK_RIGHT         // 7,
	front_left_center  = C.MA_CHANNEL_FRONT_LEFT_CENTER  // 8,
	front_right_center = C.MA_CHANNEL_FRONT_RIGHT_CENTER // 9,
	back_center        = C.MA_CHANNEL_BACK_CENTER        // 10,
	side_left          = C.MA_CHANNEL_SIDE_LEFT          // 11,
	side_right         = C.MA_CHANNEL_SIDE_RIGHT         // 12,
	top_center         = C.MA_CHANNEL_TOP_CENTER         // 13,
	top_front_left     = C.MA_CHANNEL_TOP_FRONT_LEFT     // 14,
	top_front_center   = C.MA_CHANNEL_TOP_FRONT_CENTER   // 15,
	top_front_right    = C.MA_CHANNEL_TOP_FRONT_RIGHT    // 16,
	top_back_left      = C.MA_CHANNEL_TOP_BACK_LEFT      // 17,
	top_back_center    = C.MA_CHANNEL_TOP_BACK_CENTER    // 18,
	top_back_right     = C.MA_CHANNEL_TOP_BACK_RIGHT     // 19,
	aux_0              = C.MA_CHANNEL_AUX_0              // 20,
	aux_1              = C.MA_CHANNEL_AUX_1              // 21,
	aux_2              = C.MA_CHANNEL_AUX_2              // 22,
	aux_3              = C.MA_CHANNEL_AUX_3              // 23,
	aux_4              = C.MA_CHANNEL_AUX_4              // 24,
	aux_5              = C.MA_CHANNEL_AUX_5              // 25,
	aux_6              = C.MA_CHANNEL_AUX_6              // 26,
	aux_7              = C.MA_CHANNEL_AUX_7              // 27,
	aux_8              = C.MA_CHANNEL_AUX_8              // 28,
	aux_9              = C.MA_CHANNEL_AUX_9              // 29,
	aux_10             = C.MA_CHANNEL_AUX_10             // 30,
	aux_11             = C.MA_CHANNEL_AUX_11             // 31,
	aux_12             = C.MA_CHANNEL_AUX_12             // 32,
	aux_13             = C.MA_CHANNEL_AUX_13             // 33,
	aux_14             = C.MA_CHANNEL_AUX_14             // 34,
	aux_15             = C.MA_CHANNEL_AUX_15             // 35,
	aux_16             = C.MA_CHANNEL_AUX_16             // 36,
	aux_17             = C.MA_CHANNEL_AUX_17             // 37,
	aux_18             = C.MA_CHANNEL_AUX_18             // 38,
	aux_19             = C.MA_CHANNEL_AUX_19             // 39,
	aux_20             = C.MA_CHANNEL_AUX_20             // 40,
	aux_21             = C.MA_CHANNEL_AUX_21             // 41,
	aux_22             = C.MA_CHANNEL_AUX_22             // 42,
	aux_23             = C.MA_CHANNEL_AUX_23             // 43,
	aux_24             = C.MA_CHANNEL_AUX_24             // 44,
	aux_25             = C.MA_CHANNEL_AUX_25             // 45,
	aux_26             = C.MA_CHANNEL_AUX_26             // 46,
	aux_27             = C.MA_CHANNEL_AUX_27             // 47,
	aux_28             = C.MA_CHANNEL_AUX_28             // 48,
	aux_29             = C.MA_CHANNEL_AUX_29             // 49,
	aux_30             = C.MA_CHANNEL_AUX_30             // 50,
	aux_31             = C.MA_CHANNEL_AUX_31             // 51,
	left               = C.MA_CHANNEL_LEFT               // MA_CHANNEL_FRONT_LEFT,
	right              = C.MA_CHANNEL_RIGHT              // MA_CHANNEL_FRONT_RIGHT,
	position_count     = C.MA_CHANNEL_POSITION_COUNT     // (MA_CHANNEL_AUX_31 + 1),
}

// Result is C.ma_result
pub enum Result {
	success                       = C.MA_SUCCESS                       // 0,
	error                         = C.MA_ERROR                         // -1, A generic error.
	invalid_args                  = C.MA_INVALID_ARGS                  // -2,
	invalid_operation             = C.MA_INVALID_OPERATION             // -3,
	out_of_memory                 = C.MA_OUT_OF_MEMORY                 // -4,
	out_of_range                  = C.MA_OUT_OF_RANGE                  // -5,
	access_denied                 = C.MA_ACCESS_DENIED                 // -6,
	does_not_exist                = C.MA_DOES_NOT_EXIST                // -7,
	already_exists                = C.MA_ALREADY_EXISTS                // -8,
	too_many_open_files           = C.MA_TOO_MANY_OPEN_FILES           // -9,
	invalid_file                  = C.MA_INVALID_FILE                  // -10,
	too_big                       = C.MA_TOO_BIG                       // -11,
	path_too_long                 = C.MA_PATH_TOO_LONG                 // -12,
	name_too_long                 = C.MA_NAME_TOO_LONG                 // -13,
	not_directory                 = C.MA_NOT_DIRECTORY                 // -14,
	is_directory                  = C.MA_IS_DIRECTORY                  // -15,
	directory_not_empty           = C.MA_DIRECTORY_NOT_EMPTY           // -16,
	at_end                        = C.MA_AT_END                        // -17,
	no_space                      = C.MA_NO_SPACE                      // -18,
	busy                          = C.MA_BUSY                          // -19,
	io_error                      = C.MA_IO_ERROR                      // -20,
	interrupt                     = C.MA_INTERRUPT                     // -21,
	unavailable                   = C.MA_UNAVAILABLE                   // -22,
	already_in_use                = C.MA_ALREADY_IN_USE                // -23,
	bad_address                   = C.MA_BAD_ADDRESS                   // -24,
	bad_seek                      = C.MA_BAD_SEEK                      // -25,
	bad_pipe                      = C.MA_BAD_PIPE                      // -26,
	deadlock                      = C.MA_DEADLOCK                      // -27,
	too_many_links                = C.MA_TOO_MANY_LINKS                // -28,
	not_implemented               = C.MA_NOT_IMPLEMENTED               // -29,
	no_message                    = C.MA_NO_MESSAGE                    // -30,
	bad_message                   = C.MA_BAD_MESSAGE                   // -31,
	no_data_available             = C.MA_NO_DATA_AVAILABLE             // -32,
	invalid_data                  = C.MA_INVALID_DATA                  // -33,
	timeout                       = C.MA_TIMEOUT                       // -34,
	no_network                    = C.MA_NO_NETWORK                    // -35,
	not_unique                    = C.MA_NOT_UNIQUE                    // -36,
	not_socket                    = C.MA_NOT_SOCKET                    // -37,
	no_address                    = C.MA_NO_ADDRESS                    // -38,
	bad_protocol                  = C.MA_BAD_PROTOCOL                  // -39,
	protocol_unavailable          = C.MA_PROTOCOL_UNAVAILABLE          // -40,
	protocol_not_supported        = C.MA_PROTOCOL_NOT_SUPPORTED        // -41,
	protocol_family_not_supported = C.MA_PROTOCOL_FAMILY_NOT_SUPPORTED // -42,
	address_family_not_supported  = C.MA_ADDRESS_FAMILY_NOT_SUPPORTED  // -43,
	socket_not_supported          = C.MA_SOCKET_NOT_SUPPORTED          // -44,
	connection_reset              = C.MA_CONNECTION_RESET              // -45,
	already_connected             = C.MA_ALREADY_CONNECTED             // -46,
	not_connected                 = C.MA_NOT_CONNECTED                 // -47,
	connection_refused            = C.MA_CONNECTION_REFUSED            // -48,
	no_host                       = C.MA_NO_HOST                       // -49,
	in_progress                   = C.MA_IN_PROGRESS                   // -50,
	cancelled                     = C.MA_CANCELLED                     // -51,
	memory_already_mapped         = C.MA_MEMORY_ALREADY_MAPPED         // -52,
	// -100, General miniaudio-specific errors.
	format_not_supported      = C.MA_FORMAT_NOT_SUPPORTED
	device_type_not_supported = C.MA_DEVICE_TYPE_NOT_SUPPORTED // -101,
	share_mode_not_supported  = C.MA_SHARE_MODE_NOT_SUPPORTED  // -102,
	no_backend                = C.MA_NO_BACKEND                // -103,
	no_device                 = C.MA_NO_DEVICE                 // -104,
	api_not_found             = C.MA_API_NOT_FOUND             // -105,
	invalid_device_config     = C.MA_INVALID_DEVICE_CONFIG     // -106,
	loop                      = C.MA_LOOP                      // -107,
	// -200, State errors.
	device_not_initialized     = C.MA_DEVICE_NOT_INITIALIZED
	device_already_initialized = C.MA_DEVICE_ALREADY_INITIALIZED // -201,
	device_not_started         = C.MA_DEVICE_NOT_STARTED         // -202,
	device_not_stopped         = C.MA_DEVICE_NOT_STOPPED         // -203,
	// -300, Operation errors.
	failed_to_init_backend         = C.MA_FAILED_TO_INIT_BACKEND
	failed_to_open_backend_device  = C.MA_FAILED_TO_OPEN_BACKEND_DEVICE  // -301,
	failed_to_start_backend_device = C.MA_FAILED_TO_START_BACKEND_DEVICE // -302,
	failed_to_stop_backend_device  = C.MA_FAILED_TO_STOP_BACKEND_DEVICE  // -303,
}

pub const min_channels = 1

pub const max_channels = 254

pub const max_filter_order = 8

// StreamFormat is C.ma_stream_format
pub enum StreamFormat {
	pcm = C.ma_stream_format_pcm // 0,
}

// StreamLayout is C.ma_stream_layout
pub enum StreamLayout {
	interleaved   = C.ma_stream_layout_interleaved // 0,
	deinterleaved = C.ma_stream_layout_deinterleaved
}

// DitherMode is C.ma_dither_mode
pub enum DitherMode {
	@none     = C.ma_dither_mode_none // 0,
	rectangle = C.ma_dither_mode_rectangle
	triangle  = C.ma_dither_mode_triangle
}

// Format is C.ma_format
pub enum Format {
	unknown = C.ma_format_unknown // 0, Mainly used for indicating an error, but also used as the default for the output format for decoders.
	u8      = C.ma_format_u8      // 1,
	s16     = C.ma_format_s16     // 2, Seems to be the most widely supported format.
	s24     = C.ma_format_s24     // 3, Tightly packed. 3 bytes per sample.
	s32     = C.ma_format_s32     // 4,
	f32     = C.ma_format_f32     // 5,
	count   = C.ma_format_count
}

// StandardSampleRate is C.ma_standard_sample_rate
pub enum StandardSampleRate {
	_48000  = C.ma_standard_sample_rate_48000  // 48000, Most common
	_44100  = C.ma_standard_sample_rate_44100  // 44100,
	_32000  = C.ma_standard_sample_rate_32000  // 32000, Lows
	_24000  = C.ma_standard_sample_rate_24000  // 24000,
	_22050  = C.ma_standard_sample_rate_22050  // 22050,
	_88200  = C.ma_standard_sample_rate_88200  // 88200, Highs
	_96000  = C.ma_standard_sample_rate_96000  // 96000,
	_176400 = C.ma_standard_sample_rate_176400 // 176400,
	_192000 = C.ma_standard_sample_rate_192000 // 192000,
	_16000  = C.ma_standard_sample_rate_16000  // 16000, Extreme lows
	_11025  = C.ma_standard_sample_rate_11025  // 11250,
	_8000   = C.ma_standard_sample_rate_8000   // 8000,
	_352800 = C.ma_standard_sample_rate_352800 // 352800, Extreme highs
	_384000 = C.ma_standard_sample_rate_384000 // 384000,
	min     = C.ma_standard_sample_rate_min    // ma_standard_sample_rate_8000,
	max     = C.ma_standard_sample_rate_max    // ma_standard_sample_rate_384000,
	count   = C.ma_standard_sample_rate_count  // 14, Need to maintain the count manually. Make sure this is updated if items are added to enum.
}

// ChannelMixMode is C.ma_channel_mix_mode
pub enum ChannelMixMode {
	rectangular    = C.ma_channel_mix_mode_rectangular    // 0, Simple averaging based on the plane(s) the channel is sitting on.
	simple         = C.ma_channel_mix_mode_simple         // Drop excess channels; zeroed out extra channels.
	custom_weights = C.ma_channel_mix_mode_custom_weights // Use custom weights specified in ma_channel_converter_config.
	default        = C.ma_channel_mix_mode_default        // ma_channel_mix_mode_rectangular,
}

// StandardChannelMap is C.ma_standard_channel_map
pub enum StandardChannelMap {
	microsoft = C.ma_standard_channel_map_microsoft
	alsa      = C.ma_standard_channel_map_alsa
	rfc3551   = C.ma_standard_channel_map_rfc3551 // Based off AIFF.
	flac      = C.ma_standard_channel_map_flac
	vorbis    = C.ma_standard_channel_map_vorbis
	sound4    = C.ma_standard_channel_map_sound4   // FreeBSD's sound(4).
	sndio     = C.ma_standard_channel_map_sndio    // www.sndio.org/tips.html
	webaudio  = C.ma_standard_channel_map_webaudio // ma_standard_channel_map_flac, https://webaudio.github.io/web-audio-api/#ChannelOrdering. Only 1, 2, 4 and 6 channels are defined, but can fill in the gaps with logical assumptions.
	default   = C.ma_standard_channel_map_default  // ma_standard_channel_map_microsoft,
}

// PerformanceProfile is C.ma_performance_profile
pub enum PerformanceProfile {
	low_latency  = C.ma_performance_profile_low_latency // 0,
	conservative = C.ma_performance_profile_conservative
}

@[typedef]
struct C.ma_allocation_callbacks {
pub mut:
	pUserData voidptr
	onMalloc  fn (sz usize, p_user_data voidptr) voidptr            // onMalloc)(size_t
	onRealloc fn (p voidptr, sz usize, p_user_data voidptr) voidptr // onRealloc)(void*
	onFree    fn (p voidptr, p_user_data voidptr)                   // onFree)(void*
}

pub type AllocationCallbacks = C.ma_allocation_callbacks

@[typedef]
struct C.ma_lcg {
pub mut:
	state int
}

pub type Lcg = C.ma_lcg

// ThreadPriority is C.ma_thread_priority
pub enum ThreadPriority {
	idle     = C.ma_thread_priority_idle     // -5,
	lowest   = C.ma_thread_priority_lowest   // -4,
	low      = C.ma_thread_priority_low      // -3,
	normal   = C.ma_thread_priority_normal   // -2,
	high     = C.ma_thread_priority_high     // -1,
	highest  = C.ma_thread_priority_highest  // 0,
	realtime = C.ma_thread_priority_realtime // 1,
	default  = C.ma_thread_priority_default  // 0,
}

/*
See miniaudio_default.c.v and miniaudio_windows.c.v
[typedef]
struct C.ma_event {
pub mut:
	value u32
	@lock C.ma_pthread_mutex_t
	cond  C.ma_pthread_cond_t
}
*/
pub type Event = C.ma_event

/*
See miniaudio_default.c.v and miniaudio_windows.c.v
[typedef]
struct C.ma_semaphore {
pub mut:
	value int
	@lock C.ma_pthread_mutex_t
	cond  C.ma_pthread_cond_t
}
*/

pub type Semaphore = C.ma_semaphore

// C: `MA_API void ma_version(ma_uint32* pMajor, ma_uint32* pMinor, ma_uint32* pRevision)`
fn C.ma_version(p_major &u32, p_minor &u32, p_revision &u32)

// version retrieves the version of miniaudio as separated integers. Each component can be NULL if it's not required.
pub fn version(p_major &u32, p_minor &u32, p_revision &u32) {
	C.ma_version(p_major, p_minor, p_revision)
}

// C: `MA_API const char* ma_version_string(void)`
fn C.ma_version_string() &char

// version_string retrieves the version of miniaudio as a string which can be useful for logging purposes.
pub fn version_string() &char {
	return C.ma_version_string()
}

/*
TODO Function: #define MA_ATTRIBUTE_FORMAT(fmt,va)
*/

pub const max_log_callbacks = 4

// LogCallbackProc thes callback for handling log messages.
//
//
// Parameters
//----------
// pUserData (in)
//    The user data pointer that was passed into ma_log_register_callback().
//
// logLevel (in)
//    The log level. This can be one of the following:
//
//    +----------------------+
//    | Log Level            |
//    +----------------------+
//    | MA_LOG_LEVEL_DEBUG   |
//    | MA_LOG_LEVEL_INFO    |
//    | MA_LOG_LEVEL_WARNING |
//    | MA_LOG_LEVEL_ERROR   |
//    +----------------------+
//
// pMessage (in)
//    The log message.
//
//
// Remarks
//-------
// Do not modify the state of the device from inside the callback.
// C: typedef void (* ma_log_callback_proc)(void* pUserData, ma_uint32 level, const char* pMessage);
pub type LogCallbackProc = fn (p_user_data voidptr, level u32, const_p_message &char)

@[typedef]
struct C.ma_log_callback {
pub mut:
	onLog     LogCallbackProc
	pUserData voidptr
}

pub type LogCallback = C.ma_log_callback

// C: `MA_API ma_log_callback ma_log_callback_init(ma_log_callback_proc onLog, void* pUserData)`
fn C.ma_log_callback_init(on_log LogCallbackProc, p_user_data voidptr) LogCallback

// log_callback_init is currently undocumented
pub fn log_callback_init(on_log LogCallbackProc, p_user_data voidptr) LogCallback {
	return C.ma_log_callback_init(on_log, p_user_data)
}

@[typedef]
struct C.ma_log {
pub mut:
	// TODO 	callbacks [MA_MAX_LOG_CALLBACKS]LogCallback
	callbackCount       u32
	allocationCallbacks AllocationCallbacks // Need to store these persistently because ma_log_postv() might need to allocate a buffer on the heap.
	// TODO 	MA_NO_THREADING C.#ifndef // ma_mutex For thread safety just to make it easier and safer for the logging implementation.
}

pub type Log = C.ma_log

// C: `MA_API ma_result ma_log_init(const ma_allocation_callbacks* pAllocationCallbacks, ma_log* pLog)`
fn C.ma_log_init(const_p_allocation_callbacks &AllocationCallbacks, p_log &Log) Result

// log_init is currently undocumented
pub fn log_init(const_p_allocation_callbacks &AllocationCallbacks, p_log &Log) Result {
	return C.ma_log_init(const_p_allocation_callbacks, p_log)
}

// C: `MA_API void ma_log_uninit(ma_log* pLog)`
fn C.ma_log_uninit(p_log &Log)

// log_uninit is currently undocumented
pub fn log_uninit(p_log &Log) {
	C.ma_log_uninit(p_log)
}

// C: `MA_API ma_result ma_log_register_callback(ma_log* pLog, ma_log_callback callback)`
fn C.ma_log_register_callback(p_log &Log, callback LogCallback) Result

// log_register_callback is currently undocumented
pub fn log_register_callback(p_log &Log, callback LogCallback) Result {
	return C.ma_log_register_callback(p_log, callback)
}

// C: `MA_API ma_result ma_log_unregister_callback(ma_log* pLog, ma_log_callback callback)`
fn C.ma_log_unregister_callback(p_log &Log, callback LogCallback) Result

// log_unregister_callback is currently undocumented
pub fn log_unregister_callback(p_log &Log, callback LogCallback) Result {
	return C.ma_log_unregister_callback(p_log, callback)
}

// C: `MA_API ma_result ma_log_post(ma_log* pLog, ma_uint32 level, const char* pMessage)`
fn C.ma_log_post(p_log &Log, level u32, const_p_message &char) Result

// log_post is currently undocumented
pub fn log_post(p_log &Log, level u32, const_p_message &char) Result {
	return C.ma_log_post(p_log, level, const_p_message)
}

// C: `MA_API ma_result ma_log_postv(ma_log* pLog, ma_uint32 level, const char* pFormat, va_list args)`
fn C.ma_log_postv(p_log &Log, level u32, const_p_format &char, args C.va_list) Result

// log_postv is currently undocumented
pub fn log_postv(p_log &Log, level u32, const_p_format &char, args C.va_list) Result {
	return C.ma_log_postv(p_log, level, const_p_format, args)
}

// Skipped:
/*
MA_API ma_result ma_log_postf(ma_log* pLog, ma_uint32 level, const char* pFormat, ...) MA_ATTRIBUTE_FORMAT(3, 4);
*/

@[typedef]
union C.ma_biquad_coefficient {
pub mut:
	f32 f32
	s32 int
}

pub type BiquadCoefficient = C.ma_biquad_coefficient

@[typedef]
struct C.ma_biquad_config {
pub mut:
	format   Format
	channels u32
	b0       f64
	b1       f64
	b2       f64
	a0       f64
	a1       f64
	a2       f64
}

pub type BiquadConfig = C.ma_biquad_config

// C: `MA_API ma_biquad_config ma_biquad_config_init(ma_format format, ma_uint32 channels, double b0, double b1, double b2, double a0, double a1, double a2)`
fn C.ma_biquad_config_init(format Format, channels u32, b0 f64, b1 f64, b2 f64, a0 f64, a1 f64, a2 f64) BiquadConfig

// biquad_config_init is currently undocumented
pub fn biquad_config_init(format Format, channels u32, b0 f64, b1 f64, b2 f64, a0 f64, a1 f64, a2 f64) BiquadConfig {
	return C.ma_biquad_config_init(format, channels, b0, b1, b2, a0, a1, a2)
}

@[typedef]
struct C.ma_biquad {
pub mut:
	format    Format
	channels  u32
	b0        BiquadCoefficient
	b1        BiquadCoefficient
	b2        BiquadCoefficient
	a1        BiquadCoefficient
	a2        BiquadCoefficient
	pR1       &BiquadCoefficient = unsafe { nil }
	pR2       &BiquadCoefficient = unsafe { nil } // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Biquad = C.ma_biquad

// C: `MA_API ma_result ma_biquad_get_heap_size(const ma_biquad_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_biquad_get_heap_size(const_p_config &BiquadConfig, p_heap_size_in_bytes &usize) Result

// biquad_get_heap_size is currently undocumented
pub fn biquad_get_heap_size(const_p_config &BiquadConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_biquad_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_biquad_init_preallocated(const ma_biquad_config* pConfig, void* pHeap, ma_biquad* pBQ)`
fn C.ma_biquad_init_preallocated(const_p_config &BiquadConfig, p_heap voidptr, p_bq &Biquad) Result

// biquad_init_preallocated is currently undocumented
pub fn biquad_init_preallocated(const_p_config &BiquadConfig, p_heap voidptr, p_bq &Biquad) Result {
	return C.ma_biquad_init_preallocated(const_p_config, p_heap, p_bq)
}

// C: `MA_API ma_result ma_biquad_init(const ma_biquad_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad* pBQ)`
fn C.ma_biquad_init(const_p_config &BiquadConfig, const_p_allocation_callbacks &AllocationCallbacks, p_bq &Biquad) Result

// biquad_init is currently undocumented
pub fn biquad_init(const_p_config &BiquadConfig, const_p_allocation_callbacks &AllocationCallbacks, p_bq &Biquad) Result {
	return C.ma_biquad_init(const_p_config, const_p_allocation_callbacks, p_bq)
}

// C: `MA_API void ma_biquad_uninit(ma_biquad* pBQ, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_biquad_uninit(p_bq &Biquad, const_p_allocation_callbacks &AllocationCallbacks)

// biquad_uninit is currently undocumented
pub fn biquad_uninit(p_bq &Biquad, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_biquad_uninit(p_bq, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_biquad_reinit(const ma_biquad_config* pConfig, ma_biquad* pBQ)`
fn C.ma_biquad_reinit(const_p_config &BiquadConfig, p_bq &Biquad) Result

// biquad_reinit is currently undocumented
pub fn biquad_reinit(const_p_config &BiquadConfig, p_bq &Biquad) Result {
	return C.ma_biquad_reinit(const_p_config, p_bq)
}

// C: `MA_API ma_result ma_biquad_clear_cache(ma_biquad* pBQ)`
fn C.ma_biquad_clear_cache(p_bq &Biquad) Result

// biquad_clear_cache is currently undocumented
pub fn biquad_clear_cache(p_bq &Biquad) Result {
	return C.ma_biquad_clear_cache(p_bq)
}

// C: `MA_API ma_result ma_biquad_process_pcm_frames(ma_biquad* pBQ, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_biquad_process_pcm_frames(p_bq &Biquad, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// biquad_process_pcm_frames is currently undocumented
pub fn biquad_process_pcm_frames(p_bq &Biquad, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_biquad_process_pcm_frames(p_bq, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_biquad_get_latency(const ma_biquad* pBQ)`
fn C.ma_biquad_get_latency(const_p_bq &Biquad) u32

// biquad_get_latency is currently undocumented
pub fn biquad_get_latency(const_p_bq &Biquad) u32 {
	return C.ma_biquad_get_latency(const_p_bq)
}

@[typedef]
struct C.ma_lpf1_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	q               f64
}

pub type Lpf1Config = C.ma_lpf1_config

@[typedef]
struct C.ma_lpf2_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	q               f64
}

pub type Lpf2Config = C.ma_lpf2_config

// C: `MA_API ma_lpf1_config ma_lpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)`
fn C.ma_lpf1_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64) Lpf1Config

// lpf1_config_init is currently undocumented
pub fn lpf1_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64) Lpf1Config {
	return C.ma_lpf1_config_init(format, channels, sample_rate, cutoff_frequency)
}

// C: `MA_API ma_lpf2_config ma_lpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)`
fn C.ma_lpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Lpf2Config

// lpf2_config_init is currently undocumented
pub fn lpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Lpf2Config {
	return C.ma_lpf2_config_init(format, channels, sample_rate, cutoff_frequency, q)
}

@[typedef]
struct C.ma_lpf1 {
pub mut:
	format    Format
	channels  u32
	a         BiquadCoefficient
	pR1       &BiquadCoefficient = unsafe { nil } // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Lpf1 = C.ma_lpf1

// C: `MA_API ma_result ma_lpf1_get_heap_size(const ma_lpf1_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_lpf1_get_heap_size(const_p_config &Lpf1Config, p_heap_size_in_bytes &usize) Result

// lpf1_get_heap_size is currently undocumented
pub fn lpf1_get_heap_size(const_p_config &Lpf1Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_lpf1_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_lpf1_init_preallocated(const ma_lpf1_config* pConfig, void* pHeap, ma_lpf1* pLPF)`
fn C.ma_lpf1_init_preallocated(const_p_config &Lpf1Config, p_heap voidptr, p_lpf &Lpf1) Result

// lpf1_init_preallocated is currently undocumented
pub fn lpf1_init_preallocated(const_p_config &Lpf1Config, p_heap voidptr, p_lpf &Lpf1) Result {
	return C.ma_lpf1_init_preallocated(const_p_config, p_heap, p_lpf)
}

// C: `MA_API ma_result ma_lpf1_init(const ma_lpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf1* pLPF)`
fn C.ma_lpf1_init(const_p_config &Lpf1Config, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf1) Result

// lpf1_init is currently undocumented
pub fn lpf1_init(const_p_config &Lpf1Config, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf1) Result {
	return C.ma_lpf1_init(const_p_config, const_p_allocation_callbacks, p_lpf)
}

// C: `MA_API void ma_lpf1_uninit(ma_lpf1* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_lpf1_uninit(p_lpf &Lpf1, const_p_allocation_callbacks &AllocationCallbacks)

// lpf1_uninit is currently undocumented
pub fn lpf1_uninit(p_lpf &Lpf1, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_lpf1_uninit(p_lpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_lpf1_reinit(const ma_lpf1_config* pConfig, ma_lpf1* pLPF)`
fn C.ma_lpf1_reinit(const_p_config &Lpf1Config, p_lpf &Lpf1) Result

// lpf1_reinit is currently undocumented
pub fn lpf1_reinit(const_p_config &Lpf1Config, p_lpf &Lpf1) Result {
	return C.ma_lpf1_reinit(const_p_config, p_lpf)
}

// C: `MA_API ma_result ma_lpf1_clear_cache(ma_lpf1* pLPF)`
fn C.ma_lpf1_clear_cache(p_lpf &Lpf1) Result

// lpf1_clear_cache is currently undocumented
pub fn lpf1_clear_cache(p_lpf &Lpf1) Result {
	return C.ma_lpf1_clear_cache(p_lpf)
}

// C: `MA_API ma_result ma_lpf1_process_pcm_frames(ma_lpf1* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_lpf1_process_pcm_frames(p_lpf &Lpf1, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// lpf1_process_pcm_frames is currently undocumented
pub fn lpf1_process_pcm_frames(p_lpf &Lpf1, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_lpf1_process_pcm_frames(p_lpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_lpf1_get_latency(const ma_lpf1* pLPF)`
fn C.ma_lpf1_get_latency(const_p_lpf &Lpf1) u32

// lpf1_get_latency is currently undocumented
pub fn lpf1_get_latency(const_p_lpf &Lpf1) u32 {
	return C.ma_lpf1_get_latency(const_p_lpf)
}

@[typedef]
struct C.ma_lpf2 {
pub mut:
	bq Biquad // The second order low-pass filter is implemented as a biquad filter.
}

pub type Lpf2 = C.ma_lpf2

// C: `MA_API ma_result ma_lpf2_get_heap_size(const ma_lpf2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_lpf2_get_heap_size(const_p_config &Lpf2Config, p_heap_size_in_bytes &usize) Result

// lpf2_get_heap_size is currently undocumented
pub fn lpf2_get_heap_size(const_p_config &Lpf2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_lpf2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_lpf2_init_preallocated(const ma_lpf2_config* pConfig, void* pHeap, ma_lpf2* pHPF)`
fn C.ma_lpf2_init_preallocated(const_p_config &Lpf2Config, p_heap voidptr, p_hpf &Lpf2) Result

// lpf2_init_preallocated is currently undocumented
pub fn lpf2_init_preallocated(const_p_config &Lpf2Config, p_heap voidptr, p_hpf &Lpf2) Result {
	return C.ma_lpf2_init_preallocated(const_p_config, p_heap, p_hpf)
}

// C: `MA_API ma_result ma_lpf2_init(const ma_lpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf2* pLPF)`
fn C.ma_lpf2_init(const_p_config &Lpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf2) Result

// lpf2_init is currently undocumented
pub fn lpf2_init(const_p_config &Lpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf2) Result {
	return C.ma_lpf2_init(const_p_config, const_p_allocation_callbacks, p_lpf)
}

// C: `MA_API void ma_lpf2_uninit(ma_lpf2* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_lpf2_uninit(p_lpf &Lpf2, const_p_allocation_callbacks &AllocationCallbacks)

// lpf2_uninit is currently undocumented
pub fn lpf2_uninit(p_lpf &Lpf2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_lpf2_uninit(p_lpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_lpf2_reinit(const ma_lpf2_config* pConfig, ma_lpf2* pLPF)`
fn C.ma_lpf2_reinit(const_p_config &Lpf2Config, p_lpf &Lpf2) Result

// lpf2_reinit is currently undocumented
pub fn lpf2_reinit(const_p_config &Lpf2Config, p_lpf &Lpf2) Result {
	return C.ma_lpf2_reinit(const_p_config, p_lpf)
}

// C: `MA_API ma_result ma_lpf2_clear_cache(ma_lpf2* pLPF)`
fn C.ma_lpf2_clear_cache(p_lpf &Lpf2) Result

// lpf2_clear_cache is currently undocumented
pub fn lpf2_clear_cache(p_lpf &Lpf2) Result {
	return C.ma_lpf2_clear_cache(p_lpf)
}

// C: `MA_API ma_result ma_lpf2_process_pcm_frames(ma_lpf2* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_lpf2_process_pcm_frames(p_lpf &Lpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// lpf2_process_pcm_frames is currently undocumented
pub fn lpf2_process_pcm_frames(p_lpf &Lpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_lpf2_process_pcm_frames(p_lpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_lpf2_get_latency(const ma_lpf2* pLPF)`
fn C.ma_lpf2_get_latency(const_p_lpf &Lpf2) u32

// lpf2_get_latency is currently undocumented
pub fn lpf2_get_latency(const_p_lpf &Lpf2) u32 {
	return C.ma_lpf2_get_latency(const_p_lpf)
}

@[typedef]
struct C.ma_lpf_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	order           u32 // If set to 0, will be treated as a passthrough (no filtering will be applied).
}

pub type LpfConfig = C.ma_lpf_config

// C: `MA_API ma_lpf_config ma_lpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_lpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) LpfConfig

// lpf_config_init is currently undocumented
pub fn lpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) LpfConfig {
	return C.ma_lpf_config_init(format, channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_lpf {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	lpf1Count  u32
	lpf2Count  u32
	pLPF1      &Lpf1 = unsafe { nil }
	pLPF2      &Lpf2 = unsafe { nil } // Memory management.
	_pHeap     voidptr
	_ownsHeap  u32
}

pub type Lpf = C.ma_lpf

// C: `MA_API ma_result ma_lpf_get_heap_size(const ma_lpf_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_lpf_get_heap_size(const_p_config &LpfConfig, p_heap_size_in_bytes &usize) Result

// lpf_get_heap_size is currently undocumented
pub fn lpf_get_heap_size(const_p_config &LpfConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_lpf_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_lpf_init_preallocated(const ma_lpf_config* pConfig, void* pHeap, ma_lpf* pLPF)`
fn C.ma_lpf_init_preallocated(const_p_config &LpfConfig, p_heap voidptr, p_lpf &Lpf) Result

// lpf_init_preallocated is currently undocumented
pub fn lpf_init_preallocated(const_p_config &LpfConfig, p_heap voidptr, p_lpf &Lpf) Result {
	return C.ma_lpf_init_preallocated(const_p_config, p_heap, p_lpf)
}

// C: `MA_API ma_result ma_lpf_init(const ma_lpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf* pLPF)`
fn C.ma_lpf_init(const_p_config &LpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf) Result

// lpf_init is currently undocumented
pub fn lpf_init(const_p_config &LpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_lpf &Lpf) Result {
	return C.ma_lpf_init(const_p_config, const_p_allocation_callbacks, p_lpf)
}

// C: `MA_API void ma_lpf_uninit(ma_lpf* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_lpf_uninit(p_lpf &Lpf, const_p_allocation_callbacks &AllocationCallbacks)

// lpf_uninit is currently undocumented
pub fn lpf_uninit(p_lpf &Lpf, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_lpf_uninit(p_lpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_lpf_reinit(const ma_lpf_config* pConfig, ma_lpf* pLPF)`
fn C.ma_lpf_reinit(const_p_config &LpfConfig, p_lpf &Lpf) Result

// lpf_reinit is currently undocumented
pub fn lpf_reinit(const_p_config &LpfConfig, p_lpf &Lpf) Result {
	return C.ma_lpf_reinit(const_p_config, p_lpf)
}

// C: `MA_API ma_result ma_lpf_clear_cache(ma_lpf* pLPF)`
fn C.ma_lpf_clear_cache(p_lpf &Lpf) Result

// lpf_clear_cache is currently undocumented
pub fn lpf_clear_cache(p_lpf &Lpf) Result {
	return C.ma_lpf_clear_cache(p_lpf)
}

// C: `MA_API ma_result ma_lpf_process_pcm_frames(ma_lpf* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_lpf_process_pcm_frames(p_lpf &Lpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// lpf_process_pcm_frames is currently undocumented
pub fn lpf_process_pcm_frames(p_lpf &Lpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_lpf_process_pcm_frames(p_lpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_lpf_get_latency(const ma_lpf* pLPF)`
fn C.ma_lpf_get_latency(const_p_lpf &Lpf) u32

// lpf_get_latency is currently undocumented
pub fn lpf_get_latency(const_p_lpf &Lpf) u32 {
	return C.ma_lpf_get_latency(const_p_lpf)
}

@[typedef]
struct C.ma_hpf1_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	q               f64
}

pub type Hpf1Config = C.ma_hpf1_config

@[typedef]
struct C.ma_hpf2_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	q               f64
}

pub type Hpf2Config = C.ma_hpf2_config

// C: `MA_API ma_hpf1_config ma_hpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)`
fn C.ma_hpf1_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64) Hpf1Config

// hpf1_config_init is currently undocumented
pub fn hpf1_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64) Hpf1Config {
	return C.ma_hpf1_config_init(format, channels, sample_rate, cutoff_frequency)
}

// C: `MA_API ma_hpf2_config ma_hpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)`
fn C.ma_hpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Hpf2Config

// hpf2_config_init is currently undocumented
pub fn hpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Hpf2Config {
	return C.ma_hpf2_config_init(format, channels, sample_rate, cutoff_frequency, q)
}

@[typedef]
struct C.ma_hpf1 {
pub mut:
	format    Format
	channels  u32
	a         BiquadCoefficient
	pR1       &BiquadCoefficient = unsafe { nil } // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Hpf1 = C.ma_hpf1

// C: `MA_API ma_result ma_hpf1_get_heap_size(const ma_hpf1_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_hpf1_get_heap_size(const_p_config &Hpf1Config, p_heap_size_in_bytes &usize) Result

// hpf1_get_heap_size is currently undocumented
pub fn hpf1_get_heap_size(const_p_config &Hpf1Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_hpf1_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_hpf1_init_preallocated(const ma_hpf1_config* pConfig, void* pHeap, ma_hpf1* pLPF)`
fn C.ma_hpf1_init_preallocated(const_p_config &Hpf1Config, p_heap voidptr, p_lpf &Hpf1) Result

// hpf1_init_preallocated is currently undocumented
pub fn hpf1_init_preallocated(const_p_config &Hpf1Config, p_heap voidptr, p_lpf &Hpf1) Result {
	return C.ma_hpf1_init_preallocated(const_p_config, p_heap, p_lpf)
}

// C: `MA_API ma_result ma_hpf1_init(const ma_hpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf1* pHPF)`
fn C.ma_hpf1_init(const_p_config &Hpf1Config, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf1) Result

// hpf1_init is currently undocumented
pub fn hpf1_init(const_p_config &Hpf1Config, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf1) Result {
	return C.ma_hpf1_init(const_p_config, const_p_allocation_callbacks, p_hpf)
}

// C: `MA_API void ma_hpf1_uninit(ma_hpf1* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hpf1_uninit(p_hpf &Hpf1, const_p_allocation_callbacks &AllocationCallbacks)

// hpf1_uninit is currently undocumented
pub fn hpf1_uninit(p_hpf &Hpf1, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hpf1_uninit(p_hpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_hpf1_reinit(const ma_hpf1_config* pConfig, ma_hpf1* pHPF)`
fn C.ma_hpf1_reinit(const_p_config &Hpf1Config, p_hpf &Hpf1) Result

// hpf1_reinit is currently undocumented
pub fn hpf1_reinit(const_p_config &Hpf1Config, p_hpf &Hpf1) Result {
	return C.ma_hpf1_reinit(const_p_config, p_hpf)
}

// C: `MA_API ma_result ma_hpf1_process_pcm_frames(ma_hpf1* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_hpf1_process_pcm_frames(p_hpf &Hpf1, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// hpf1_process_pcm_frames is currently undocumented
pub fn hpf1_process_pcm_frames(p_hpf &Hpf1, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_hpf1_process_pcm_frames(p_hpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_hpf1_get_latency(const ma_hpf1* pHPF)`
fn C.ma_hpf1_get_latency(const_p_hpf &Hpf1) u32

// hpf1_get_latency is currently undocumented
pub fn hpf1_get_latency(const_p_hpf &Hpf1) u32 {
	return C.ma_hpf1_get_latency(const_p_hpf)
}

@[typedef]
struct C.ma_hpf2 {
pub mut:
	bq Biquad // The second order high-pass filter is implemented as a biquad filter.
}

pub type Hpf2 = C.ma_hpf2

// C: `MA_API ma_result ma_hpf2_get_heap_size(const ma_hpf2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_hpf2_get_heap_size(const_p_config &Hpf2Config, p_heap_size_in_bytes &usize) Result

// hpf2_get_heap_size is currently undocumented
pub fn hpf2_get_heap_size(const_p_config &Hpf2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_hpf2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_hpf2_init_preallocated(const ma_hpf2_config* pConfig, void* pHeap, ma_hpf2* pHPF)`
fn C.ma_hpf2_init_preallocated(const_p_config &Hpf2Config, p_heap voidptr, p_hpf &Hpf2) Result

// hpf2_init_preallocated is currently undocumented
pub fn hpf2_init_preallocated(const_p_config &Hpf2Config, p_heap voidptr, p_hpf &Hpf2) Result {
	return C.ma_hpf2_init_preallocated(const_p_config, p_heap, p_hpf)
}

// C: `MA_API ma_result ma_hpf2_init(const ma_hpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf2* pHPF)`
fn C.ma_hpf2_init(const_p_config &Hpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf2) Result

// hpf2_init is currently undocumented
pub fn hpf2_init(const_p_config &Hpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf2) Result {
	return C.ma_hpf2_init(const_p_config, const_p_allocation_callbacks, p_hpf)
}

// C: `MA_API void ma_hpf2_uninit(ma_hpf2* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hpf2_uninit(p_hpf &Hpf2, const_p_allocation_callbacks &AllocationCallbacks)

// hpf2_uninit is currently undocumented
pub fn hpf2_uninit(p_hpf &Hpf2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hpf2_uninit(p_hpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_hpf2_reinit(const ma_hpf2_config* pConfig, ma_hpf2* pHPF)`
fn C.ma_hpf2_reinit(const_p_config &Hpf2Config, p_hpf &Hpf2) Result

// hpf2_reinit is currently undocumented
pub fn hpf2_reinit(const_p_config &Hpf2Config, p_hpf &Hpf2) Result {
	return C.ma_hpf2_reinit(const_p_config, p_hpf)
}

// C: `MA_API ma_result ma_hpf2_process_pcm_frames(ma_hpf2* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_hpf2_process_pcm_frames(p_hpf &Hpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// hpf2_process_pcm_frames is currently undocumented
pub fn hpf2_process_pcm_frames(p_hpf &Hpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_hpf2_process_pcm_frames(p_hpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_hpf2_get_latency(const ma_hpf2* pHPF)`
fn C.ma_hpf2_get_latency(const_p_hpf &Hpf2) u32

// hpf2_get_latency is currently undocumented
pub fn hpf2_get_latency(const_p_hpf &Hpf2) u32 {
	return C.ma_hpf2_get_latency(const_p_hpf)
}

@[typedef]
struct C.ma_hpf_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	order           u32 // If set to 0, will be treated as a passthrough (no filtering will be applied).
}

pub type HpfConfig = C.ma_hpf_config

// C: `MA_API ma_hpf_config ma_hpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_hpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) HpfConfig

// hpf_config_init is currently undocumented
pub fn hpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) HpfConfig {
	return C.ma_hpf_config_init(format, channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_hpf {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	hpf1Count  u32
	hpf2Count  u32
	pHPF1      &Hpf1 = unsafe { nil }
	pHPF2      &Hpf2 = unsafe { nil } // Memory management.
	_pHeap     voidptr
	_ownsHeap  u32
}

pub type Hpf = C.ma_hpf

// C: `MA_API ma_result ma_hpf_get_heap_size(const ma_hpf_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_hpf_get_heap_size(const_p_config &HpfConfig, p_heap_size_in_bytes &usize) Result

// hpf_get_heap_size is currently undocumented
pub fn hpf_get_heap_size(const_p_config &HpfConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_hpf_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_hpf_init_preallocated(const ma_hpf_config* pConfig, void* pHeap, ma_hpf* pLPF)`
fn C.ma_hpf_init_preallocated(const_p_config &HpfConfig, p_heap voidptr, p_lpf &Hpf) Result

// hpf_init_preallocated is currently undocumented
pub fn hpf_init_preallocated(const_p_config &HpfConfig, p_heap voidptr, p_lpf &Hpf) Result {
	return C.ma_hpf_init_preallocated(const_p_config, p_heap, p_lpf)
}

// C: `MA_API ma_result ma_hpf_init(const ma_hpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf* pHPF)`
fn C.ma_hpf_init(const_p_config &HpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf) Result

// hpf_init is currently undocumented
pub fn hpf_init(const_p_config &HpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_hpf &Hpf) Result {
	return C.ma_hpf_init(const_p_config, const_p_allocation_callbacks, p_hpf)
}

// C: `MA_API void ma_hpf_uninit(ma_hpf* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hpf_uninit(p_hpf &Hpf, const_p_allocation_callbacks &AllocationCallbacks)

// hpf_uninit is currently undocumented
pub fn hpf_uninit(p_hpf &Hpf, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hpf_uninit(p_hpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_hpf_reinit(const ma_hpf_config* pConfig, ma_hpf* pHPF)`
fn C.ma_hpf_reinit(const_p_config &HpfConfig, p_hpf &Hpf) Result

// hpf_reinit is currently undocumented
pub fn hpf_reinit(const_p_config &HpfConfig, p_hpf &Hpf) Result {
	return C.ma_hpf_reinit(const_p_config, p_hpf)
}

// C: `MA_API ma_result ma_hpf_process_pcm_frames(ma_hpf* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_hpf_process_pcm_frames(p_hpf &Hpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// hpf_process_pcm_frames is currently undocumented
pub fn hpf_process_pcm_frames(p_hpf &Hpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_hpf_process_pcm_frames(p_hpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_hpf_get_latency(const ma_hpf* pHPF)`
fn C.ma_hpf_get_latency(const_p_hpf &Hpf) u32

// hpf_get_latency is currently undocumented
pub fn hpf_get_latency(const_p_hpf &Hpf) u32 {
	return C.ma_hpf_get_latency(const_p_hpf)
}

@[typedef]
struct C.ma_bpf2_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	q               f64
}

pub type Bpf2Config = C.ma_bpf2_config

// C: `MA_API ma_bpf2_config ma_bpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)`
fn C.ma_bpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Bpf2Config

// bpf2_config_init is currently undocumented
pub fn bpf2_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, q f64) Bpf2Config {
	return C.ma_bpf2_config_init(format, channels, sample_rate, cutoff_frequency, q)
}

@[typedef]
struct C.ma_bpf2 {
pub mut:
	bq Biquad // The second order band-pass filter is implemented as a biquad filter.
}

pub type Bpf2 = C.ma_bpf2

// C: `MA_API ma_result ma_bpf2_get_heap_size(const ma_bpf2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_bpf2_get_heap_size(const_p_config &Bpf2Config, p_heap_size_in_bytes &usize) Result

// bpf2_get_heap_size is currently undocumented
pub fn bpf2_get_heap_size(const_p_config &Bpf2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_bpf2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_bpf2_init_preallocated(const ma_bpf2_config* pConfig, void* pHeap, ma_bpf2* pBPF)`
fn C.ma_bpf2_init_preallocated(const_p_config &Bpf2Config, p_heap voidptr, p_bpf &Bpf2) Result

// bpf2_init_preallocated is currently undocumented
pub fn bpf2_init_preallocated(const_p_config &Bpf2Config, p_heap voidptr, p_bpf &Bpf2) Result {
	return C.ma_bpf2_init_preallocated(const_p_config, p_heap, p_bpf)
}

// C: `MA_API ma_result ma_bpf2_init(const ma_bpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf2* pBPF)`
fn C.ma_bpf2_init(const_p_config &Bpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_bpf &Bpf2) Result

// bpf2_init is currently undocumented
pub fn bpf2_init(const_p_config &Bpf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_bpf &Bpf2) Result {
	return C.ma_bpf2_init(const_p_config, const_p_allocation_callbacks, p_bpf)
}

// C: `MA_API void ma_bpf2_uninit(ma_bpf2* pBPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_bpf2_uninit(p_bpf &Bpf2, const_p_allocation_callbacks &AllocationCallbacks)

// bpf2_uninit is currently undocumented
pub fn bpf2_uninit(p_bpf &Bpf2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_bpf2_uninit(p_bpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_bpf2_reinit(const ma_bpf2_config* pConfig, ma_bpf2* pBPF)`
fn C.ma_bpf2_reinit(const_p_config &Bpf2Config, p_bpf &Bpf2) Result

// bpf2_reinit is currently undocumented
pub fn bpf2_reinit(const_p_config &Bpf2Config, p_bpf &Bpf2) Result {
	return C.ma_bpf2_reinit(const_p_config, p_bpf)
}

// C: `MA_API ma_result ma_bpf2_process_pcm_frames(ma_bpf2* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_bpf2_process_pcm_frames(p_bpf &Bpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// bpf2_process_pcm_frames is currently undocumented
pub fn bpf2_process_pcm_frames(p_bpf &Bpf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_bpf2_process_pcm_frames(p_bpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_bpf2_get_latency(const ma_bpf2* pBPF)`
fn C.ma_bpf2_get_latency(const_p_bpf &Bpf2) u32

// bpf2_get_latency is currently undocumented
pub fn bpf2_get_latency(const_p_bpf &Bpf2) u32 {
	return C.ma_bpf2_get_latency(const_p_bpf)
}

@[typedef]
struct C.ma_bpf_config {
pub mut:
	format          Format
	channels        u32
	sampleRate      u32
	cutoffFrequency f64
	order           u32 // If set to 0, will be treated as a passthrough (no filtering will be applied).
}

pub type BpfConfig = C.ma_bpf_config

// C: `MA_API ma_bpf_config ma_bpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_bpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) BpfConfig

// bpf_config_init is currently undocumented
pub fn bpf_config_init(format Format, channels u32, sample_rate u32, cutoff_frequency f64, order u32) BpfConfig {
	return C.ma_bpf_config_init(format, channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_bpf {
pub mut:
	format    Format
	channels  u32
	bpf2Count u32
	pBPF2     &Bpf2 = unsafe { nil } // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Bpf = C.ma_bpf

// C: `MA_API ma_result ma_bpf_get_heap_size(const ma_bpf_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_bpf_get_heap_size(const_p_config &BpfConfig, p_heap_size_in_bytes &usize) Result

// bpf_get_heap_size is currently undocumented
pub fn bpf_get_heap_size(const_p_config &BpfConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_bpf_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_bpf_init_preallocated(const ma_bpf_config* pConfig, void* pHeap, ma_bpf* pBPF)`
fn C.ma_bpf_init_preallocated(const_p_config &BpfConfig, p_heap voidptr, p_bpf &Bpf) Result

// bpf_init_preallocated is currently undocumented
pub fn bpf_init_preallocated(const_p_config &BpfConfig, p_heap voidptr, p_bpf &Bpf) Result {
	return C.ma_bpf_init_preallocated(const_p_config, p_heap, p_bpf)
}

// C: `MA_API ma_result ma_bpf_init(const ma_bpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf* pBPF)`
fn C.ma_bpf_init(const_p_config &BpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_bpf &Bpf) Result

// bpf_init is currently undocumented
pub fn bpf_init(const_p_config &BpfConfig, const_p_allocation_callbacks &AllocationCallbacks, p_bpf &Bpf) Result {
	return C.ma_bpf_init(const_p_config, const_p_allocation_callbacks, p_bpf)
}

// C: `MA_API void ma_bpf_uninit(ma_bpf* pBPF, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_bpf_uninit(p_bpf &Bpf, const_p_allocation_callbacks &AllocationCallbacks)

// bpf_uninit is currently undocumented
pub fn bpf_uninit(p_bpf &Bpf, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_bpf_uninit(p_bpf, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_bpf_reinit(const ma_bpf_config* pConfig, ma_bpf* pBPF)`
fn C.ma_bpf_reinit(const_p_config &BpfConfig, p_bpf &Bpf) Result

// bpf_reinit is currently undocumented
pub fn bpf_reinit(const_p_config &BpfConfig, p_bpf &Bpf) Result {
	return C.ma_bpf_reinit(const_p_config, p_bpf)
}

// C: `MA_API ma_result ma_bpf_process_pcm_frames(ma_bpf* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_bpf_process_pcm_frames(p_bpf &Bpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// bpf_process_pcm_frames is currently undocumented
pub fn bpf_process_pcm_frames(p_bpf &Bpf, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_bpf_process_pcm_frames(p_bpf, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_bpf_get_latency(const ma_bpf* pBPF)`
fn C.ma_bpf_get_latency(const_p_bpf &Bpf) u32

// bpf_get_latency is currently undocumented
pub fn bpf_get_latency(const_p_bpf &Bpf) u32 {
	return C.ma_bpf_get_latency(const_p_bpf)
}

@[typedef]
struct C.ma_notch2_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	q          f64
	frequency  f64
}

pub type Notch2Config = C.ma_notch2_config

@[typedef]
struct C.ma_notch_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	q          f64
	frequency  f64
}

pub type NotchConfig = C.ma_notch_config

// C: `MA_API ma_notch2_config ma_notch2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency)`
fn C.ma_notch2_config_init(format Format, channels u32, sample_rate u32, q f64, frequency f64) Notch2Config

// notch2_config_init is currently undocumented
pub fn notch2_config_init(format Format, channels u32, sample_rate u32, q f64, frequency f64) Notch2Config {
	return C.ma_notch2_config_init(format, channels, sample_rate, q, frequency)
}

@[typedef]
struct C.ma_notch2 {
pub mut:
	bq Biquad
}

pub type Notch2 = C.ma_notch2

// C: `MA_API ma_result ma_notch2_get_heap_size(const ma_notch2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_notch2_get_heap_size(const_p_config &Notch2Config, p_heap_size_in_bytes &usize) Result

// notch2_get_heap_size is currently undocumented
pub fn notch2_get_heap_size(const_p_config &Notch2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_notch2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_notch2_init_preallocated(const ma_notch2_config* pConfig, void* pHeap, ma_notch2* pFilter)`
fn C.ma_notch2_init_preallocated(const_p_config &Notch2Config, p_heap voidptr, p_filter &Notch2) Result

// notch2_init_preallocated is currently undocumented
pub fn notch2_init_preallocated(const_p_config &Notch2Config, p_heap voidptr, p_filter &Notch2) Result {
	return C.ma_notch2_init_preallocated(const_p_config, p_heap, p_filter)
}

// C: `MA_API ma_result ma_notch2_init(const ma_notch2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch2* pFilter)`
fn C.ma_notch2_init(const_p_config &Notch2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Notch2) Result

// notch2_init is currently undocumented
pub fn notch2_init(const_p_config &Notch2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Notch2) Result {
	return C.ma_notch2_init(const_p_config, const_p_allocation_callbacks, p_filter)
}

// C: `MA_API void ma_notch2_uninit(ma_notch2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_notch2_uninit(p_filter &Notch2, const_p_allocation_callbacks &AllocationCallbacks)

// notch2_uninit is currently undocumented
pub fn notch2_uninit(p_filter &Notch2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_notch2_uninit(p_filter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_notch2_reinit(const ma_notch2_config* pConfig, ma_notch2* pFilter)`
fn C.ma_notch2_reinit(const_p_config &Notch2Config, p_filter &Notch2) Result

// notch2_reinit is currently undocumented
pub fn notch2_reinit(const_p_config &Notch2Config, p_filter &Notch2) Result {
	return C.ma_notch2_reinit(const_p_config, p_filter)
}

// C: `MA_API ma_result ma_notch2_process_pcm_frames(ma_notch2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_notch2_process_pcm_frames(p_filter &Notch2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// notch2_process_pcm_frames is currently undocumented
pub fn notch2_process_pcm_frames(p_filter &Notch2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_notch2_process_pcm_frames(p_filter, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_notch2_get_latency(const ma_notch2* pFilter)`
fn C.ma_notch2_get_latency(const_p_filter &Notch2) u32

// notch2_get_latency is currently undocumented
pub fn notch2_get_latency(const_p_filter &Notch2) u32 {
	return C.ma_notch2_get_latency(const_p_filter)
}

@[typedef]
struct C.ma_peak2_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	q          f64
	frequency  f64
}

pub type Peak2Config = C.ma_peak2_config

@[typedef]
struct C.ma_peak_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	q          f64
	frequency  f64
}

pub type PeakConfig = C.ma_peak_config

// C: `MA_API ma_peak2_config ma_peak2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)`
fn C.ma_peak2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) Peak2Config

// peak2_config_init is currently undocumented
pub fn peak2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) Peak2Config {
	return C.ma_peak2_config_init(format, channels, sample_rate, gain_db, q, frequency)
}

@[typedef]
struct C.ma_peak2 {
pub mut:
	bq Biquad
}

pub type Peak2 = C.ma_peak2

// C: `MA_API ma_result ma_peak2_get_heap_size(const ma_peak2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_peak2_get_heap_size(const_p_config &Peak2Config, p_heap_size_in_bytes &usize) Result

// peak2_get_heap_size is currently undocumented
pub fn peak2_get_heap_size(const_p_config &Peak2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_peak2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_peak2_init_preallocated(const ma_peak2_config* pConfig, void* pHeap, ma_peak2* pFilter)`
fn C.ma_peak2_init_preallocated(const_p_config &Peak2Config, p_heap voidptr, p_filter &Peak2) Result

// peak2_init_preallocated is currently undocumented
pub fn peak2_init_preallocated(const_p_config &Peak2Config, p_heap voidptr, p_filter &Peak2) Result {
	return C.ma_peak2_init_preallocated(const_p_config, p_heap, p_filter)
}

// C: `MA_API ma_result ma_peak2_init(const ma_peak2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak2* pFilter)`
fn C.ma_peak2_init(const_p_config &Peak2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Peak2) Result

// peak2_init is currently undocumented
pub fn peak2_init(const_p_config &Peak2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Peak2) Result {
	return C.ma_peak2_init(const_p_config, const_p_allocation_callbacks, p_filter)
}

// C: `MA_API void ma_peak2_uninit(ma_peak2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_peak2_uninit(p_filter &Peak2, const_p_allocation_callbacks &AllocationCallbacks)

// peak2_uninit is currently undocumented
pub fn peak2_uninit(p_filter &Peak2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_peak2_uninit(p_filter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_peak2_reinit(const ma_peak2_config* pConfig, ma_peak2* pFilter)`
fn C.ma_peak2_reinit(const_p_config &Peak2Config, p_filter &Peak2) Result

// peak2_reinit is currently undocumented
pub fn peak2_reinit(const_p_config &Peak2Config, p_filter &Peak2) Result {
	return C.ma_peak2_reinit(const_p_config, p_filter)
}

// C: `MA_API ma_result ma_peak2_process_pcm_frames(ma_peak2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_peak2_process_pcm_frames(p_filter &Peak2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// peak2_process_pcm_frames is currently undocumented
pub fn peak2_process_pcm_frames(p_filter &Peak2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_peak2_process_pcm_frames(p_filter, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_peak2_get_latency(const ma_peak2* pFilter)`
fn C.ma_peak2_get_latency(const_p_filter &Peak2) u32

// peak2_get_latency is currently undocumented
pub fn peak2_get_latency(const_p_filter &Peak2) u32 {
	return C.ma_peak2_get_latency(const_p_filter)
}

@[typedef]
struct C.ma_loshelf2_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	shelfSlope f64
	frequency  f64
}

pub type Loshelf2Config = C.ma_loshelf2_config

@[typedef]
struct C.ma_loshelf_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	shelfSlope f64
	frequency  f64
}

pub type LoshelfConfig = C.ma_loshelf_config

// C: `MA_API ma_loshelf2_config ma_loshelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency)`
fn C.ma_loshelf2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, shelf_slope f64, frequency f64) Loshelf2Config

// loshelf2_config_init is currently undocumented
pub fn loshelf2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, shelf_slope f64, frequency f64) Loshelf2Config {
	return C.ma_loshelf2_config_init(format, channels, sample_rate, gain_db, shelf_slope,
		frequency)
}

@[typedef]
struct C.ma_loshelf2 {
pub mut:
	bq Biquad
}

pub type Loshelf2 = C.ma_loshelf2

// C: `MA_API ma_result ma_loshelf2_get_heap_size(const ma_loshelf2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_loshelf2_get_heap_size(const_p_config &Loshelf2Config, p_heap_size_in_bytes &usize) Result

// loshelf2_get_heap_size is currently undocumented
pub fn loshelf2_get_heap_size(const_p_config &Loshelf2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_loshelf2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_loshelf2_init_preallocated(const ma_loshelf2_config* pConfig, void* pHeap, ma_loshelf2* pFilter)`
fn C.ma_loshelf2_init_preallocated(const_p_config &Loshelf2Config, p_heap voidptr, p_filter &Loshelf2) Result

// loshelf2_init_preallocated is currently undocumented
pub fn loshelf2_init_preallocated(const_p_config &Loshelf2Config, p_heap voidptr, p_filter &Loshelf2) Result {
	return C.ma_loshelf2_init_preallocated(const_p_config, p_heap, p_filter)
}

// C: `MA_API ma_result ma_loshelf2_init(const ma_loshelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf2* pFilter)`
fn C.ma_loshelf2_init(const_p_config &Loshelf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Loshelf2) Result

// loshelf2_init is currently undocumented
pub fn loshelf2_init(const_p_config &Loshelf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Loshelf2) Result {
	return C.ma_loshelf2_init(const_p_config, const_p_allocation_callbacks, p_filter)
}

// C: `MA_API void ma_loshelf2_uninit(ma_loshelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_loshelf2_uninit(p_filter &Loshelf2, const_p_allocation_callbacks &AllocationCallbacks)

// loshelf2_uninit is currently undocumented
pub fn loshelf2_uninit(p_filter &Loshelf2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_loshelf2_uninit(p_filter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_loshelf2_reinit(const ma_loshelf2_config* pConfig, ma_loshelf2* pFilter)`
fn C.ma_loshelf2_reinit(const_p_config &Loshelf2Config, p_filter &Loshelf2) Result

// loshelf2_reinit is currently undocumented
pub fn loshelf2_reinit(const_p_config &Loshelf2Config, p_filter &Loshelf2) Result {
	return C.ma_loshelf2_reinit(const_p_config, p_filter)
}

// C: `MA_API ma_result ma_loshelf2_process_pcm_frames(ma_loshelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_loshelf2_process_pcm_frames(p_filter &Loshelf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// loshelf2_process_pcm_frames is currently undocumented
pub fn loshelf2_process_pcm_frames(p_filter &Loshelf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_loshelf2_process_pcm_frames(p_filter, p_frames_out, const_p_frames_in,
		frame_count)
}

// C: `MA_API ma_uint32 ma_loshelf2_get_latency(const ma_loshelf2* pFilter)`
fn C.ma_loshelf2_get_latency(const_p_filter &Loshelf2) u32

// loshelf2_get_latency is currently undocumented
pub fn loshelf2_get_latency(const_p_filter &Loshelf2) u32 {
	return C.ma_loshelf2_get_latency(const_p_filter)
}

@[typedef]
struct C.ma_hishelf2_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	shelfSlope f64
	frequency  f64
}

pub type Hishelf2Config = C.ma_hishelf2_config

@[typedef]
struct C.ma_hishelf_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	gainDB     f64
	shelfSlope f64
	frequency  f64
}

pub type HishelfConfig = C.ma_hishelf_config

// C: `MA_API ma_hishelf2_config ma_hishelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency)`
fn C.ma_hishelf2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, shelf_slope f64, frequency f64) Hishelf2Config

// hishelf2_config_init is currently undocumented
pub fn hishelf2_config_init(format Format, channels u32, sample_rate u32, gain_db f64, shelf_slope f64, frequency f64) Hishelf2Config {
	return C.ma_hishelf2_config_init(format, channels, sample_rate, gain_db, shelf_slope,
		frequency)
}

@[typedef]
struct C.ma_hishelf2 {
pub mut:
	bq Biquad
}

pub type Hishelf2 = C.ma_hishelf2

// C: `MA_API ma_result ma_hishelf2_get_heap_size(const ma_hishelf2_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_hishelf2_get_heap_size(const_p_config &Hishelf2Config, p_heap_size_in_bytes &usize) Result

// hishelf2_get_heap_size is currently undocumented
pub fn hishelf2_get_heap_size(const_p_config &Hishelf2Config, p_heap_size_in_bytes &usize) Result {
	return C.ma_hishelf2_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_hishelf2_init_preallocated(const ma_hishelf2_config* pConfig, void* pHeap, ma_hishelf2* pFilter)`
fn C.ma_hishelf2_init_preallocated(const_p_config &Hishelf2Config, p_heap voidptr, p_filter &Hishelf2) Result

// hishelf2_init_preallocated is currently undocumented
pub fn hishelf2_init_preallocated(const_p_config &Hishelf2Config, p_heap voidptr, p_filter &Hishelf2) Result {
	return C.ma_hishelf2_init_preallocated(const_p_config, p_heap, p_filter)
}

// C: `MA_API ma_result ma_hishelf2_init(const ma_hishelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf2* pFilter)`
fn C.ma_hishelf2_init(const_p_config &Hishelf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Hishelf2) Result

// hishelf2_init is currently undocumented
pub fn hishelf2_init(const_p_config &Hishelf2Config, const_p_allocation_callbacks &AllocationCallbacks, p_filter &Hishelf2) Result {
	return C.ma_hishelf2_init(const_p_config, const_p_allocation_callbacks, p_filter)
}

// C: `MA_API void ma_hishelf2_uninit(ma_hishelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hishelf2_uninit(p_filter &Hishelf2, const_p_allocation_callbacks &AllocationCallbacks)

// hishelf2_uninit is currently undocumented
pub fn hishelf2_uninit(p_filter &Hishelf2, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hishelf2_uninit(p_filter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_hishelf2_reinit(const ma_hishelf2_config* pConfig, ma_hishelf2* pFilter)`
fn C.ma_hishelf2_reinit(const_p_config &Hishelf2Config, p_filter &Hishelf2) Result

// hishelf2_reinit is currently undocumented
pub fn hishelf2_reinit(const_p_config &Hishelf2Config, p_filter &Hishelf2) Result {
	return C.ma_hishelf2_reinit(const_p_config, p_filter)
}

// C: `MA_API ma_result ma_hishelf2_process_pcm_frames(ma_hishelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_hishelf2_process_pcm_frames(p_filter &Hishelf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// hishelf2_process_pcm_frames is currently undocumented
pub fn hishelf2_process_pcm_frames(p_filter &Hishelf2, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_hishelf2_process_pcm_frames(p_filter, p_frames_out, const_p_frames_in,
		frame_count)
}

// C: `MA_API ma_uint32 ma_hishelf2_get_latency(const ma_hishelf2* pFilter)`
fn C.ma_hishelf2_get_latency(const_p_filter &Hishelf2) u32

// hishelf2_get_latency is currently undocumented
pub fn hishelf2_get_latency(const_p_filter &Hishelf2) u32 {
	return C.ma_hishelf2_get_latency(const_p_filter)
}

@[typedef]
struct C.ma_delay_config {
pub mut:
	channels      u32
	sampleRate    u32
	delayInFrames u32
	delayStart    u32 // Set to true to delay the start of the output
	// TODO 	otherwise.*/ C.false
	wet   f32 // 0..1. Default = 1.
	dry   f32 // 0..1. Default = 1.
	decay f32 // 0..1. Default = 0 (no feedback). Feedback decay. Use this for echo.
}

pub type DelayConfig = C.ma_delay_config

// C: `MA_API ma_delay_config ma_delay_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay)`
fn C.ma_delay_config_init(channels u32, sample_rate u32, delay_in_frames u32, decay f32) DelayConfig

// delay_config_init is currently undocumented
pub fn delay_config_init(channels u32, sample_rate u32, delay_in_frames u32, decay f32) DelayConfig {
	return C.ma_delay_config_init(channels, sample_rate, delay_in_frames, decay)
}

@[typedef]
struct C.ma_delay {
pub mut:
	config             DelayConfig
	cursor             u32 // Feedback is written to this cursor. Always equal or in front of the read cursor.
	bufferSizeInFrames u32
	pBuffer            &f32 = unsafe { nil }
}

pub type Delay = C.ma_delay

// C: `MA_API ma_result ma_delay_init(const ma_delay_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay* pDelay)`
fn C.ma_delay_init(const_p_config &DelayConfig, const_p_allocation_callbacks &AllocationCallbacks, p_delay &Delay) Result

// delay_init is currently undocumented
pub fn delay_init(const_p_config &DelayConfig, const_p_allocation_callbacks &AllocationCallbacks, p_delay &Delay) Result {
	return C.ma_delay_init(const_p_config, const_p_allocation_callbacks, p_delay)
}

// C: `MA_API void ma_delay_uninit(ma_delay* pDelay, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_delay_uninit(p_delay &Delay, const_p_allocation_callbacks &AllocationCallbacks)

// delay_uninit is currently undocumented
pub fn delay_uninit(p_delay &Delay, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_delay_uninit(p_delay, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_delay_process_pcm_frames(ma_delay* pDelay, void* pFramesOut, const void* pFramesIn, ma_uint32 frameCount)`
fn C.ma_delay_process_pcm_frames(p_delay &Delay, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u32) Result

// delay_process_pcm_frames is currently undocumented
pub fn delay_process_pcm_frames(p_delay &Delay, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u32) Result {
	return C.ma_delay_process_pcm_frames(p_delay, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API void ma_delay_set_wet(ma_delay* pDelay, float value)`
fn C.ma_delay_set_wet(p_delay &Delay, value f32)

// delay_set_wet is currently undocumented
pub fn delay_set_wet(p_delay &Delay, value f32) {
	C.ma_delay_set_wet(p_delay, value)
}

// C: `MA_API float ma_delay_get_wet(const ma_delay* pDelay)`
fn C.ma_delay_get_wet(const_p_delay &Delay) f32

// delay_get_wet is currently undocumented
pub fn delay_get_wet(const_p_delay &Delay) f32 {
	return C.ma_delay_get_wet(const_p_delay)
}

// C: `MA_API void ma_delay_set_dry(ma_delay* pDelay, float value)`
fn C.ma_delay_set_dry(p_delay &Delay, value f32)

// delay_set_dry is currently undocumented
pub fn delay_set_dry(p_delay &Delay, value f32) {
	C.ma_delay_set_dry(p_delay, value)
}

// C: `MA_API float ma_delay_get_dry(const ma_delay* pDelay)`
fn C.ma_delay_get_dry(const_p_delay &Delay) f32

// delay_get_dry is currently undocumented
pub fn delay_get_dry(const_p_delay &Delay) f32 {
	return C.ma_delay_get_dry(const_p_delay)
}

// C: `MA_API void ma_delay_set_decay(ma_delay* pDelay, float value)`
fn C.ma_delay_set_decay(p_delay &Delay, value f32)

// delay_set_decay is currently undocumented
pub fn delay_set_decay(p_delay &Delay, value f32) {
	C.ma_delay_set_decay(p_delay, value)
}

// C: `MA_API float ma_delay_get_decay(const ma_delay* pDelay)`
fn C.ma_delay_get_decay(const_p_delay &Delay) f32

// delay_get_decay is currently undocumented
pub fn delay_get_decay(const_p_delay &Delay) f32 {
	return C.ma_delay_get_decay(const_p_delay)
}

@[typedef]
struct C.ma_gainer_config {
pub mut:
	channels           u32
	smoothTimeInFrames u32
}

pub type GainerConfig = C.ma_gainer_config

// C: `MA_API ma_gainer_config ma_gainer_config_init(ma_uint32 channels, ma_uint32 smoothTimeInFrames)`
fn C.ma_gainer_config_init(channels u32, smooth_time_in_frames u32) GainerConfig

// gainer_config_init is currently undocumented
pub fn gainer_config_init(channels u32, smooth_time_in_frames u32) GainerConfig {
	return C.ma_gainer_config_init(channels, smooth_time_in_frames)
}

@[typedef]
struct C.ma_gainer {
pub mut:
	config    GainerConfig
	t         u32
	pOldGains &f32 = unsafe { nil }
	pNewGains &f32 = unsafe { nil } // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Gainer = C.ma_gainer

// C: `MA_API ma_result ma_gainer_get_heap_size(const ma_gainer_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_gainer_get_heap_size(const_p_config &GainerConfig, p_heap_size_in_bytes &usize) Result

// gainer_get_heap_size is currently undocumented
pub fn gainer_get_heap_size(const_p_config &GainerConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_gainer_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_gainer_init_preallocated(const ma_gainer_config* pConfig, void* pHeap, ma_gainer* pGainer)`
fn C.ma_gainer_init_preallocated(const_p_config &GainerConfig, p_heap voidptr, p_gainer &Gainer) Result

// gainer_init_preallocated is currently undocumented
pub fn gainer_init_preallocated(const_p_config &GainerConfig, p_heap voidptr, p_gainer &Gainer) Result {
	return C.ma_gainer_init_preallocated(const_p_config, p_heap, p_gainer)
}

// C: `MA_API ma_result ma_gainer_init(const ma_gainer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_gainer* pGainer)`
fn C.ma_gainer_init(const_p_config &GainerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_gainer &Gainer) Result

// gainer_init is currently undocumented
pub fn gainer_init(const_p_config &GainerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_gainer &Gainer) Result {
	return C.ma_gainer_init(const_p_config, const_p_allocation_callbacks, p_gainer)
}

// C: `MA_API void ma_gainer_uninit(ma_gainer* pGainer, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_gainer_uninit(p_gainer &Gainer, const_p_allocation_callbacks &AllocationCallbacks)

// gainer_uninit is currently undocumented
pub fn gainer_uninit(p_gainer &Gainer, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_gainer_uninit(p_gainer, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_gainer_process_pcm_frames(ma_gainer* pGainer, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_gainer_process_pcm_frames(p_gainer &Gainer, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// gainer_process_pcm_frames is currently undocumented
pub fn gainer_process_pcm_frames(p_gainer &Gainer, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_gainer_process_pcm_frames(p_gainer, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API ma_result ma_gainer_set_gain(ma_gainer* pGainer, float newGain)`
fn C.ma_gainer_set_gain(p_gainer &Gainer, new_gain f32) Result

// gainer_set_gain is currently undocumented
pub fn gainer_set_gain(p_gainer &Gainer, new_gain f32) Result {
	return C.ma_gainer_set_gain(p_gainer, new_gain)
}

// C: `MA_API ma_result ma_gainer_set_gains(ma_gainer* pGainer, float* pNewGains)`
fn C.ma_gainer_set_gains(p_gainer &Gainer, p_new_gains &f32) Result

// gainer_set_gains is currently undocumented
pub fn gainer_set_gains(p_gainer &Gainer, p_new_gains &f32) Result {
	return C.ma_gainer_set_gains(p_gainer, p_new_gains)
}

// PanMode is C.ma_pan_mode
pub enum PanMode {
	balance = C.ma_pan_mode_balance // 0, Does not blend one side with the other. Technically just a balance. Compatible with other popular audio engines and therefore the default.
	pan     = C.ma_pan_mode_pan     // A true pan. The sound from one side will "move" to the other side and blend with it.
}

@[typedef]
struct C.ma_panner_config {
pub mut:
	format   Format
	channels u32
	mode     PanMode
	pan      f32
}

pub type PannerConfig = C.ma_panner_config

// C: `MA_API ma_panner_config ma_panner_config_init(ma_format format, ma_uint32 channels)`
fn C.ma_panner_config_init(format Format, channels u32) PannerConfig

// panner_config_init is currently undocumented
pub fn panner_config_init(format Format, channels u32) PannerConfig {
	return C.ma_panner_config_init(format, channels)
}

@[typedef]
struct C.ma_panner {
pub mut:
	format   Format
	channels u32
	mode     PanMode
	pan      f32 // -1..1 where 0 is no pan, -1 is left side, +1 is right side. Defaults to 0.
}

pub type Panner = C.ma_panner

// C: `MA_API ma_result ma_panner_init(const ma_panner_config* pConfig, ma_panner* pPanner)`
fn C.ma_panner_init(const_p_config &PannerConfig, p_panner &Panner) Result

// panner_init is currently undocumented
pub fn panner_init(const_p_config &PannerConfig, p_panner &Panner) Result {
	return C.ma_panner_init(const_p_config, p_panner)
}

// C: `MA_API ma_result ma_panner_process_pcm_frames(ma_panner* pPanner, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_panner_process_pcm_frames(p_panner &Panner, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// panner_process_pcm_frames is currently undocumented
pub fn panner_process_pcm_frames(p_panner &Panner, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_panner_process_pcm_frames(p_panner, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API void ma_panner_set_mode(ma_panner* pPanner, ma_pan_mode mode)`
fn C.ma_panner_set_mode(p_panner &Panner, mode PanMode)

// panner_set_mode is currently undocumented
pub fn panner_set_mode(p_panner &Panner, mode PanMode) {
	C.ma_panner_set_mode(p_panner, mode)
}

// C: `MA_API ma_pan_mode ma_panner_get_mode(const ma_panner* pPanner)`
fn C.ma_panner_get_mode(const_p_panner &Panner) PanMode

// panner_get_mode is currently undocumented
pub fn panner_get_mode(const_p_panner &Panner) PanMode {
	return C.ma_panner_get_mode(const_p_panner)
}

// C: `MA_API void ma_panner_set_pan(ma_panner* pPanner, float pan)`
fn C.ma_panner_set_pan(p_panner &Panner, pan f32)

// panner_set_pan is currently undocumented
pub fn panner_set_pan(p_panner &Panner, pan f32) {
	C.ma_panner_set_pan(p_panner, pan)
}

// C: `MA_API float ma_panner_get_pan(const ma_panner* pPanner)`
fn C.ma_panner_get_pan(const_p_panner &Panner) f32

// panner_get_pan is currently undocumented
pub fn panner_get_pan(const_p_panner &Panner) f32 {
	return C.ma_panner_get_pan(const_p_panner)
}

@[typedef]
struct C.ma_fader_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
}

pub type FaderConfig = C.ma_fader_config

// C: `MA_API ma_fader_config ma_fader_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate)`
fn C.ma_fader_config_init(format Format, channels u32, sample_rate u32) FaderConfig

// fader_config_init is currently undocumented
pub fn fader_config_init(format Format, channels u32, sample_rate u32) FaderConfig {
	return C.ma_fader_config_init(format, channels, sample_rate)
}

@[typedef]
struct C.ma_fader {
pub mut:
	config         FaderConfig
	volumeBeg      f32 // If volumeBeg and volumeEnd is equal to 1, no fading happens (ma_fader_process_pcm_frames() will run as a passthrough).
	volumeEnd      f32
	lengthInFrames u64 // The total length of the fade.
	cursorInFrames u64 // The current time in frames. Incremented by ma_fader_process_pcm_frames().
}

pub type Fader = C.ma_fader

// C: `MA_API ma_result ma_fader_init(const ma_fader_config* pConfig, ma_fader* pFader)`
fn C.ma_fader_init(const_p_config &FaderConfig, p_fader &Fader) Result

// fader_init is currently undocumented
pub fn fader_init(const_p_config &FaderConfig, p_fader &Fader) Result {
	return C.ma_fader_init(const_p_config, p_fader)
}

// C: `MA_API ma_result ma_fader_process_pcm_frames(ma_fader* pFader, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_fader_process_pcm_frames(p_fader &Fader, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// fader_process_pcm_frames is currently undocumented
pub fn fader_process_pcm_frames(p_fader &Fader, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_fader_process_pcm_frames(p_fader, p_frames_out, const_p_frames_in, frame_count)
}

// C: `MA_API void ma_fader_get_data_format(const ma_fader* pFader, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate)`
fn C.ma_fader_get_data_format(const_p_fader &Fader, p_format &Format, p_channels &u32, p_sample_rate &u32)

// fader_get_data_format is currently undocumented
pub fn fader_get_data_format(const_p_fader &Fader, p_format &Format, p_channels &u32, p_sample_rate &u32) {
	C.ma_fader_get_data_format(const_p_fader, &p_format, p_channels, p_sample_rate)
}

// C: `MA_API void ma_fader_set_fade(ma_fader* pFader, float volumeBeg, float volumeEnd, ma_uint64 lengthInFrames)`
fn C.ma_fader_set_fade(p_fader &Fader, volume_beg f32, volume_end f32, length_in_frames u64)

// fader_set_fade is currently undocumented
pub fn fader_set_fade(p_fader &Fader, volume_beg f32, volume_end f32, length_in_frames u64) {
	C.ma_fader_set_fade(p_fader, volume_beg, volume_end, length_in_frames)
}

// C: `MA_API float ma_fader_get_current_volume(ma_fader* pFader)`
fn C.ma_fader_get_current_volume(p_fader &Fader) f32

// fader_get_current_volume is currently undocumented
pub fn fader_get_current_volume(p_fader &Fader) f32 {
	return C.ma_fader_get_current_volume(p_fader)
}

@[typedef]
struct C.ma_vec3f {
pub mut:
	x f32
	y f32
	z f32
}

pub type Vec3f = C.ma_vec3f

// AttenuationModel is C.ma_attenuation_model
pub enum AttenuationModel {
	@none       = C.ma_attenuation_model_none        // No distance attenuation and no spatialization.
	inverse     = C.ma_attenuation_model_inverse     // Equivalent to OpenAL's AL_INVERSE_DISTANCE_CLAMPED.
	linear      = C.ma_attenuation_model_linear      // Linear attenuation. Equivalent to OpenAL's AL_LINEAR_DISTANCE_CLAMPED.
	exponential = C.ma_attenuation_model_exponential // Exponential attenuation. Equivalent to OpenAL's AL_EXPONENT_DISTANCE_CLAMPED.
}

// Positioning is C.ma_positioning
pub enum Positioning {
	absolute = C.ma_positioning_absolute
	relative = C.ma_positioning_relative
}

// Handedness is C.ma_handedness
pub enum Handedness {
	right = C.ma_handedness_right
	left  = C.ma_handedness_left
}

@[typedef]
struct C.ma_spatializer_listener_config {
pub mut:
	channelsOut             u32
	pChannelMapOut          &u8 = unsafe { nil }
	handedness              Handedness // Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis.
	coneInnerAngleInRadians f32
	coneOuterAngleInRadians f32
	coneOuterGain           f32
	speedOfSound            f32
	worldUp                 Vec3f
}

pub type SpatializerListenerConfig = C.ma_spatializer_listener_config

// C: `MA_API ma_spatializer_listener_config ma_spatializer_listener_config_init(ma_uint32 channelsOut)`
fn C.ma_spatializer_listener_config_init(channels_out u32) SpatializerListenerConfig

// spatializer_listener_config_init is currently undocumented
pub fn spatializer_listener_config_init(channels_out u32) SpatializerListenerConfig {
	return C.ma_spatializer_listener_config_init(channels_out)
}

@[typedef]
struct C.ma_spatializer_listener {
pub mut:
	config    SpatializerListenerConfig
	position  Vec3f // The absolute position of the listener.
	direction Vec3f // The direction the listener is facing. The world up vector is config.worldUp.
	velocity  Vec3f
	isEnabled u32 // Memory management.
	_ownsHeap u32
	_pHeap    voidptr
}

pub type SpatializerListener = C.ma_spatializer_listener

// C: `MA_API ma_result ma_spatializer_listener_get_heap_size(const ma_spatializer_listener_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_spatializer_listener_get_heap_size(const_p_config &SpatializerListenerConfig, p_heap_size_in_bytes &usize) Result

// spatializer_listener_get_heap_size is currently undocumented
pub fn spatializer_listener_get_heap_size(const_p_config &SpatializerListenerConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_spatializer_listener_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_spatializer_listener_init_preallocated(const ma_spatializer_listener_config* pConfig, void* pHeap, ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_init_preallocated(const_p_config &SpatializerListenerConfig, p_heap voidptr, p_listener &SpatializerListener) Result

// spatializer_listener_init_preallocated is currently undocumented
pub fn spatializer_listener_init_preallocated(const_p_config &SpatializerListenerConfig, p_heap voidptr, p_listener &SpatializerListener) Result {
	return C.ma_spatializer_listener_init_preallocated(const_p_config, p_heap, p_listener)
}

// C: `MA_API ma_result ma_spatializer_listener_init(const ma_spatializer_listener_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_init(const_p_config &SpatializerListenerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_listener &SpatializerListener) Result

// spatializer_listener_init is currently undocumented
pub fn spatializer_listener_init(const_p_config &SpatializerListenerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_listener &SpatializerListener) Result {
	return C.ma_spatializer_listener_init(const_p_config, const_p_allocation_callbacks,
		p_listener)
}

// C: `MA_API void ma_spatializer_listener_uninit(ma_spatializer_listener* pListener, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_spatializer_listener_uninit(p_listener &SpatializerListener, const_p_allocation_callbacks &AllocationCallbacks)

// spatializer_listener_uninit is currently undocumented
pub fn spatializer_listener_uninit(p_listener &SpatializerListener, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_spatializer_listener_uninit(p_listener, const_p_allocation_callbacks)
}

// C: `MA_API ma_channel* ma_spatializer_listener_get_channel_map(ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_channel_map(p_listener &SpatializerListener) &u8

// spatializer_listener_get_channel_map is currently undocumented
pub fn spatializer_listener_get_channel_map(p_listener &SpatializerListener) &u8 {
	return C.ma_spatializer_listener_get_channel_map(p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_cone(ma_spatializer_listener* pListener, float innerAngleInRadians, float outerAngleInRadians, float outerGain)`
fn C.ma_spatializer_listener_set_cone(p_listener &SpatializerListener, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32)

// spatializer_listener_set_cone is currently undocumented
pub fn spatializer_listener_set_cone(p_listener &SpatializerListener, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32) {
	C.ma_spatializer_listener_set_cone(p_listener, inner_angle_in_radians, outer_angle_in_radians,
		outer_gain)
}

// C: `MA_API void ma_spatializer_listener_get_cone(const ma_spatializer_listener* pListener, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)`
fn C.ma_spatializer_listener_get_cone(const_p_listener &SpatializerListener, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32)

// spatializer_listener_get_cone is currently undocumented
pub fn spatializer_listener_get_cone(const_p_listener &SpatializerListener, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32) {
	C.ma_spatializer_listener_get_cone(const_p_listener, p_inner_angle_in_radians, p_outer_angle_in_radians,
		p_outer_gain)
}

// C: `MA_API void ma_spatializer_listener_set_position(ma_spatializer_listener* pListener, float x, float y, float z)`
fn C.ma_spatializer_listener_set_position(p_listener &SpatializerListener, x f32, y f32, z f32)

// spatializer_listener_set_position is currently undocumented
pub fn spatializer_listener_set_position(p_listener &SpatializerListener, x f32, y f32, z f32) {
	C.ma_spatializer_listener_set_position(p_listener, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_listener_get_position(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_position(const_p_listener &SpatializerListener) Vec3f

// spatializer_listener_get_position is currently undocumented
pub fn spatializer_listener_get_position(const_p_listener &SpatializerListener) Vec3f {
	return C.ma_spatializer_listener_get_position(const_p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_direction(ma_spatializer_listener* pListener, float x, float y, float z)`
fn C.ma_spatializer_listener_set_direction(p_listener &SpatializerListener, x f32, y f32, z f32)

// spatializer_listener_set_direction is currently undocumented
pub fn spatializer_listener_set_direction(p_listener &SpatializerListener, x f32, y f32, z f32) {
	C.ma_spatializer_listener_set_direction(p_listener, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_listener_get_direction(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_direction(const_p_listener &SpatializerListener) Vec3f

// spatializer_listener_get_direction is currently undocumented
pub fn spatializer_listener_get_direction(const_p_listener &SpatializerListener) Vec3f {
	return C.ma_spatializer_listener_get_direction(const_p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_velocity(ma_spatializer_listener* pListener, float x, float y, float z)`
fn C.ma_spatializer_listener_set_velocity(p_listener &SpatializerListener, x f32, y f32, z f32)

// spatializer_listener_set_velocity is currently undocumented
pub fn spatializer_listener_set_velocity(p_listener &SpatializerListener, x f32, y f32, z f32) {
	C.ma_spatializer_listener_set_velocity(p_listener, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_listener_get_velocity(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_velocity(const_p_listener &SpatializerListener) Vec3f

// spatializer_listener_get_velocity is currently undocumented
pub fn spatializer_listener_get_velocity(const_p_listener &SpatializerListener) Vec3f {
	return C.ma_spatializer_listener_get_velocity(const_p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_speed_of_sound(ma_spatializer_listener* pListener, float speedOfSound)`
fn C.ma_spatializer_listener_set_speed_of_sound(p_listener &SpatializerListener, speed_of_sound f32)

// spatializer_listener_set_speed_of_sound is currently undocumented
pub fn spatializer_listener_set_speed_of_sound(p_listener &SpatializerListener, speed_of_sound f32) {
	C.ma_spatializer_listener_set_speed_of_sound(p_listener, speed_of_sound)
}

// C: `MA_API float ma_spatializer_listener_get_speed_of_sound(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_speed_of_sound(const_p_listener &SpatializerListener) f32

// spatializer_listener_get_speed_of_sound is currently undocumented
pub fn spatializer_listener_get_speed_of_sound(const_p_listener &SpatializerListener) f32 {
	return C.ma_spatializer_listener_get_speed_of_sound(const_p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_world_up(ma_spatializer_listener* pListener, float x, float y, float z)`
fn C.ma_spatializer_listener_set_world_up(p_listener &SpatializerListener, x f32, y f32, z f32)

// spatializer_listener_set_world_up is currently undocumented
pub fn spatializer_listener_set_world_up(p_listener &SpatializerListener, x f32, y f32, z f32) {
	C.ma_spatializer_listener_set_world_up(p_listener, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_listener_get_world_up(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_get_world_up(const_p_listener &SpatializerListener) Vec3f

// spatializer_listener_get_world_up is currently undocumented
pub fn spatializer_listener_get_world_up(const_p_listener &SpatializerListener) Vec3f {
	return C.ma_spatializer_listener_get_world_up(const_p_listener)
}

// C: `MA_API void ma_spatializer_listener_set_enabled(ma_spatializer_listener* pListener, ma_bool32 isEnabled)`
fn C.ma_spatializer_listener_set_enabled(p_listener &SpatializerListener, is_enabled u32)

// spatializer_listener_set_enabled is currently undocumented
pub fn spatializer_listener_set_enabled(p_listener &SpatializerListener, is_enabled u32) {
	C.ma_spatializer_listener_set_enabled(p_listener, is_enabled)
}

// C: `MA_API ma_bool32 ma_spatializer_listener_is_enabled(const ma_spatializer_listener* pListener)`
fn C.ma_spatializer_listener_is_enabled(const_p_listener &SpatializerListener) u32

// spatializer_listener_is_enabled is currently undocumented
pub fn spatializer_listener_is_enabled(const_p_listener &SpatializerListener) u32 {
	return C.ma_spatializer_listener_is_enabled(const_p_listener)
}

@[typedef]
struct C.ma_spatializer_config {
pub mut:
	channelsIn                   u32
	channelsOut                  u32
	pChannelMapIn                &u8 = unsafe { nil }
	attenuationModel             AttenuationModel
	positioning                  Positioning
	handedness                   Handedness // Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis.
	minGain                      f32
	maxGain                      f32
	minDistance                  f32
	maxDistance                  f32
	rolloff                      f32
	coneInnerAngleInRadians      f32
	coneOuterAngleInRadians      f32
	coneOuterGain                f32
	dopplerFactor                f32 // Set to 0 to disable doppler effect.
	directionalAttenuationFactor f32 // Set to 0 to disable directional attenuation.
	gainSmoothTimeInFrames       u32 // When the gain of a channel changes during spatialization, the transition will be linearly interpolated over this number of frames.
}

pub type SpatializerConfig = C.ma_spatializer_config

// C: `MA_API ma_spatializer_config ma_spatializer_config_init(ma_uint32 channelsIn, ma_uint32 channelsOut)`
fn C.ma_spatializer_config_init(channels_in u32, channels_out u32) SpatializerConfig

// spatializer_config_init is currently undocumented
pub fn spatializer_config_init(channels_in u32, channels_out u32) SpatializerConfig {
	return C.ma_spatializer_config_init(channels_in, channels_out)
}

@[typedef]
struct C.ma_spatializer {
pub mut:
	channelsIn                   u32
	channelsOut                  u32
	pChannelMapIn                &u8 = unsafe { nil }
	attenuationModel             AttenuationModel
	positioning                  Positioning
	handedness                   Handedness // Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis.
	minGain                      f32
	maxGain                      f32
	minDistance                  f32
	maxDistance                  f32
	rolloff                      f32
	coneInnerAngleInRadians      f32
	coneOuterAngleInRadians      f32
	coneOuterGain                f32
	dopplerFactor                f32 // Set to 0 to disable doppler effect.
	directionalAttenuationFactor f32 // Set to 0 to disable directional attenuation.
	gainSmoothTimeInFrames       u32 // When the gain of a channel changes during spatialization, the transition will be linearly interpolated over this number of frames.
	position                     Vec3f
	direction                    Vec3f
	velocity                     Vec3f  // For doppler effect.
	dopplerPitch                 f32    // Will be updated by ma_spatializer_process_pcm_frames() and can be used by higher level functions to apply a pitch shift for doppler effect.
	gainer                       Gainer // For smooth gain transitions.
	pNewChannelGainsOut          &f32 = unsafe { nil } // An offset of _pHeap. Used by ma_spatializer_process_pcm_frames() to store new channel gains. The number of elements in this array is equal to config.channelsOut.
	// Memory management.

	_pHeap    voidptr
	_ownsHeap u32
}

pub type Spatializer = C.ma_spatializer

// C: `MA_API ma_result ma_spatializer_get_heap_size(const ma_spatializer_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_spatializer_get_heap_size(const_p_config &SpatializerConfig, p_heap_size_in_bytes &usize) Result

// spatializer_get_heap_size is currently undocumented
pub fn spatializer_get_heap_size(const_p_config &SpatializerConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_spatializer_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_spatializer_init_preallocated(const ma_spatializer_config* pConfig, void* pHeap, ma_spatializer* pSpatializer)`
fn C.ma_spatializer_init_preallocated(const_p_config &SpatializerConfig, p_heap voidptr, p_spatializer &Spatializer) Result

// spatializer_init_preallocated is currently undocumented
pub fn spatializer_init_preallocated(const_p_config &SpatializerConfig, p_heap voidptr, p_spatializer &Spatializer) Result {
	return C.ma_spatializer_init_preallocated(const_p_config, p_heap, p_spatializer)
}

// C: `MA_API ma_result ma_spatializer_init(const ma_spatializer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer* pSpatializer)`
fn C.ma_spatializer_init(const_p_config &SpatializerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_spatializer &Spatializer) Result

// spatializer_init is currently undocumented
pub fn spatializer_init(const_p_config &SpatializerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_spatializer &Spatializer) Result {
	return C.ma_spatializer_init(const_p_config, const_p_allocation_callbacks, p_spatializer)
}

// C: `MA_API void ma_spatializer_uninit(ma_spatializer* pSpatializer, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_spatializer_uninit(p_spatializer &Spatializer, const_p_allocation_callbacks &AllocationCallbacks)

// spatializer_uninit is currently undocumented
pub fn spatializer_uninit(p_spatializer &Spatializer, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_spatializer_uninit(p_spatializer, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_spatializer_process_pcm_frames(ma_spatializer* pSpatializer, ma_spatializer_listener* pListener, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_spatializer_process_pcm_frames(p_spatializer &Spatializer, p_listener &SpatializerListener, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// spatializer_process_pcm_frames is currently undocumented
pub fn spatializer_process_pcm_frames(p_spatializer &Spatializer, p_listener &SpatializerListener, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_spatializer_process_pcm_frames(p_spatializer, p_listener, p_frames_out,
		const_p_frames_in, frame_count)
}

// C: `MA_API ma_uint32 ma_spatializer_get_input_channels(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_input_channels(const_p_spatializer &Spatializer) u32

// spatializer_get_input_channels is currently undocumented
pub fn spatializer_get_input_channels(const_p_spatializer &Spatializer) u32 {
	return C.ma_spatializer_get_input_channels(const_p_spatializer)
}

// C: `MA_API ma_uint32 ma_spatializer_get_output_channels(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_output_channels(const_p_spatializer &Spatializer) u32

// spatializer_get_output_channels is currently undocumented
pub fn spatializer_get_output_channels(const_p_spatializer &Spatializer) u32 {
	return C.ma_spatializer_get_output_channels(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_attenuation_model(ma_spatializer* pSpatializer, ma_attenuation_model attenuationModel)`
fn C.ma_spatializer_set_attenuation_model(p_spatializer &Spatializer, attenuation_model AttenuationModel)

// spatializer_set_attenuation_model is currently undocumented
pub fn spatializer_set_attenuation_model(p_spatializer &Spatializer, attenuation_model AttenuationModel) {
	C.ma_spatializer_set_attenuation_model(p_spatializer, attenuation_model)
}

// C: `MA_API ma_attenuation_model ma_spatializer_get_attenuation_model(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_attenuation_model(const_p_spatializer &Spatializer) AttenuationModel

// spatializer_get_attenuation_model is currently undocumented
pub fn spatializer_get_attenuation_model(const_p_spatializer &Spatializer) AttenuationModel {
	return C.ma_spatializer_get_attenuation_model(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_positioning(ma_spatializer* pSpatializer, ma_positioning positioning)`
fn C.ma_spatializer_set_positioning(p_spatializer &Spatializer, positioning Positioning)

// spatializer_set_positioning is currently undocumented
pub fn spatializer_set_positioning(p_spatializer &Spatializer, positioning Positioning) {
	C.ma_spatializer_set_positioning(p_spatializer, positioning)
}

// C: `MA_API ma_positioning ma_spatializer_get_positioning(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_positioning(const_p_spatializer &Spatializer) Positioning

// spatializer_get_positioning is currently undocumented
pub fn spatializer_get_positioning(const_p_spatializer &Spatializer) Positioning {
	return C.ma_spatializer_get_positioning(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_rolloff(ma_spatializer* pSpatializer, float rolloff)`
fn C.ma_spatializer_set_rolloff(p_spatializer &Spatializer, rolloff f32)

// spatializer_set_rolloff is currently undocumented
pub fn spatializer_set_rolloff(p_spatializer &Spatializer, rolloff f32) {
	C.ma_spatializer_set_rolloff(p_spatializer, rolloff)
}

// C: `MA_API float ma_spatializer_get_rolloff(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_rolloff(const_p_spatializer &Spatializer) f32

// spatializer_get_rolloff is currently undocumented
pub fn spatializer_get_rolloff(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_rolloff(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_min_gain(ma_spatializer* pSpatializer, float minGain)`
fn C.ma_spatializer_set_min_gain(p_spatializer &Spatializer, min_gain f32)

// spatializer_set_min_gain is currently undocumented
pub fn spatializer_set_min_gain(p_spatializer &Spatializer, min_gain f32) {
	C.ma_spatializer_set_min_gain(p_spatializer, min_gain)
}

// C: `MA_API float ma_spatializer_get_min_gain(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_min_gain(const_p_spatializer &Spatializer) f32

// spatializer_get_min_gain is currently undocumented
pub fn spatializer_get_min_gain(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_min_gain(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_max_gain(ma_spatializer* pSpatializer, float maxGain)`
fn C.ma_spatializer_set_max_gain(p_spatializer &Spatializer, max_gain f32)

// spatializer_set_max_gain is currently undocumented
pub fn spatializer_set_max_gain(p_spatializer &Spatializer, max_gain f32) {
	C.ma_spatializer_set_max_gain(p_spatializer, max_gain)
}

// C: `MA_API float ma_spatializer_get_max_gain(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_max_gain(const_p_spatializer &Spatializer) f32

// spatializer_get_max_gain is currently undocumented
pub fn spatializer_get_max_gain(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_max_gain(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_min_distance(ma_spatializer* pSpatializer, float minDistance)`
fn C.ma_spatializer_set_min_distance(p_spatializer &Spatializer, min_distance f32)

// spatializer_set_min_distance is currently undocumented
pub fn spatializer_set_min_distance(p_spatializer &Spatializer, min_distance f32) {
	C.ma_spatializer_set_min_distance(p_spatializer, min_distance)
}

// C: `MA_API float ma_spatializer_get_min_distance(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_min_distance(const_p_spatializer &Spatializer) f32

// spatializer_get_min_distance is currently undocumented
pub fn spatializer_get_min_distance(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_min_distance(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_max_distance(ma_spatializer* pSpatializer, float maxDistance)`
fn C.ma_spatializer_set_max_distance(p_spatializer &Spatializer, max_distance f32)

// spatializer_set_max_distance is currently undocumented
pub fn spatializer_set_max_distance(p_spatializer &Spatializer, max_distance f32) {
	C.ma_spatializer_set_max_distance(p_spatializer, max_distance)
}

// C: `MA_API float ma_spatializer_get_max_distance(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_max_distance(const_p_spatializer &Spatializer) f32

// spatializer_get_max_distance is currently undocumented
pub fn spatializer_get_max_distance(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_max_distance(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_cone(ma_spatializer* pSpatializer, float innerAngleInRadians, float outerAngleInRadians, float outerGain)`
fn C.ma_spatializer_set_cone(p_spatializer &Spatializer, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32)

// spatializer_set_cone is currently undocumented
pub fn spatializer_set_cone(p_spatializer &Spatializer, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32) {
	C.ma_spatializer_set_cone(p_spatializer, inner_angle_in_radians, outer_angle_in_radians,
		outer_gain)
}

// C: `MA_API void ma_spatializer_get_cone(const ma_spatializer* pSpatializer, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)`
fn C.ma_spatializer_get_cone(const_p_spatializer &Spatializer, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32)

// spatializer_get_cone is currently undocumented
pub fn spatializer_get_cone(const_p_spatializer &Spatializer, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32) {
	C.ma_spatializer_get_cone(const_p_spatializer, p_inner_angle_in_radians, p_outer_angle_in_radians,
		p_outer_gain)
}

// C: `MA_API void ma_spatializer_set_doppler_factor(ma_spatializer* pSpatializer, float dopplerFactor)`
fn C.ma_spatializer_set_doppler_factor(p_spatializer &Spatializer, doppler_factor f32)

// spatializer_set_doppler_factor is currently undocumented
pub fn spatializer_set_doppler_factor(p_spatializer &Spatializer, doppler_factor f32) {
	C.ma_spatializer_set_doppler_factor(p_spatializer, doppler_factor)
}

// C: `MA_API float ma_spatializer_get_doppler_factor(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_doppler_factor(const_p_spatializer &Spatializer) f32

// spatializer_get_doppler_factor is currently undocumented
pub fn spatializer_get_doppler_factor(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_doppler_factor(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_directional_attenuation_factor(ma_spatializer* pSpatializer, float directionalAttenuationFactor)`
fn C.ma_spatializer_set_directional_attenuation_factor(p_spatializer &Spatializer, directional_attenuation_factor f32)

// spatializer_set_directional_attenuation_factor is currently undocumented
pub fn spatializer_set_directional_attenuation_factor(p_spatializer &Spatializer, directional_attenuation_factor f32) {
	C.ma_spatializer_set_directional_attenuation_factor(p_spatializer, directional_attenuation_factor)
}

// C: `MA_API float ma_spatializer_get_directional_attenuation_factor(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_directional_attenuation_factor(const_p_spatializer &Spatializer) f32

// spatializer_get_directional_attenuation_factor is currently undocumented
pub fn spatializer_get_directional_attenuation_factor(const_p_spatializer &Spatializer) f32 {
	return C.ma_spatializer_get_directional_attenuation_factor(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_position(ma_spatializer* pSpatializer, float x, float y, float z)`
fn C.ma_spatializer_set_position(p_spatializer &Spatializer, x f32, y f32, z f32)

// spatializer_set_position is currently undocumented
pub fn spatializer_set_position(p_spatializer &Spatializer, x f32, y f32, z f32) {
	C.ma_spatializer_set_position(p_spatializer, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_get_position(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_position(const_p_spatializer &Spatializer) Vec3f

// spatializer_get_position is currently undocumented
pub fn spatializer_get_position(const_p_spatializer &Spatializer) Vec3f {
	return C.ma_spatializer_get_position(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_direction(ma_spatializer* pSpatializer, float x, float y, float z)`
fn C.ma_spatializer_set_direction(p_spatializer &Spatializer, x f32, y f32, z f32)

// spatializer_set_direction is currently undocumented
pub fn spatializer_set_direction(p_spatializer &Spatializer, x f32, y f32, z f32) {
	C.ma_spatializer_set_direction(p_spatializer, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_get_direction(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_direction(const_p_spatializer &Spatializer) Vec3f

// spatializer_get_direction is currently undocumented
pub fn spatializer_get_direction(const_p_spatializer &Spatializer) Vec3f {
	return C.ma_spatializer_get_direction(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_set_velocity(ma_spatializer* pSpatializer, float x, float y, float z)`
fn C.ma_spatializer_set_velocity(p_spatializer &Spatializer, x f32, y f32, z f32)

// spatializer_set_velocity is currently undocumented
pub fn spatializer_set_velocity(p_spatializer &Spatializer, x f32, y f32, z f32) {
	C.ma_spatializer_set_velocity(p_spatializer, x, y, z)
}

// C: `MA_API ma_vec3f ma_spatializer_get_velocity(const ma_spatializer* pSpatializer)`
fn C.ma_spatializer_get_velocity(const_p_spatializer &Spatializer) Vec3f

// spatializer_get_velocity is currently undocumented
pub fn spatializer_get_velocity(const_p_spatializer &Spatializer) Vec3f {
	return C.ma_spatializer_get_velocity(const_p_spatializer)
}

// C: `MA_API void ma_spatializer_get_relative_position_and_direction(const ma_spatializer* pSpatializer, const ma_spatializer_listener* pListener, ma_vec3f* pRelativePos, ma_vec3f* pRelativeDir)`
fn C.ma_spatializer_get_relative_position_and_direction(const_p_spatializer &Spatializer, const_p_listener &SpatializerListener, p_relative_pos &Vec3f, p_relative_dir &Vec3f)

// spatializer_get_relative_position_and_direction is currently undocumented
pub fn spatializer_get_relative_position_and_direction(const_p_spatializer &Spatializer, const_p_listener &SpatializerListener, p_relative_pos &Vec3f, p_relative_dir &Vec3f) {
	C.ma_spatializer_get_relative_position_and_direction(const_p_spatializer, const_p_listener,
		p_relative_pos, p_relative_dir)
}

@[typedef]
struct C.ma_linear_resampler_config {
pub mut:
	format           Format
	channels         u32
	sampleRateIn     u32
	sampleRateOut    u32
	lpfOrder         u32 // The low-pass filter order. Setting this to 0 will disable low-pass filtering.
	lpfNyquistFactor f64 // 0..1. Defaults to 1. 1 = Half the sampling frequency (Nyquist Frequency), 0.5 = Quarter the sampling frequency (half Nyquest Frequency), etc.
}

pub type LinearResamplerConfig = C.ma_linear_resampler_config

// C: `MA_API ma_linear_resampler_config ma_linear_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)`
fn C.ma_linear_resampler_config_init(format Format, channels u32, sample_rate_in u32, sample_rate_out u32) LinearResamplerConfig

// linear_resampler_config_init is currently undocumented
pub fn linear_resampler_config_init(format Format, channels u32, sample_rate_in u32, sample_rate_out u32) LinearResamplerConfig {
	return C.ma_linear_resampler_config_init(format, channels, sample_rate_in, sample_rate_out)
}

@[typedef]
struct C.ma_linear_resampler {
pub mut:
	config        LinearResamplerConfig
	inAdvanceInt  u32
	inAdvanceFrac u32
	inTimeInt     u32
	inTimeFrac    u32
	// TODO// union {
	//  float* f32; ma_int16* s16; } x0
	// TODO// union {
	//  float* f32; ma_int16* s16; } x1
	lpf       Lpf // Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type LinearResampler = C.ma_linear_resampler

// C: `MA_API ma_result ma_linear_resampler_get_heap_size(const ma_linear_resampler_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_linear_resampler_get_heap_size(const_p_config &LinearResamplerConfig, p_heap_size_in_bytes &usize) Result

// linear_resampler_get_heap_size is currently undocumented
pub fn linear_resampler_get_heap_size(const_p_config &LinearResamplerConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_linear_resampler_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_linear_resampler_init_preallocated(const ma_linear_resampler_config* pConfig, void* pHeap, ma_linear_resampler* pResampler)`
fn C.ma_linear_resampler_init_preallocated(const_p_config &LinearResamplerConfig, p_heap voidptr, p_resampler &LinearResampler) Result

// linear_resampler_init_preallocated is currently undocumented
pub fn linear_resampler_init_preallocated(const_p_config &LinearResamplerConfig, p_heap voidptr, p_resampler &LinearResampler) Result {
	return C.ma_linear_resampler_init_preallocated(const_p_config, p_heap, p_resampler)
}

// C: `MA_API ma_result ma_linear_resampler_init(const ma_linear_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_linear_resampler* pResampler)`
fn C.ma_linear_resampler_init(const_p_config &LinearResamplerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_resampler &LinearResampler) Result

// linear_resampler_init is currently undocumented
pub fn linear_resampler_init(const_p_config &LinearResamplerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_resampler &LinearResampler) Result {
	return C.ma_linear_resampler_init(const_p_config, const_p_allocation_callbacks, p_resampler)
}

// C: `MA_API void ma_linear_resampler_uninit(ma_linear_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_linear_resampler_uninit(p_resampler &LinearResampler, const_p_allocation_callbacks &AllocationCallbacks)

// linear_resampler_uninit is currently undocumented
pub fn linear_resampler_uninit(p_resampler &LinearResampler, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_linear_resampler_uninit(p_resampler, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_linear_resampler_process_pcm_frames(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)`
fn C.ma_linear_resampler_process_pcm_frames(p_resampler &LinearResampler, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result

// linear_resampler_process_pcm_frames is currently undocumented
pub fn linear_resampler_process_pcm_frames(p_resampler &LinearResampler, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result {
	return C.ma_linear_resampler_process_pcm_frames(p_resampler, const_p_frames_in, p_frame_count_in,
		p_frames_out, p_frame_count_out)
}

// C: `MA_API ma_result ma_linear_resampler_set_rate(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)`
fn C.ma_linear_resampler_set_rate(p_resampler &LinearResampler, sample_rate_in u32, sample_rate_out u32) Result

// linear_resampler_set_rate is currently undocumented
pub fn linear_resampler_set_rate(p_resampler &LinearResampler, sample_rate_in u32, sample_rate_out u32) Result {
	return C.ma_linear_resampler_set_rate(p_resampler, sample_rate_in, sample_rate_out)
}

// C: `MA_API ma_result ma_linear_resampler_set_rate_ratio(ma_linear_resampler* pResampler, float ratioInOut)`
fn C.ma_linear_resampler_set_rate_ratio(p_resampler &LinearResampler, ratio_in_out f32) Result

// linear_resampler_set_rate_ratio is currently undocumented
pub fn linear_resampler_set_rate_ratio(p_resampler &LinearResampler, ratio_in_out f32) Result {
	return C.ma_linear_resampler_set_rate_ratio(p_resampler, ratio_in_out)
}

// C: `MA_API ma_uint64 ma_linear_resampler_get_input_latency(const ma_linear_resampler* pResampler)`
fn C.ma_linear_resampler_get_input_latency(const_p_resampler &LinearResampler) u64

// linear_resampler_get_input_latency is currently undocumented
pub fn linear_resampler_get_input_latency(const_p_resampler &LinearResampler) u64 {
	return C.ma_linear_resampler_get_input_latency(const_p_resampler)
}

// C: `MA_API ma_uint64 ma_linear_resampler_get_output_latency(const ma_linear_resampler* pResampler)`
fn C.ma_linear_resampler_get_output_latency(const_p_resampler &LinearResampler) u64

// linear_resampler_get_output_latency is currently undocumented
pub fn linear_resampler_get_output_latency(const_p_resampler &LinearResampler) u64 {
	return C.ma_linear_resampler_get_output_latency(const_p_resampler)
}

// C: `MA_API ma_result ma_linear_resampler_get_required_input_frame_count(const ma_linear_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)`
fn C.ma_linear_resampler_get_required_input_frame_count(const_p_resampler &LinearResampler, output_frame_count u64, p_input_frame_count &u64) Result

// linear_resampler_get_required_input_frame_count is currently undocumented
pub fn linear_resampler_get_required_input_frame_count(const_p_resampler &LinearResampler, output_frame_count u64, p_input_frame_count &u64) Result {
	return C.ma_linear_resampler_get_required_input_frame_count(const_p_resampler, output_frame_count,
		p_input_frame_count)
}

// C: `MA_API ma_result ma_linear_resampler_get_expected_output_frame_count(const ma_linear_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)`
fn C.ma_linear_resampler_get_expected_output_frame_count(const_p_resampler &LinearResampler, input_frame_count u64, p_output_frame_count &u64) Result

// linear_resampler_get_expected_output_frame_count is currently undocumented
pub fn linear_resampler_get_expected_output_frame_count(const_p_resampler &LinearResampler, input_frame_count u64, p_output_frame_count &u64) Result {
	return C.ma_linear_resampler_get_expected_output_frame_count(const_p_resampler, input_frame_count,
		p_output_frame_count)
}

// C: `MA_API ma_result ma_linear_resampler_reset(ma_linear_resampler* pResampler)`
fn C.ma_linear_resampler_reset(p_resampler &LinearResampler) Result

// linear_resampler_reset is currently undocumented
pub fn linear_resampler_reset(p_resampler &LinearResampler) Result {
	return C.ma_linear_resampler_reset(p_resampler)
}

@[typedef]
struct C.ma_resampling_backend_vtable {
pub mut:
	onGetHeapSize                 fn (p_user_data voidptr, const_p_config &ResamplerConfig, p_heap_size_in_bytes &usize) Result        // onGetHeapSize
	onInit                        fn (p_user_data voidptr, const_p_config &ResamplerConfig, p_heap voidptr, pp_backend voidptr) Result // onInit
	onUninit                      fn (p_user_data voidptr, p_backend voidptr, const_p_allocation_callbacks &AllocationCallbacks)       // onUninit
	onProcess                     fn (p_user_data voidptr, p_backend voidptr, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result // onProcess
	onSetRate                     fn (p_user_data voidptr, p_backend voidptr, sample_rate_in u32, sample_rate_out u32) Result // onSetRate Optional. Rate changes will be disabled.
	onGetInputLatency             fn (p_user_data voidptr, const_p_backend voidptr) u64 // onGetInputLatency Optional. Latency will be reported as 0.
	onGetOutputLatency            fn (p_user_data voidptr, const_p_backend voidptr) u64 // onGetOutputLatency Optional. Latency will be reported as 0.
	onGetRequiredInputFrameCount  fn (p_user_data voidptr, const_p_backend voidptr, output_frame_count u64, p_input_frame_count &u64) Result // onGetRequiredInputFrameCount Optional. Latency mitigation will be disabled.
	onGetExpectedOutputFrameCount fn (p_user_data voidptr, const_p_backend voidptr, input_frame_count u64, p_output_frame_count &u64) Result // onGetExpectedOutputFrameCount)(void* Optional. Latency mitigation will be disabled.
	onReset                       fn (p_user_data voidptr, p_backend voidptr) Result // onReset
}

pub type ResamplingBackendVtable = C.ma_resampling_backend_vtable

// ResampleAlgorithm is C.ma_resample_algorithm
pub enum ResampleAlgorithm {
	linear = C.ma_resample_algorithm_linear // 0, Fastest, lowest quality. Optional low-pass filtering. Default.
	custom = C.ma_resample_algorithm_custom
}

@[typedef]
struct C.ma_resampler_config {
pub mut:
	format           Format // Must be either ma_format_f32 or ma_format_s16.
	channels         u32
	sampleRateIn     u32
	sampleRateOut    u32
	algorithm        ResampleAlgorithm // When set to ma_resample_algorithm_custom, pBackendVTable will be used.
	pBackendVTable   &ResamplingBackendVtable = unsafe { nil }
	pBackendUserData voidptr
	// TODO// struct {
	//  ma_uint32 lpfOrder; } linear
}

pub type ResamplerConfig = C.ma_resampler_config

// C: `MA_API ma_resampler_config ma_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_resample_algorithm algorithm)`
fn C.ma_resampler_config_init(format Format, channels u32, sample_rate_in u32, sample_rate_out u32, algorithm ResampleAlgorithm) ResamplerConfig

// resampler_config_init is currently undocumented
pub fn resampler_config_init(format Format, channels u32, sample_rate_in u32, sample_rate_out u32, algorithm ResampleAlgorithm) ResamplerConfig {
	return C.ma_resampler_config_init(format, channels, sample_rate_in, sample_rate_out,
		algorithm)
}

@[typedef]
struct C.ma_resampler {
pub mut:
	pBackend         voidptr
	pBackendVTable   &ResamplingBackendVtable = unsafe { nil }
	pBackendUserData voidptr
	format           Format
	channels         u32
	sampleRateIn     u32
	sampleRateOut    u32
	// TODO// union {
	//  ma_linear_resampler linear; } state
	// Memory management.

	_pHeap    voidptr
	_ownsHeap u32
}

pub type Resampler = C.ma_resampler

// C: `MA_API ma_result ma_resampler_get_heap_size(const ma_resampler_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_resampler_get_heap_size(const_p_config &ResamplerConfig, p_heap_size_in_bytes &usize) Result

// resampler_get_heap_size is currently undocumented
pub fn resampler_get_heap_size(const_p_config &ResamplerConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_resampler_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_resampler_init_preallocated(const ma_resampler_config* pConfig, void* pHeap, ma_resampler* pResampler)`
fn C.ma_resampler_init_preallocated(const_p_config &ResamplerConfig, p_heap voidptr, p_resampler &Resampler) Result

// resampler_init_preallocated is currently undocumented
pub fn resampler_init_preallocated(const_p_config &ResamplerConfig, p_heap voidptr, p_resampler &Resampler) Result {
	return C.ma_resampler_init_preallocated(const_p_config, p_heap, p_resampler)
}

// C: `MA_API ma_result ma_resampler_init(const ma_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_resampler* pResampler)`
fn C.ma_resampler_init(const_p_config &ResamplerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_resampler &Resampler) Result

// resampler_init initializes a new resampler object from a config.
pub fn resampler_init(const_p_config &ResamplerConfig, const_p_allocation_callbacks &AllocationCallbacks, p_resampler &Resampler) Result {
	return C.ma_resampler_init(const_p_config, const_p_allocation_callbacks, p_resampler)
}

// C: `MA_API void ma_resampler_uninit(ma_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_resampler_uninit(p_resampler &Resampler, const_p_allocation_callbacks &AllocationCallbacks)

// resampler_uninit uninitializes a resampler.
pub fn resampler_uninit(p_resampler &Resampler, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_resampler_uninit(p_resampler, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_resampler_process_pcm_frames(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)`
fn C.ma_resampler_process_pcm_frames(p_resampler &Resampler, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result

// resampler_process_pcm_frames converts the given input data.
//
// Both the input and output frames must be in the format specified in the config when the resampler was initilized.
//
// On input, [pFrameCountOut] contains the number of output frames to process. On output it contains the number of output frames that
// were actually processed, which may be less than the requested amount which will happen if there's not enough input data. You can use
// ma_resampler_get_expected_output_frame_count() to know how many output frames will be processed for a given number of input frames.
//
// On input, [pFrameCountIn] contains the number of input frames contained in [pFramesIn]. On output it contains the number of whole
// input frames that were actually processed. You can use ma_resampler_get_required_input_frame_count() to know how many input frames
// you should provide for a given number of output frames. [pFramesIn] can be NULL, in which case zeroes will be used instead.
//
// If [pFramesOut] is NULL, a seek is performed. In this case, if [pFrameCountOut] is not NULL it will seek by the specified number of
// output frames. Otherwise, if [pFramesCountOut] is NULL and [pFrameCountIn] is not NULL, it will seek by the specified number of input
// frames. When seeking, [pFramesIn] is allowed to NULL, in which case the internal timing state will be updated, but no input will be
// processed. In this case, any internal filter state will be updated as if zeroes were passed in.
//
// It is an error for [pFramesOut] to be non-NULL and [pFrameCountOut] to be NULL.
//
// It is an error for both [pFrameCountOut] and [pFrameCountIn] to be NULL.
pub fn resampler_process_pcm_frames(p_resampler &Resampler, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result {
	return C.ma_resampler_process_pcm_frames(p_resampler, const_p_frames_in, p_frame_count_in,
		p_frames_out, p_frame_count_out)
}

// C: `MA_API ma_result ma_resampler_set_rate(ma_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)`
fn C.ma_resampler_set_rate(p_resampler &Resampler, sample_rate_in u32, sample_rate_out u32) Result

// resampler_set_rate sets the input and output sample sample rate.
pub fn resampler_set_rate(p_resampler &Resampler, sample_rate_in u32, sample_rate_out u32) Result {
	return C.ma_resampler_set_rate(p_resampler, sample_rate_in, sample_rate_out)
}

// C: `MA_API ma_result ma_resampler_set_rate_ratio(ma_resampler* pResampler, float ratio)`
fn C.ma_resampler_set_rate_ratio(p_resampler &Resampler, ratio f32) Result

// resampler_set_rate_ratio sets the input and output sample rate as a ratio.
//
// The ration is in/out.
pub fn resampler_set_rate_ratio(p_resampler &Resampler, ratio f32) Result {
	return C.ma_resampler_set_rate_ratio(p_resampler, ratio)
}

// C: `MA_API ma_uint64 ma_resampler_get_input_latency(const ma_resampler* pResampler)`
fn C.ma_resampler_get_input_latency(const_p_resampler &Resampler) u64

// resampler_get_input_latency retrieves the latency introduced by the resampler in input frames.
pub fn resampler_get_input_latency(const_p_resampler &Resampler) u64 {
	return C.ma_resampler_get_input_latency(const_p_resampler)
}

// C: `MA_API ma_uint64 ma_resampler_get_output_latency(const ma_resampler* pResampler)`
fn C.ma_resampler_get_output_latency(const_p_resampler &Resampler) u64

// resampler_get_output_latency retrieves the latency introduced by the resampler in output frames.
pub fn resampler_get_output_latency(const_p_resampler &Resampler) u64 {
	return C.ma_resampler_get_output_latency(const_p_resampler)
}

// C: `MA_API ma_result ma_resampler_get_required_input_frame_count(const ma_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)`
fn C.ma_resampler_get_required_input_frame_count(const_p_resampler &Resampler, output_frame_count u64, p_input_frame_count &u64) Result

// resampler_get_required_input_frame_count calculates the number of whole input frames that would need to be read from the client in order to output the specified
// number of output frames.
//
// The returned value does not include cached input frames. It only returns the number of extra frames that would need to be
// read from the input buffer in order to output the specified number of output frames.
pub fn resampler_get_required_input_frame_count(const_p_resampler &Resampler, output_frame_count u64, p_input_frame_count &u64) Result {
	return C.ma_resampler_get_required_input_frame_count(const_p_resampler, output_frame_count,
		p_input_frame_count)
}

// C: `MA_API ma_result ma_resampler_get_expected_output_frame_count(const ma_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)`
fn C.ma_resampler_get_expected_output_frame_count(const_p_resampler &Resampler, input_frame_count u64, p_output_frame_count &u64) Result

// resampler_get_expected_output_frame_count calculates the number of whole output frames that would be output after fully reading and consuming the specified number of
// input frames.
pub fn resampler_get_expected_output_frame_count(const_p_resampler &Resampler, input_frame_count u64, p_output_frame_count &u64) Result {
	return C.ma_resampler_get_expected_output_frame_count(const_p_resampler, input_frame_count,
		p_output_frame_count)
}

// C: `MA_API ma_result ma_resampler_reset(ma_resampler* pResampler)`
fn C.ma_resampler_reset(p_resampler &Resampler) Result

// resampler_reset resets the resampler's timer and clears it's internal cache.
pub fn resampler_reset(p_resampler &Resampler) Result {
	return C.ma_resampler_reset(p_resampler)
}

// ChannelConversionPath is C.ma_channel_conversion_path
pub enum ChannelConversionPath {
	unknown     = C.ma_channel_conversion_path_unknown
	passthrough = C.ma_channel_conversion_path_passthrough
	mono_out    = C.ma_channel_conversion_path_mono_out // Converting to mono.
	mono_in     = C.ma_channel_conversion_path_mono_in  // Converting from mono.
	shuffle     = C.ma_channel_conversion_path_shuffle  // Simple shuffle. Will use this when all channels are present in both input and output channel maps, but just in a different order.
	weights     = C.ma_channel_conversion_path_weights  // Blended based on weights.
}

// MonoExpansionMode is C.ma_mono_expansion_mode
pub enum MonoExpansionMode {
	duplicate   = C.ma_mono_expansion_mode_duplicate   // 0, The default.
	average     = C.ma_mono_expansion_mode_average     // Average the mono channel across all channels.
	stereo_only = C.ma_mono_expansion_mode_stereo_only // Duplicate to the left and right channels only and ignore the others.
	default     = C.ma_mono_expansion_mode_default     // ma_mono_expansion_mode_duplicate,
}

@[typedef]
struct C.ma_channel_converter_config {
pub mut:
	format                          Format
	channelsIn                      u32
	channelsOut                     u32
	pChannelMapIn                   &u8 = unsafe { nil }
	pChannelMapOut                  &u8 = unsafe { nil }
	mixingMode                      ChannelMixMode
	calculateLFEFromSpatialChannels u32 // When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present.
	ppWeights                       &&f32 = unsafe { nil } // [in][out]. Only used when mixingMode is set to ma_channel_mix_mode_custom_weights.
}

pub type ChannelConverterConfig = C.ma_channel_converter_config

// C: `MA_API ma_channel_converter_config ma_channel_converter_config_init(ma_format format, ma_uint32 channelsIn, const ma_channel* pChannelMapIn, ma_uint32 channelsOut, const ma_channel* pChannelMapOut, ma_channel_mix_mode mixingMode)`
fn C.ma_channel_converter_config_init(format Format, channels_in u32, const_p_channel_map_in &u8, channels_out u32, const_p_channel_map_out &u8, mixing_mode ChannelMixMode) ChannelConverterConfig

// channel_converter_config_init is currently undocumented
pub fn channel_converter_config_init(format Format, channels_in u32, const_p_channel_map_in &u8, channels_out u32, const_p_channel_map_out &u8, mixing_mode ChannelMixMode) ChannelConverterConfig {
	return C.ma_channel_converter_config_init(format, channels_in, const_p_channel_map_in,
		channels_out, const_p_channel_map_out, mixing_mode)
}

@[typedef]
struct C.ma_channel_converter {
pub mut:
	format         Format
	channelsIn     u32
	channelsOut    u32
	mixingMode     ChannelMixMode
	conversionPath ChannelConversionPath
	pChannelMapIn  &u8 = unsafe { nil }
	pChannelMapOut &u8 = unsafe { nil }
	pShuffleTable  &u8 = unsafe { nil } // Indexed by output channel index.
	// TODO// union {
	//  float** f32; ma_int32** s16; } weights
	// Memory management.

	_pHeap    voidptr
	_ownsHeap u32
}

pub type ChannelConverter = C.ma_channel_converter

// C: `MA_API ma_result ma_channel_converter_get_heap_size(const ma_channel_converter_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_channel_converter_get_heap_size(const_p_config &ChannelConverterConfig, p_heap_size_in_bytes &usize) Result

// channel_converter_get_heap_size is currently undocumented
pub fn channel_converter_get_heap_size(const_p_config &ChannelConverterConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_channel_converter_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_channel_converter_init_preallocated(const ma_channel_converter_config* pConfig, void* pHeap, ma_channel_converter* pConverter)`
fn C.ma_channel_converter_init_preallocated(const_p_config &ChannelConverterConfig, p_heap voidptr, p_converter &ChannelConverter) Result

// channel_converter_init_preallocated is currently undocumented
pub fn channel_converter_init_preallocated(const_p_config &ChannelConverterConfig, p_heap voidptr, p_converter &ChannelConverter) Result {
	return C.ma_channel_converter_init_preallocated(const_p_config, p_heap, p_converter)
}

// C: `MA_API ma_result ma_channel_converter_init(const ma_channel_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_channel_converter* pConverter)`
fn C.ma_channel_converter_init(const_p_config &ChannelConverterConfig, const_p_allocation_callbacks &AllocationCallbacks, p_converter &ChannelConverter) Result

// channel_converter_init is currently undocumented
pub fn channel_converter_init(const_p_config &ChannelConverterConfig, const_p_allocation_callbacks &AllocationCallbacks, p_converter &ChannelConverter) Result {
	return C.ma_channel_converter_init(const_p_config, const_p_allocation_callbacks, p_converter)
}

// C: `MA_API void ma_channel_converter_uninit(ma_channel_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_channel_converter_uninit(p_converter &ChannelConverter, const_p_allocation_callbacks &AllocationCallbacks)

// channel_converter_uninit is currently undocumented
pub fn channel_converter_uninit(p_converter &ChannelConverter, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_channel_converter_uninit(p_converter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_channel_converter_process_pcm_frames(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)`
fn C.ma_channel_converter_process_pcm_frames(p_converter &ChannelConverter, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result

// channel_converter_process_pcm_frames is currently undocumented
pub fn channel_converter_process_pcm_frames(p_converter &ChannelConverter, p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64) Result {
	return C.ma_channel_converter_process_pcm_frames(p_converter, p_frames_out, const_p_frames_in,
		frame_count)
}

// C: `MA_API ma_result ma_channel_converter_get_input_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_channel_converter_get_input_channel_map(const_p_converter &ChannelConverter, p_channel_map &u8, channel_map_cap usize) Result

// channel_converter_get_input_channel_map is currently undocumented
pub fn channel_converter_get_input_channel_map(const_p_converter &ChannelConverter, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_channel_converter_get_input_channel_map(const_p_converter, p_channel_map,
		channel_map_cap)
}

// C: `MA_API ma_result ma_channel_converter_get_output_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_channel_converter_get_output_channel_map(const_p_converter &ChannelConverter, p_channel_map &u8, channel_map_cap usize) Result

// channel_converter_get_output_channel_map is currently undocumented
pub fn channel_converter_get_output_channel_map(const_p_converter &ChannelConverter, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_channel_converter_get_output_channel_map(const_p_converter, p_channel_map,
		channel_map_cap)
}

@[typedef]
struct C.ma_data_converter_config {
pub mut:
	formatIn                        Format
	formatOut                       Format
	channelsIn                      u32
	channelsOut                     u32
	sampleRateIn                    u32
	sampleRateOut                   u32
	pChannelMapIn                   &u8 = unsafe { nil }
	pChannelMapOut                  &u8 = unsafe { nil }
	ditherMode                      DitherMode
	channelMixMode                  ChannelMixMode
	calculateLFEFromSpatialChannels u32 // When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present.
	ppChannelWeights                &&f32 = unsafe { nil } // [in][out]. Only used when mixingMode is set to ma_channel_mix_mode_custom_weights.
	allowDynamicSampleRate          u32
	resampling                      ResamplerConfig
}

pub type DataConverterConfig = C.ma_data_converter_config

// C: `MA_API ma_data_converter_config ma_data_converter_config_init_default(void)`
fn C.ma_data_converter_config_init_default() DataConverterConfig

// data_converter_config_init_default is currently undocumented
pub fn data_converter_config_init_default() DataConverterConfig {
	return C.ma_data_converter_config_init_default()
}

// C: `MA_API ma_data_converter_config ma_data_converter_config_init(ma_format formatIn, ma_format formatOut, ma_uint32 channelsIn, ma_uint32 channelsOut, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)`
fn C.ma_data_converter_config_init(format_in Format, format_out Format, channels_in u32, channels_out u32, sample_rate_in u32, sample_rate_out u32) DataConverterConfig

// data_converter_config_init is currently undocumented
pub fn data_converter_config_init(format_in Format, format_out Format, channels_in u32, channels_out u32, sample_rate_in u32, sample_rate_out u32) DataConverterConfig {
	return C.ma_data_converter_config_init(format_in, format_out, channels_in, channels_out,
		sample_rate_in, sample_rate_out)
}

// DataConverterExecutionPath is C.ma_data_converter_execution_path
pub enum DataConverterExecutionPath {
	passthrough    = C.ma_data_converter_execution_path_passthrough    // No conversion.
	format_only    = C.ma_data_converter_execution_path_format_only    // Only format conversion.
	channels_only  = C.ma_data_converter_execution_path_channels_only  // Only channel conversion.
	resample_only  = C.ma_data_converter_execution_path_resample_only  // Only resampling.
	resample_first = C.ma_data_converter_execution_path_resample_first // All conversions, but resample as the first step.
	channels_first = C.ma_data_converter_execution_path_channels_first // All conversions, but channels as the first step.
}

@[typedef]
struct C.ma_data_converter {
pub mut:
	formatIn                Format
	formatOut               Format
	channelsIn              u32
	channelsOut             u32
	sampleRateIn            u32
	sampleRateOut           u32
	ditherMode              DitherMode
	executionPath           DataConverterExecutionPath // The execution path the data converter will follow when processing.
	channelConverter        ChannelConverter
	resampler               Resampler
	hasPreFormatConversion  u8
	hasPostFormatConversion u8
	hasChannelConverter     u8
	hasResampler            u8
	isPassthrough           u8 // Memory management.
	_ownsHeap               u8
	_pHeap                  voidptr
}

pub type DataConverter = C.ma_data_converter

// C: `MA_API ma_result ma_data_converter_get_heap_size(const ma_data_converter_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_data_converter_get_heap_size(const_p_config &DataConverterConfig, p_heap_size_in_bytes &usize) Result

// data_converter_get_heap_size is currently undocumented
pub fn data_converter_get_heap_size(const_p_config &DataConverterConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_data_converter_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_data_converter_init_preallocated(const ma_data_converter_config* pConfig, void* pHeap, ma_data_converter* pConverter)`
fn C.ma_data_converter_init_preallocated(const_p_config &DataConverterConfig, p_heap voidptr, p_converter &DataConverter) Result

// data_converter_init_preallocated is currently undocumented
pub fn data_converter_init_preallocated(const_p_config &DataConverterConfig, p_heap voidptr, p_converter &DataConverter) Result {
	return C.ma_data_converter_init_preallocated(const_p_config, p_heap, p_converter)
}

// C: `MA_API ma_result ma_data_converter_init(const ma_data_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_converter* pConverter)`
fn C.ma_data_converter_init(const_p_config &DataConverterConfig, const_p_allocation_callbacks &AllocationCallbacks, p_converter &DataConverter) Result

// data_converter_init is currently undocumented
pub fn data_converter_init(const_p_config &DataConverterConfig, const_p_allocation_callbacks &AllocationCallbacks, p_converter &DataConverter) Result {
	return C.ma_data_converter_init(const_p_config, const_p_allocation_callbacks, p_converter)
}

// C: `MA_API void ma_data_converter_uninit(ma_data_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_data_converter_uninit(p_converter &DataConverter, const_p_allocation_callbacks &AllocationCallbacks)

// data_converter_uninit is currently undocumented
pub fn data_converter_uninit(p_converter &DataConverter, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_data_converter_uninit(p_converter, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_data_converter_process_pcm_frames(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)`
fn C.ma_data_converter_process_pcm_frames(p_converter &DataConverter, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result

// data_converter_process_pcm_frames is currently undocumented
pub fn data_converter_process_pcm_frames(p_converter &DataConverter, const_p_frames_in voidptr, p_frame_count_in &u64, p_frames_out voidptr, p_frame_count_out &u64) Result {
	return C.ma_data_converter_process_pcm_frames(p_converter, const_p_frames_in, p_frame_count_in,
		p_frames_out, p_frame_count_out)
}

// C: `MA_API ma_result ma_data_converter_set_rate(ma_data_converter* pConverter, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)`
fn C.ma_data_converter_set_rate(p_converter &DataConverter, sample_rate_in u32, sample_rate_out u32) Result

// data_converter_set_rate is currently undocumented
pub fn data_converter_set_rate(p_converter &DataConverter, sample_rate_in u32, sample_rate_out u32) Result {
	return C.ma_data_converter_set_rate(p_converter, sample_rate_in, sample_rate_out)
}

// C: `MA_API ma_result ma_data_converter_set_rate_ratio(ma_data_converter* pConverter, float ratioInOut)`
fn C.ma_data_converter_set_rate_ratio(p_converter &DataConverter, ratio_in_out f32) Result

// data_converter_set_rate_ratio is currently undocumented
pub fn data_converter_set_rate_ratio(p_converter &DataConverter, ratio_in_out f32) Result {
	return C.ma_data_converter_set_rate_ratio(p_converter, ratio_in_out)
}

// C: `MA_API ma_uint64 ma_data_converter_get_input_latency(const ma_data_converter* pConverter)`
fn C.ma_data_converter_get_input_latency(const_p_converter &DataConverter) u64

// data_converter_get_input_latency is currently undocumented
pub fn data_converter_get_input_latency(const_p_converter &DataConverter) u64 {
	return C.ma_data_converter_get_input_latency(const_p_converter)
}

// C: `MA_API ma_uint64 ma_data_converter_get_output_latency(const ma_data_converter* pConverter)`
fn C.ma_data_converter_get_output_latency(const_p_converter &DataConverter) u64

// data_converter_get_output_latency is currently undocumented
pub fn data_converter_get_output_latency(const_p_converter &DataConverter) u64 {
	return C.ma_data_converter_get_output_latency(const_p_converter)
}

// C: `MA_API ma_result ma_data_converter_get_required_input_frame_count(const ma_data_converter* pConverter, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)`
fn C.ma_data_converter_get_required_input_frame_count(const_p_converter &DataConverter, output_frame_count u64, p_input_frame_count &u64) Result

// data_converter_get_required_input_frame_count is currently undocumented
pub fn data_converter_get_required_input_frame_count(const_p_converter &DataConverter, output_frame_count u64, p_input_frame_count &u64) Result {
	return C.ma_data_converter_get_required_input_frame_count(const_p_converter, output_frame_count,
		p_input_frame_count)
}

// C: `MA_API ma_result ma_data_converter_get_expected_output_frame_count(const ma_data_converter* pConverter, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)`
fn C.ma_data_converter_get_expected_output_frame_count(const_p_converter &DataConverter, input_frame_count u64, p_output_frame_count &u64) Result

// data_converter_get_expected_output_frame_count is currently undocumented
pub fn data_converter_get_expected_output_frame_count(const_p_converter &DataConverter, input_frame_count u64, p_output_frame_count &u64) Result {
	return C.ma_data_converter_get_expected_output_frame_count(const_p_converter, input_frame_count,
		p_output_frame_count)
}

// C: `MA_API ma_result ma_data_converter_get_input_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_data_converter_get_input_channel_map(const_p_converter &DataConverter, p_channel_map &u8, channel_map_cap usize) Result

// data_converter_get_input_channel_map is currently undocumented
pub fn data_converter_get_input_channel_map(const_p_converter &DataConverter, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_data_converter_get_input_channel_map(const_p_converter, p_channel_map,
		channel_map_cap)
}

// C: `MA_API ma_result ma_data_converter_get_output_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_data_converter_get_output_channel_map(const_p_converter &DataConverter, p_channel_map &u8, channel_map_cap usize) Result

// data_converter_get_output_channel_map is currently undocumented
pub fn data_converter_get_output_channel_map(const_p_converter &DataConverter, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_data_converter_get_output_channel_map(const_p_converter, p_channel_map,
		channel_map_cap)
}

// C: `MA_API ma_result ma_data_converter_reset(ma_data_converter* pConverter)`
fn C.ma_data_converter_reset(p_converter &DataConverter) Result

// data_converter_reset is currently undocumented
pub fn data_converter_reset(p_converter &DataConverter) Result {
	return C.ma_data_converter_reset(p_converter)
}

// C: `MA_API void ma_pcm_u8_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_u8_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// Format Conversion
pub fn pcm_u8_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_u8_to_s16(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_u8_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_u8_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_u8_to_s24 is currently undocumented
pub fn pcm_u8_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_u8_to_s24(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_u8_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_u8_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_u8_to_s32 is currently undocumented
pub fn pcm_u8_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_u8_to_s32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_u8_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_u8_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_u8_to_f32 is currently undocumented
pub fn pcm_u8_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_u8_to_f32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s16_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s16_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s16_to_u8 is currently undocumented
pub fn pcm_s16_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s16_to_u8(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s16_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s16_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s16_to_s24 is currently undocumented
pub fn pcm_s16_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s16_to_s24(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s16_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s16_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s16_to_s32 is currently undocumented
pub fn pcm_s16_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s16_to_s32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s16_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s16_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s16_to_f32 is currently undocumented
pub fn pcm_s16_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s16_to_f32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s24_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s24_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s24_to_u8 is currently undocumented
pub fn pcm_s24_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s24_to_u8(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s24_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s24_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s24_to_s16 is currently undocumented
pub fn pcm_s24_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s24_to_s16(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s24_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s24_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s24_to_s32 is currently undocumented
pub fn pcm_s24_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s24_to_s32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s24_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s24_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s24_to_f32 is currently undocumented
pub fn pcm_s24_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s24_to_f32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s32_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s32_to_u8 is currently undocumented
pub fn pcm_s32_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s32_to_u8(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s32_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s32_to_s16 is currently undocumented
pub fn pcm_s32_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s32_to_s16(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s32_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s32_to_s24 is currently undocumented
pub fn pcm_s32_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s32_to_s24(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_s32_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_s32_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_s32_to_f32 is currently undocumented
pub fn pcm_s32_to_f32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_s32_to_f32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_f32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_f32_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_f32_to_u8 is currently undocumented
pub fn pcm_f32_to_u8(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_f32_to_u8(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_f32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_f32_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_f32_to_s16 is currently undocumented
pub fn pcm_f32_to_s16(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_f32_to_s16(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_f32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_f32_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_f32_to_s24 is currently undocumented
pub fn pcm_f32_to_s24(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_f32_to_s24(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_f32_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode)`
fn C.ma_pcm_f32_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode)

// pcm_f32_to_s32 is currently undocumented
pub fn pcm_f32_to_s32(p_out voidptr, const_p_in voidptr, count u64, dither_mode DitherMode) {
	C.ma_pcm_f32_to_s32(p_out, const_p_in, count, dither_mode)
}

// C: `MA_API void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode)`
fn C.ma_pcm_convert(p_out voidptr, format_out Format, const_p_in voidptr, format_in Format, sample_count u64, dither_mode DitherMode)

// pcm_convert is currently undocumented
pub fn pcm_convert(p_out voidptr, format_out Format, const_p_in voidptr, format_in Format, sample_count u64, dither_mode DitherMode) {
	C.ma_pcm_convert(p_out, format_out, const_p_in, format_in, sample_count, dither_mode)
}

// C: `MA_API void ma_convert_pcm_frames_format(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 frameCount, ma_uint32 channels, ma_dither_mode ditherMode)`
fn C.ma_convert_pcm_frames_format(p_out voidptr, format_out Format, const_p_in voidptr, format_in Format, frame_count u64, channels u32, dither_mode DitherMode)

// convert_pcm_frames_format is currently undocumented
pub fn convert_pcm_frames_format(p_out voidptr, format_out Format, const_p_in voidptr, format_in Format, frame_count u64, channels u32, dither_mode DitherMode) {
	C.ma_convert_pcm_frames_format(p_out, format_out, const_p_in, format_in, frame_count,
		channels, dither_mode)
}

// C: `MA_API void ma_deinterleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames)`
fn C.ma_deinterleave_pcm_frames(format Format, channels u32, frame_count u64, const_p_interleaved_pcm_frames voidptr, pp_deinterleaved_pcm_frames voidptr)

// deinterleave_pcm_frames deinterleaves an interleaved buffer.
pub fn deinterleave_pcm_frames(format Format, channels u32, frame_count u64, const_p_interleaved_pcm_frames voidptr, pp_deinterleaved_pcm_frames voidptr) {
	C.ma_deinterleave_pcm_frames(format, channels, frame_count, const_p_interleaved_pcm_frames,
		pp_deinterleaved_pcm_frames)
}

// C: `MA_API void ma_interleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames)`
fn C.ma_interleave_pcm_frames(format Format, channels u32, frame_count u64, const_pp_deinterleaved_pcm_frames voidptr, p_interleaved_pcm_frames voidptr)

// interleave_pcm_frames interleaves a group of deinterleaved buffers.
pub fn interleave_pcm_frames(format Format, channels u32, frame_count u64, const_pp_deinterleaved_pcm_frames voidptr, p_interleaved_pcm_frames voidptr) {
	C.ma_interleave_pcm_frames(format, channels, frame_count, const_pp_deinterleaved_pcm_frames,
		p_interleaved_pcm_frames)
}

// This is used in the shuffle table to indicate that the channel index is undefined and should be ignored.
pub const channel_index_null = 255

// C: `MA_API ma_channel ma_channel_map_get_channel(const ma_channel* pChannelMap, ma_uint32 channelCount, ma_uint32 channelIndex)`
fn C.ma_channel_map_get_channel(const_p_channel_map &u8, channel_count u32, channel_index u32) u8

// channel_map_get_channel retrieves the channel position of the specified channel in the given channel map.
//
// The pChannelMap parameter can be null, in which case miniaudio's default channel map will be assumed.
pub fn channel_map_get_channel(const_p_channel_map &u8, channel_count u32, channel_index u32) u8 {
	return C.ma_channel_map_get_channel(const_p_channel_map, channel_count, channel_index)
}

// C: `MA_API void ma_channel_map_init_blank(ma_channel* pChannelMap, ma_uint32 channels)`
fn C.ma_channel_map_init_blank(p_channel_map &u8, channels u32)

// channel_map_init_blank initializes a blank channel map.
//
// When a blank channel map is specified anywhere it indicates that the native channel map should be used.
pub fn channel_map_init_blank(p_channel_map &u8, channels u32) {
	C.ma_channel_map_init_blank(p_channel_map, channels)
}

// C: `MA_API void ma_channel_map_init_standard(ma_standard_channel_map standardChannelMap, ma_channel* pChannelMap, size_t channelMapCap, ma_uint32 channels)`
fn C.ma_channel_map_init_standard(standard_channel_map StandardChannelMap, p_channel_map &u8, channel_map_cap usize, channels u32)

// channel_map_init_standard helpers for retrieving a standard channel map.
//
// The output channel map buffer must have a capacity of at least `channelMapCap`.
pub fn channel_map_init_standard(standard_channel_map StandardChannelMap, p_channel_map &u8, channel_map_cap usize, channels u32) {
	C.ma_channel_map_init_standard(standard_channel_map, p_channel_map, channel_map_cap,
		channels)
}

// C: `MA_API void ma_channel_map_copy(ma_channel* pOut, const ma_channel* pIn, ma_uint32 channels)`
fn C.ma_channel_map_copy(p_out &u8, const_p_in &u8, channels u32)

// channel_map_copy copies a channel map.
//
// Both input and output channel map buffers must have a capacity of at at least `channels`.
pub fn channel_map_copy(p_out &u8, const_p_in &u8, channels u32) {
	C.ma_channel_map_copy(p_out, const_p_in, channels)
}

// C: `MA_API void ma_channel_map_copy_or_default(ma_channel* pOut, size_t channelMapCapOut, const ma_channel* pIn, ma_uint32 channels)`
fn C.ma_channel_map_copy_or_default(p_out &u8, channel_map_cap_out usize, const_p_in &u8, channels u32)

// channel_map_copy_or_default copies a channel map if one is specified, otherwise copies the default channel map.
//
// The output buffer must have a capacity of at least `channels`. If not NULL, the input channel map must also have a capacity of at least `channels`.
pub fn channel_map_copy_or_default(p_out &u8, channel_map_cap_out usize, const_p_in &u8, channels u32) {
	C.ma_channel_map_copy_or_default(p_out, channel_map_cap_out, const_p_in, channels)
}

// C: `MA_API ma_bool32 ma_channel_map_is_valid(const ma_channel* pChannelMap, ma_uint32 channels)`
fn C.ma_channel_map_is_valid(const_p_channel_map &u8, channels u32) u32

// channel_map_is_valid determines whether or not a channel map is valid.
//
// A blank channel map is valid (all channels set to MA_CHANNEL_NONE). The way a blank channel map is handled is context specific, but
// is usually treated as a passthrough.
//
// Invalid channel maps:
//  - A channel map with no channels
//  - A channel map with more than one channel and a mono channel
//
// The channel map buffer must have a capacity of at least `channels`.
pub fn channel_map_is_valid(const_p_channel_map &u8, channels u32) u32 {
	return C.ma_channel_map_is_valid(const_p_channel_map, channels)
}

// C: `MA_API ma_bool32 ma_channel_map_is_equal(const ma_channel* pChannelMapA, const ma_channel* pChannelMapB, ma_uint32 channels)`
fn C.ma_channel_map_is_equal(const_p_channel_map_a &u8, const_p_channel_map_b &u8, channels u32) u32

// channel_map_is_equal helpers for comparing two channel maps for equality.
//
// This assumes the channel count is the same between the two.
//
// Both channels map buffers must have a capacity of at least `channels`.
pub fn channel_map_is_equal(const_p_channel_map_a &u8, const_p_channel_map_b &u8, channels u32) u32 {
	return C.ma_channel_map_is_equal(const_p_channel_map_a, const_p_channel_map_b, channels)
}

// C: `MA_API ma_bool32 ma_channel_map_is_blank(const ma_channel* pChannelMap, ma_uint32 channels)`
fn C.ma_channel_map_is_blank(const_p_channel_map &u8, channels u32) u32

// channel_map_is_blank helpers for determining if a channel map is blank (all channels set to MA_CHANNEL_NONE).
//
// The channel map buffer must have a capacity of at least `channels`.
pub fn channel_map_is_blank(const_p_channel_map &u8, channels u32) u32 {
	return C.ma_channel_map_is_blank(const_p_channel_map, channels)
}

// C: `MA_API ma_bool32 ma_channel_map_contains_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition)`
fn C.ma_channel_map_contains_channel_position(channels u32, const_p_channel_map &u8, channel_position u8) u32

// channel_map_contains_channel_position helpers for determining whether or not a channel is present in the given channel map.
//
// The channel map buffer must have a capacity of at least `channels`.
pub fn channel_map_contains_channel_position(channels u32, const_p_channel_map &u8, channel_position u8) u32 {
	return C.ma_channel_map_contains_channel_position(channels, const_p_channel_map, channel_position)
}

// C: `MA_API ma_bool32 ma_channel_map_find_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition, ma_uint32* pChannelIndex)`
fn C.ma_channel_map_find_channel_position(channels u32, const_p_channel_map &u8, channel_position u8, p_channel_index &u32) u32

// channel_map_find_channel_position finds a channel position in the given channel map. Returns MA_TRUE if the channel is found; MA_FALSE otherwise. The
// index of the channel is output to `pChannelIndex`.
//
// The channel map buffer must have a capacity of at least `channels`.
pub fn channel_map_find_channel_position(channels u32, const_p_channel_map &u8, channel_position u8, p_channel_index &u32) u32 {
	return C.ma_channel_map_find_channel_position(channels, const_p_channel_map, channel_position,
		p_channel_index)
}

// C: `MA_API size_t ma_channel_map_to_string(const ma_channel* pChannelMap, ma_uint32 channels, char* pBufferOut, size_t bufferCap)`
fn C.ma_channel_map_to_string(const_p_channel_map &u8, channels u32, p_buffer_out &char, buffer_cap usize) usize

// channel_map_to_string generates a string representing the given channel map.
//
// This is for printing and debugging purposes, not serialization/deserialization.
//
// Returns the length of the string, not including the null terminator.
pub fn channel_map_to_string(const_p_channel_map &u8, channels u32, p_buffer_out &char, buffer_cap usize) usize {
	return C.ma_channel_map_to_string(const_p_channel_map, channels, p_buffer_out, buffer_cap)
}

// C: `MA_API const char* ma_channel_position_to_string(ma_channel channel)`
fn C.ma_channel_position_to_string(channel u8) &char

// channel_position_to_string retrieves a human readable version of a channel position.
pub fn channel_position_to_string(channel u8) &char {
	return C.ma_channel_position_to_string(channel)
}

// C: `MA_API ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn)`
fn C.ma_convert_frames(p_out voidptr, frame_count_out u64, format_out Format, channels_out u32, sample_rate_out u32, const_p_in voidptr, frame_count_in u64, format_in Format, channels_in u32, sample_rate_in u32) u64

// convert_frames high-levels helper for doing a full format conversion in one go. Returns the number of output frames. Call this with pOut set to NULL to
// determine the required size of the output buffer. frameCountOut should be set to the capacity of pOut. If pOut is NULL, frameCountOut is
// ignored.
//
// A return value of 0 indicates an error.
//
// This function is useful for one-off bulk conversions, but if you're streaming data you should use the ma_data_converter APIs instead.
pub fn convert_frames(p_out voidptr, frame_count_out u64, format_out Format, channels_out u32, sample_rate_out u32, const_p_in voidptr, frame_count_in u64, format_in Format, channels_in u32, sample_rate_in u32) u64 {
	return C.ma_convert_frames(p_out, frame_count_out, format_out, channels_out, sample_rate_out,
		const_p_in, frame_count_in, format_in, channels_in, sample_rate_in)
}

// C: `MA_API ma_uint64 ma_convert_frames_ex(void* pOut, ma_uint64 frameCountOut, const void* pIn, ma_uint64 frameCountIn, const ma_data_converter_config* pConfig)`
fn C.ma_convert_frames_ex(p_out voidptr, frame_count_out u64, const_p_in voidptr, frame_count_in u64, const_p_config &DataConverterConfig) u64

// convert_frames_ex is currently undocumented
pub fn convert_frames_ex(p_out voidptr, frame_count_out u64, const_p_in voidptr, frame_count_in u64, const_p_config &DataConverterConfig) u64 {
	return C.ma_convert_frames_ex(p_out, frame_count_out, const_p_in, frame_count_in,
		const_p_config)
}

@[typedef]
struct C.ma_rb {
pub mut:
	pBuffer                voidptr
	subbufferSizeInBytes   u32
	subbufferCount         u32
	subbufferStrideInBytes u32
	// TODO MA_ATOMIC(4, ma_uint32) encodedReadOffset
	// TODO MA_ATOMIC(4, ma_uint32) encodedWriteOffset
	ownsBuffer          u8 // Used to know whether or not miniaudio is responsible for free()-ing the buffer.
	clearOnWriteAcquire u8 // When set, clears the acquired write buffer before returning from ma_rb_acquire_write().
	allocationCallbacks AllocationCallbacks
}

pub type Rb = C.ma_rb

// C: `MA_API ma_result ma_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)`
fn C.ma_rb_init_ex(subbuffer_size_in_bytes usize, subbuffer_count usize, subbuffer_stride_in_bytes usize, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &Rb) Result

// rb_init_ex is currently undocumented
pub fn rb_init_ex(subbuffer_size_in_bytes usize, subbuffer_count usize, subbuffer_stride_in_bytes usize, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &Rb) Result {
	return C.ma_rb_init_ex(subbuffer_size_in_bytes, subbuffer_count, subbuffer_stride_in_bytes,
		p_optional_preallocated_buffer, const_p_allocation_callbacks, p_rb)
}

// C: `MA_API ma_result ma_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)`
fn C.ma_rb_init(buffer_size_in_bytes usize, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &Rb) Result

// rb_init is currently undocumented
pub fn rb_init(buffer_size_in_bytes usize, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &Rb) Result {
	return C.ma_rb_init(buffer_size_in_bytes, p_optional_preallocated_buffer, const_p_allocation_callbacks,
		p_rb)
}

// C: `MA_API void ma_rb_uninit(ma_rb* pRB)`
fn C.ma_rb_uninit(p_rb &Rb)

// rb_uninit is currently undocumented
pub fn rb_uninit(p_rb &Rb) {
	C.ma_rb_uninit(p_rb)
}

// C: `MA_API void ma_rb_reset(ma_rb* pRB)`
fn C.ma_rb_reset(p_rb &Rb)

// rb_reset is currently undocumented
pub fn rb_reset(p_rb &Rb) {
	C.ma_rb_reset(p_rb)
}

// C: `MA_API ma_result ma_rb_acquire_read(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)`
fn C.ma_rb_acquire_read(p_rb &Rb, p_size_in_bytes &usize, pp_buffer_out voidptr) Result

// rb_acquire_read is currently undocumented
pub fn rb_acquire_read(p_rb &Rb, p_size_in_bytes &usize, pp_buffer_out voidptr) Result {
	return C.ma_rb_acquire_read(p_rb, p_size_in_bytes, pp_buffer_out)
}

// C: `MA_API ma_result ma_rb_commit_read(ma_rb* pRB, size_t sizeInBytes)`
fn C.ma_rb_commit_read(p_rb &Rb, size_in_bytes usize) Result

// rb_commit_read is currently undocumented
pub fn rb_commit_read(p_rb &Rb, size_in_bytes usize) Result {
	return C.ma_rb_commit_read(p_rb, size_in_bytes)
}

// C: `MA_API ma_result ma_rb_acquire_write(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)`
fn C.ma_rb_acquire_write(p_rb &Rb, p_size_in_bytes &usize, pp_buffer_out voidptr) Result

// rb_acquire_write is currently undocumented
pub fn rb_acquire_write(p_rb &Rb, p_size_in_bytes &usize, pp_buffer_out voidptr) Result {
	return C.ma_rb_acquire_write(p_rb, p_size_in_bytes, pp_buffer_out)
}

// C: `MA_API ma_result ma_rb_commit_write(ma_rb* pRB, size_t sizeInBytes)`
fn C.ma_rb_commit_write(p_rb &Rb, size_in_bytes usize) Result

// rb_commit_write is currently undocumented
pub fn rb_commit_write(p_rb &Rb, size_in_bytes usize) Result {
	return C.ma_rb_commit_write(p_rb, size_in_bytes)
}

// C: `MA_API ma_result ma_rb_seek_read(ma_rb* pRB, size_t offsetInBytes)`
fn C.ma_rb_seek_read(p_rb &Rb, offset_in_bytes usize) Result

// rb_seek_read is currently undocumented
pub fn rb_seek_read(p_rb &Rb, offset_in_bytes usize) Result {
	return C.ma_rb_seek_read(p_rb, offset_in_bytes)
}

// C: `MA_API ma_result ma_rb_seek_write(ma_rb* pRB, size_t offsetInBytes)`
fn C.ma_rb_seek_write(p_rb &Rb, offset_in_bytes usize) Result

// rb_seek_write is currently undocumented
pub fn rb_seek_write(p_rb &Rb, offset_in_bytes usize) Result {
	return C.ma_rb_seek_write(p_rb, offset_in_bytes)
}

// C: `MA_API ma_int32 ma_rb_pointer_distance(ma_rb* pRB);/* Returns the distance between the write pointer and the read pointer. Should never be negative for a correct program. Will return the number of bytes that can be read before the read pointer hits the write pointer. */`
fn C.ma_rb_pointer_distance(p_rb &Rb) int

// rb_pointer_distance returns the distance between the write pointer and the read pointer. Should never be negative for a correct program. Will return the number of bytes that can be read before the read pointer hits the write pointer.
pub fn rb_pointer_distance(p_rb &Rb) int {
	return C.ma_rb_pointer_distance(p_rb)
}

// C: `MA_API ma_uint32 ma_rb_available_read(ma_rb* pRB)`
fn C.ma_rb_available_read(p_rb &Rb) u32

// rb_available_read is currently undocumented
pub fn rb_available_read(p_rb &Rb) u32 {
	return C.ma_rb_available_read(p_rb)
}

// C: `MA_API ma_uint32 ma_rb_available_write(ma_rb* pRB)`
fn C.ma_rb_available_write(p_rb &Rb) u32

// rb_available_write is currently undocumented
pub fn rb_available_write(p_rb &Rb) u32 {
	return C.ma_rb_available_write(p_rb)
}

// C: `MA_API size_t ma_rb_get_subbuffer_size(ma_rb* pRB)`
fn C.ma_rb_get_subbuffer_size(p_rb &Rb) usize

// rb_get_subbuffer_size is currently undocumented
pub fn rb_get_subbuffer_size(p_rb &Rb) usize {
	return C.ma_rb_get_subbuffer_size(p_rb)
}

// C: `MA_API size_t ma_rb_get_subbuffer_stride(ma_rb* pRB)`
fn C.ma_rb_get_subbuffer_stride(p_rb &Rb) usize

// rb_get_subbuffer_stride is currently undocumented
pub fn rb_get_subbuffer_stride(p_rb &Rb) usize {
	return C.ma_rb_get_subbuffer_stride(p_rb)
}

// C: `MA_API size_t ma_rb_get_subbuffer_offset(ma_rb* pRB, size_t subbufferIndex)`
fn C.ma_rb_get_subbuffer_offset(p_rb &Rb, subbuffer_index usize) usize

// rb_get_subbuffer_offset is currently undocumented
pub fn rb_get_subbuffer_offset(p_rb &Rb, subbuffer_index usize) usize {
	return C.ma_rb_get_subbuffer_offset(p_rb, subbuffer_index)
}

// C: `MA_API void* ma_rb_get_subbuffer_ptr(ma_rb* pRB, size_t subbufferIndex, void* pBuffer)`
fn C.ma_rb_get_subbuffer_ptr(p_rb &Rb, subbuffer_index usize, p_buffer voidptr) voidptr

// rb_get_subbuffer_ptr is currently undocumented
pub fn rb_get_subbuffer_ptr(p_rb &Rb, subbuffer_index usize, p_buffer voidptr) voidptr {
	return C.ma_rb_get_subbuffer_ptr(p_rb, subbuffer_index, p_buffer)
}

@[typedef]
struct C.ma_pcm_rb {
pub mut:
	rb       Rb
	format   Format
	channels u32
}

pub type PcmRb = C.ma_pcm_rb

// C: `MA_API ma_result ma_pcm_rb_init_ex(ma_format format, ma_uint32 channels, ma_uint32 subbufferSizeInFrames, ma_uint32 subbufferCount, ma_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_init_ex(format Format, channels u32, subbuffer_size_in_frames u32, subbuffer_count u32, subbuffer_stride_in_frames u32, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &PcmRb) Result

// pcm_rb_init_ex is currently undocumented
pub fn pcm_rb_init_ex(format Format, channels u32, subbuffer_size_in_frames u32, subbuffer_count u32, subbuffer_stride_in_frames u32, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &PcmRb) Result {
	return C.ma_pcm_rb_init_ex(format, channels, subbuffer_size_in_frames, subbuffer_count,
		subbuffer_stride_in_frames, p_optional_preallocated_buffer, const_p_allocation_callbacks,
		p_rb)
}

// C: `MA_API ma_result ma_pcm_rb_init(ma_format format, ma_uint32 channels, ma_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_init(format Format, channels u32, buffer_size_in_frames u32, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &PcmRb) Result

// pcm_rb_init is currently undocumented
pub fn pcm_rb_init(format Format, channels u32, buffer_size_in_frames u32, p_optional_preallocated_buffer voidptr, const_p_allocation_callbacks &AllocationCallbacks, p_rb &PcmRb) Result {
	return C.ma_pcm_rb_init(format, channels, buffer_size_in_frames, p_optional_preallocated_buffer,
		const_p_allocation_callbacks, p_rb)
}

// C: `MA_API void ma_pcm_rb_uninit(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_uninit(p_rb &PcmRb)

// pcm_rb_uninit is currently undocumented
pub fn pcm_rb_uninit(p_rb &PcmRb) {
	C.ma_pcm_rb_uninit(p_rb)
}

// C: `MA_API void ma_pcm_rb_reset(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_reset(p_rb &PcmRb)

// pcm_rb_reset is currently undocumented
pub fn pcm_rb_reset(p_rb &PcmRb) {
	C.ma_pcm_rb_reset(p_rb)
}

// C: `MA_API ma_result ma_pcm_rb_acquire_read(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)`
fn C.ma_pcm_rb_acquire_read(p_rb &PcmRb, p_size_in_frames &u32, pp_buffer_out voidptr) Result

// pcm_rb_acquire_read is currently undocumented
pub fn pcm_rb_acquire_read(p_rb &PcmRb, p_size_in_frames &u32, pp_buffer_out voidptr) Result {
	return C.ma_pcm_rb_acquire_read(p_rb, p_size_in_frames, pp_buffer_out)
}

// C: `MA_API ma_result ma_pcm_rb_commit_read(ma_pcm_rb* pRB, ma_uint32 sizeInFrames)`
fn C.ma_pcm_rb_commit_read(p_rb &PcmRb, size_in_frames u32) Result

// pcm_rb_commit_read is currently undocumented
pub fn pcm_rb_commit_read(p_rb &PcmRb, size_in_frames u32) Result {
	return C.ma_pcm_rb_commit_read(p_rb, size_in_frames)
}

// C: `MA_API ma_result ma_pcm_rb_acquire_write(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)`
fn C.ma_pcm_rb_acquire_write(p_rb &PcmRb, p_size_in_frames &u32, pp_buffer_out voidptr) Result

// pcm_rb_acquire_write is currently undocumented
pub fn pcm_rb_acquire_write(p_rb &PcmRb, p_size_in_frames &u32, pp_buffer_out voidptr) Result {
	return C.ma_pcm_rb_acquire_write(p_rb, p_size_in_frames, pp_buffer_out)
}

// C: `MA_API ma_result ma_pcm_rb_commit_write(ma_pcm_rb* pRB, ma_uint32 sizeInFrames)`
fn C.ma_pcm_rb_commit_write(p_rb &PcmRb, size_in_frames u32) Result

// pcm_rb_commit_write is currently undocumented
pub fn pcm_rb_commit_write(p_rb &PcmRb, size_in_frames u32) Result {
	return C.ma_pcm_rb_commit_write(p_rb, size_in_frames)
}

// C: `MA_API ma_result ma_pcm_rb_seek_read(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)`
fn C.ma_pcm_rb_seek_read(p_rb &PcmRb, offset_in_frames u32) Result

// pcm_rb_seek_read is currently undocumented
pub fn pcm_rb_seek_read(p_rb &PcmRb, offset_in_frames u32) Result {
	return C.ma_pcm_rb_seek_read(p_rb, offset_in_frames)
}

// C: `MA_API ma_result ma_pcm_rb_seek_write(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)`
fn C.ma_pcm_rb_seek_write(p_rb &PcmRb, offset_in_frames u32) Result

// pcm_rb_seek_write is currently undocumented
pub fn pcm_rb_seek_write(p_rb &PcmRb, offset_in_frames u32) Result {
	return C.ma_pcm_rb_seek_write(p_rb, offset_in_frames)
}

// C: `MA_API ma_int32 ma_pcm_rb_pointer_distance(ma_pcm_rb* pRB); /* Return value is in frames. */`
fn C.ma_pcm_rb_pointer_distance(p_rb &PcmRb) int

// pcm_rb_pointer_distance returns value is in frames.
pub fn pcm_rb_pointer_distance(p_rb &PcmRb) int {
	return C.ma_pcm_rb_pointer_distance(p_rb)
}

// C: `MA_API ma_uint32 ma_pcm_rb_available_read(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_available_read(p_rb &PcmRb) u32

// pcm_rb_available_read is currently undocumented
pub fn pcm_rb_available_read(p_rb &PcmRb) u32 {
	return C.ma_pcm_rb_available_read(p_rb)
}

// C: `MA_API ma_uint32 ma_pcm_rb_available_write(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_available_write(p_rb &PcmRb) u32

// pcm_rb_available_write is currently undocumented
pub fn pcm_rb_available_write(p_rb &PcmRb) u32 {
	return C.ma_pcm_rb_available_write(p_rb)
}

// C: `MA_API ma_uint32 ma_pcm_rb_get_subbuffer_size(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_get_subbuffer_size(p_rb &PcmRb) u32

// pcm_rb_get_subbuffer_size is currently undocumented
pub fn pcm_rb_get_subbuffer_size(p_rb &PcmRb) u32 {
	return C.ma_pcm_rb_get_subbuffer_size(p_rb)
}

// C: `MA_API ma_uint32 ma_pcm_rb_get_subbuffer_stride(ma_pcm_rb* pRB)`
fn C.ma_pcm_rb_get_subbuffer_stride(p_rb &PcmRb) u32

// pcm_rb_get_subbuffer_stride is currently undocumented
pub fn pcm_rb_get_subbuffer_stride(p_rb &PcmRb) u32 {
	return C.ma_pcm_rb_get_subbuffer_stride(p_rb)
}

// C: `MA_API ma_uint32 ma_pcm_rb_get_subbuffer_offset(ma_pcm_rb* pRB, ma_uint32 subbufferIndex)`
fn C.ma_pcm_rb_get_subbuffer_offset(p_rb &PcmRb, subbuffer_index u32) u32

// pcm_rb_get_subbuffer_offset is currently undocumented
pub fn pcm_rb_get_subbuffer_offset(p_rb &PcmRb, subbuffer_index u32) u32 {
	return C.ma_pcm_rb_get_subbuffer_offset(p_rb, subbuffer_index)
}

// C: `MA_API void* ma_pcm_rb_get_subbuffer_ptr(ma_pcm_rb* pRB, ma_uint32 subbufferIndex, void* pBuffer)`
fn C.ma_pcm_rb_get_subbuffer_ptr(p_rb &PcmRb, subbuffer_index u32, p_buffer voidptr) voidptr

// pcm_rb_get_subbuffer_ptr is currently undocumented
pub fn pcm_rb_get_subbuffer_ptr(p_rb &PcmRb, subbuffer_index u32, p_buffer voidptr) voidptr {
	return C.ma_pcm_rb_get_subbuffer_ptr(p_rb, subbuffer_index, p_buffer)
}

@[typedef]
struct C.ma_duplex_rb {
pub mut:
	rb PcmRb
}

pub type DuplexRb = C.ma_duplex_rb

// C: `MA_API ma_result ma_duplex_rb_init(ma_format captureFormat, ma_uint32 captureChannels, ma_uint32 sampleRate, ma_uint32 captureInternalSampleRate, ma_uint32 captureInternalPeriodSizeInFrames, const ma_allocation_callbacks* pAllocationCallbacks, ma_duplex_rb* pRB)`
fn C.ma_duplex_rb_init(capture_format Format, capture_channels u32, sample_rate u32, capture_internal_sample_rate u32, capture_internal_period_size_in_frames u32, const_p_allocation_callbacks &AllocationCallbacks, p_rb &DuplexRb) Result

// duplex_rb_init is currently undocumented
pub fn duplex_rb_init(capture_format Format, capture_channels u32, sample_rate u32, capture_internal_sample_rate u32, capture_internal_period_size_in_frames u32, const_p_allocation_callbacks &AllocationCallbacks, p_rb &DuplexRb) Result {
	return C.ma_duplex_rb_init(capture_format, capture_channels, sample_rate, capture_internal_sample_rate,
		capture_internal_period_size_in_frames, const_p_allocation_callbacks, p_rb)
}

// C: `MA_API ma_result ma_duplex_rb_uninit(ma_duplex_rb* pRB)`
fn C.ma_duplex_rb_uninit(p_rb &DuplexRb) Result

// duplex_rb_uninit is currently undocumented
pub fn duplex_rb_uninit(p_rb &DuplexRb) Result {
	return C.ma_duplex_rb_uninit(p_rb)
}

// C: `MA_API const char* ma_result_description(ma_result result)`
fn C.ma_result_description(result Result) &char

// result_description retrieves a human readable description of the given result code.
pub fn result_description(result Result) &char {
	return C.ma_result_description(result)
}

// C: `MA_API void* ma_malloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_malloc(sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr

// malloc is currently undocumented
pub fn malloc(sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr {
	return C.ma_malloc(sz, const_p_allocation_callbacks)
}

// C: `MA_API void* ma_calloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_calloc(sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr

// calloc is currently undocumented
pub fn calloc(sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr {
	return C.ma_calloc(sz, const_p_allocation_callbacks)
}

// C: `MA_API void* ma_realloc(void* p, size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_realloc(p voidptr, sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr

// realloc is currently undocumented
pub fn realloc(p voidptr, sz usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr {
	return C.ma_realloc(p, sz, const_p_allocation_callbacks)
}

// C: `MA_API void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_free(p voidptr, const_p_allocation_callbacks &AllocationCallbacks)

// free is currently undocumented
pub fn free(p voidptr, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_free(p, const_p_allocation_callbacks)
}

// C: `MA_API void* ma_aligned_malloc(size_t sz, size_t alignment, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_aligned_malloc(sz usize, alignment usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr

// aligned_malloc performs an aligned malloc, with the assumption that the alignment is a power of 2.
pub fn aligned_malloc(sz usize, alignment usize, const_p_allocation_callbacks &AllocationCallbacks) voidptr {
	return C.ma_aligned_malloc(sz, alignment, const_p_allocation_callbacks)
}

// C: `MA_API void ma_aligned_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_aligned_free(p voidptr, const_p_allocation_callbacks &AllocationCallbacks)

// aligned_free free's an aligned malloc'd buffer.
pub fn aligned_free(p voidptr, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_aligned_free(p, const_p_allocation_callbacks)
}

// C: `MA_API const char* ma_get_format_name(ma_format format)`
fn C.ma_get_format_name(format Format) &char

// get_format_name retrieves a friendly name for a format.
pub fn get_format_name(format Format) &char {
	return C.ma_get_format_name(format)
}

// C: `MA_API void ma_blend_f32(float* pOut, float* pInA, float* pInB, float factor, ma_uint32 channels)`
fn C.ma_blend_f32(p_out &f32, p_in_a &f32, p_in_b &f32, factor f32, channels u32)

// blend_f32 blends two frames in floating point format.
pub fn blend_f32(p_out &f32, p_in_a &f32, p_in_b &f32, factor f32, channels u32) {
	C.ma_blend_f32(p_out, p_in_a, p_in_b, factor, channels)
}

// C: `MA_API ma_uint32 ma_get_bytes_per_sample(ma_format format)`
fn C.ma_get_bytes_per_sample(format Format) u32

// get_bytes_per_sample retrieves the size of a sample in bytes for the given format.
//
// This API is efficient and is implemented using a lookup table.
//
// Thread Safety: SAFE
//  This API is pure.
pub fn get_bytes_per_sample(format Format) u32 {
	return C.ma_get_bytes_per_sample(format)
}

// C: `MA_API const char* ma_log_level_to_string(ma_uint32 logLevel)`
fn C.ma_log_level_to_string(log_level u32) &char

// log_level_to_string converts a log level to a string.
pub fn log_level_to_string(log_level u32) &char {
	return C.ma_log_level_to_string(log_level)
}

// C: `MA_API ma_result ma_spinlock_lock(volatile ma_spinlock* pSpinlock)`
fn C.ma_spinlock_lock(p_spinlock &u32) Result

// spinlock_lock locks a spinlock.
pub fn spinlock_lock(p_spinlock &u32) Result {
	return C.ma_spinlock_lock(p_spinlock)
}

// C: `MA_API ma_result ma_spinlock_lock_noyield(volatile ma_spinlock* pSpinlock)`
fn C.ma_spinlock_lock_noyield(p_spinlock &u32) Result

// spinlock_lock_noyield locks a spinlock, but does not yield() when looping.
pub fn spinlock_lock_noyield(p_spinlock &u32) Result {
	return C.ma_spinlock_lock_noyield(p_spinlock)
}

// C: `MA_API ma_result ma_spinlock_unlock(volatile ma_spinlock* pSpinlock)`
fn C.ma_spinlock_unlock(p_spinlock &u32) Result

// spinlock_unlock unlocks a spinlock.
pub fn spinlock_unlock(p_spinlock &u32) Result {
	return C.ma_spinlock_unlock(p_spinlock)
}

// C: `MA_API ma_result ma_mutex_init(ma_mutex* pMutex)`
fn C.ma_mutex_init(p_mutex &C.ma_mutex) Result

// mutex_init creates a mutex.
//
// A mutex must be created from a valid context. A mutex is initially unlocked.
pub fn mutex_init(p_mutex &C.ma_mutex) Result {
	return C.ma_mutex_init(p_mutex)
}

// C: `MA_API void ma_mutex_uninit(ma_mutex* pMutex)`
fn C.ma_mutex_uninit(p_mutex &C.ma_mutex)

// mutex_uninit deletes a mutex.
pub fn mutex_uninit(p_mutex &C.ma_mutex) {
	C.ma_mutex_uninit(p_mutex)
}

// C: `MA_API void ma_mutex_lock(ma_mutex* pMutex)`
fn C.ma_mutex_lock(p_mutex &C.ma_mutex)

// mutex_lock locks a mutex with an infinite timeout.
pub fn mutex_lock(p_mutex &C.ma_mutex) {
	C.ma_mutex_lock(p_mutex)
}

// C: `MA_API void ma_mutex_unlock(ma_mutex* pMutex)`
fn C.ma_mutex_unlock(p_mutex &C.ma_mutex)

// mutex_unlock unlocks a mutex.
pub fn mutex_unlock(p_mutex &C.ma_mutex) {
	C.ma_mutex_unlock(p_mutex)
}

// C: `MA_API ma_result ma_event_init(ma_event* pEvent)`
fn C.ma_event_init(p_event &Event) Result

// event_init initializes an auto-reset event.
pub fn event_init(p_event &Event) Result {
	return C.ma_event_init(p_event)
}

// C: `MA_API void ma_event_uninit(ma_event* pEvent)`
fn C.ma_event_uninit(p_event &Event)

// event_uninit uninitializes an auto-reset event.
pub fn event_uninit(p_event &Event) {
	C.ma_event_uninit(p_event)
}

// C: `MA_API ma_result ma_event_wait(ma_event* pEvent)`
fn C.ma_event_wait(p_event &Event) Result

// event_wait waits for the specified auto-reset event to become signalled.
pub fn event_wait(p_event &Event) Result {
	return C.ma_event_wait(p_event)
}

// C: `MA_API ma_result ma_event_signal(ma_event* pEvent)`
fn C.ma_event_signal(p_event &Event) Result

// event_signal signals the specified auto-reset event.
pub fn event_signal(p_event &Event) Result {
	return C.ma_event_signal(p_event)
}

@[typedef]
struct C.ma_fence {
pub mut:
	// TODO 	MA_NO_THREADING C.#ifndef // ma_event
	counter u32
}

pub type Fence = C.ma_fence

// C: `MA_API ma_result ma_fence_init(ma_fence* pFence)`
fn C.ma_fence_init(p_fence &Fence) Result

// fence_init is currently undocumented
pub fn fence_init(p_fence &Fence) Result {
	return C.ma_fence_init(p_fence)
}

// C: `MA_API void ma_fence_uninit(ma_fence* pFence)`
fn C.ma_fence_uninit(p_fence &Fence)

// fence_uninit is currently undocumented
pub fn fence_uninit(p_fence &Fence) {
	C.ma_fence_uninit(p_fence)
}

// C: `MA_API ma_result ma_fence_acquire(ma_fence* pFence);/* Increment counter. */`
fn C.ma_fence_acquire(p_fence &Fence) Result

// fence_acquire increments counter.
pub fn fence_acquire(p_fence &Fence) Result {
	return C.ma_fence_acquire(p_fence)
}

// C: `MA_API ma_result ma_fence_release(ma_fence* pFence);/* Decrement counter. */`
fn C.ma_fence_release(p_fence &Fence) Result

// fence_release decrements counter.
pub fn fence_release(p_fence &Fence) Result {
	return C.ma_fence_release(p_fence)
}

// C: `MA_API ma_result ma_fence_wait(ma_fence* pFence); /* Wait for counter to reach 0. */`
fn C.ma_fence_wait(p_fence &Fence) Result

// fence_wait waits for counter to reach 0.
pub fn fence_wait(p_fence &Fence) Result {
	return C.ma_fence_wait(p_fence)
}

@[typedef]
struct C.ma_async_notification_callbacks {
pub mut:
	onSignal fn (p_notification voidptr) // onSignal)(ma_async_notification*
}

pub type AsyncNotificationCallbacks = C.ma_async_notification_callbacks

// C: `MA_API ma_result ma_async_notification_signal(ma_async_notification* pNotification)`
fn C.ma_async_notification_signal(p_notification voidptr) Result

// async_notification_signal is currently undocumented
pub fn async_notification_signal(p_notification voidptr) Result {
	return C.ma_async_notification_signal(p_notification)
}

@[typedef]
struct C.ma_async_notification_poll {
pub mut:
	cb        AsyncNotificationCallbacks
	signalled u32
}

pub type AsyncNotificationPoll = C.ma_async_notification_poll

// C: `MA_API ma_result ma_async_notification_poll_init(ma_async_notification_poll* pNotificationPoll)`
fn C.ma_async_notification_poll_init(p_notification_poll &AsyncNotificationPoll) Result

// async_notification_poll_init is currently undocumented
pub fn async_notification_poll_init(p_notification_poll &AsyncNotificationPoll) Result {
	return C.ma_async_notification_poll_init(p_notification_poll)
}

// C: `MA_API ma_bool32 ma_async_notification_poll_is_signalled(const ma_async_notification_poll* pNotificationPoll)`
fn C.ma_async_notification_poll_is_signalled(const_p_notification_poll &AsyncNotificationPoll) u32

// async_notification_poll_is_signalled is currently undocumented
pub fn async_notification_poll_is_signalled(const_p_notification_poll &AsyncNotificationPoll) u32 {
	return C.ma_async_notification_poll_is_signalled(const_p_notification_poll)
}

@[typedef]
struct C.ma_async_notification_event {
pub mut:
	cb AsyncNotificationCallbacks
	// TODO 	MA_NO_THREADING C.#ifndef // ma_event
}

pub type AsyncNotificationEvent = C.ma_async_notification_event

// C: `MA_API ma_result ma_async_notification_event_init(ma_async_notification_event* pNotificationEvent)`
fn C.ma_async_notification_event_init(p_notification_event &AsyncNotificationEvent) Result

// async_notification_event_init is currently undocumented
pub fn async_notification_event_init(p_notification_event &AsyncNotificationEvent) Result {
	return C.ma_async_notification_event_init(p_notification_event)
}

// C: `MA_API ma_result ma_async_notification_event_uninit(ma_async_notification_event* pNotificationEvent)`
fn C.ma_async_notification_event_uninit(p_notification_event &AsyncNotificationEvent) Result

// async_notification_event_uninit is currently undocumented
pub fn async_notification_event_uninit(p_notification_event &AsyncNotificationEvent) Result {
	return C.ma_async_notification_event_uninit(p_notification_event)
}

// C: `MA_API ma_result ma_async_notification_event_wait(ma_async_notification_event* pNotificationEvent)`
fn C.ma_async_notification_event_wait(p_notification_event &AsyncNotificationEvent) Result

// async_notification_event_wait is currently undocumented
pub fn async_notification_event_wait(p_notification_event &AsyncNotificationEvent) Result {
	return C.ma_async_notification_event_wait(p_notification_event)
}

// C: `MA_API ma_result ma_async_notification_event_signal(ma_async_notification_event* pNotificationEvent)`
fn C.ma_async_notification_event_signal(p_notification_event &AsyncNotificationEvent) Result

// async_notification_event_signal is currently undocumented
pub fn async_notification_event_signal(p_notification_event &AsyncNotificationEvent) Result {
	return C.ma_async_notification_event_signal(p_notification_event)
}

@[typedef]
struct C.ma_slot_allocator_config {
pub mut:
	capacity u32 // The number of slots to make available.
}

pub type SlotAllocatorConfig = C.ma_slot_allocator_config

// C: `MA_API ma_slot_allocator_config ma_slot_allocator_config_init(ma_uint32 capacity)`
fn C.ma_slot_allocator_config_init(capacity u32) SlotAllocatorConfig

// slot_allocator_config_init is currently undocumented
pub fn slot_allocator_config_init(capacity u32) SlotAllocatorConfig {
	return C.ma_slot_allocator_config_init(capacity)
}

@[typedef]
struct C.ma_slot_allocator_group {
	// TODO MA_ATOMIC(4, ma_uint32) bitfield
}

pub type SlotAllocatorGroup = C.ma_slot_allocator_group

@[typedef]
struct C.ma_slot_allocator {
pub mut:
	pGroups   &SlotAllocatorGroup = unsafe { nil } // Slots are grouped in chunks of 32.
	pSlots    &u32                = unsafe { nil } // 32 bits for reference counting for ABA mitigation.
	count     u32 // Allocation count.
	capacity  u32 // Memory management.
	_ownsHeap u32
	_pHeap    voidptr
}

pub type SlotAllocator = C.ma_slot_allocator

// C: `MA_API ma_result ma_slot_allocator_get_heap_size(const ma_slot_allocator_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_slot_allocator_get_heap_size(const_p_config &SlotAllocatorConfig, p_heap_size_in_bytes &usize) Result

// slot_allocator_get_heap_size is currently undocumented
pub fn slot_allocator_get_heap_size(const_p_config &SlotAllocatorConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_slot_allocator_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_slot_allocator_init_preallocated(const ma_slot_allocator_config* pConfig, void* pHeap, ma_slot_allocator* pAllocator)`
fn C.ma_slot_allocator_init_preallocated(const_p_config &SlotAllocatorConfig, p_heap voidptr, p_allocator &SlotAllocator) Result

// slot_allocator_init_preallocated is currently undocumented
pub fn slot_allocator_init_preallocated(const_p_config &SlotAllocatorConfig, p_heap voidptr, p_allocator &SlotAllocator) Result {
	return C.ma_slot_allocator_init_preallocated(const_p_config, p_heap, p_allocator)
}

// C: `MA_API ma_result ma_slot_allocator_init(const ma_slot_allocator_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_slot_allocator* pAllocator)`
fn C.ma_slot_allocator_init(const_p_config &SlotAllocatorConfig, const_p_allocation_callbacks &AllocationCallbacks, p_allocator &SlotAllocator) Result

// slot_allocator_init is currently undocumented
pub fn slot_allocator_init(const_p_config &SlotAllocatorConfig, const_p_allocation_callbacks &AllocationCallbacks, p_allocator &SlotAllocator) Result {
	return C.ma_slot_allocator_init(const_p_config, const_p_allocation_callbacks, p_allocator)
}

// C: `MA_API void ma_slot_allocator_uninit(ma_slot_allocator* pAllocator, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_slot_allocator_uninit(p_allocator &SlotAllocator, const_p_allocation_callbacks &AllocationCallbacks)

// slot_allocator_uninit is currently undocumented
pub fn slot_allocator_uninit(p_allocator &SlotAllocator, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_slot_allocator_uninit(p_allocator, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_slot_allocator_alloc(ma_slot_allocator* pAllocator, ma_uint64* pSlot)`
fn C.ma_slot_allocator_alloc(p_allocator &SlotAllocator, p_slot &u64) Result

// slot_allocator_alloc is currently undocumented
pub fn slot_allocator_alloc(p_allocator &SlotAllocator, p_slot &u64) Result {
	return C.ma_slot_allocator_alloc(p_allocator, p_slot)
}

// C: `MA_API ma_result ma_slot_allocator_free(ma_slot_allocator* pAllocator, ma_uint64 slot)`
fn C.ma_slot_allocator_free(p_allocator &SlotAllocator, slot u64) Result

// slot_allocator_free is currently undocumented
pub fn slot_allocator_free(p_allocator &SlotAllocator, slot u64) Result {
	return C.ma_slot_allocator_free(p_allocator, slot)
}

// JobProc callbacks for processing a job. Each job type will have their own processing callback which will be
// called by ma_job_process().
// C: typedef ma_result (* ma_job_proc)(ma_job* pJob);
pub type JobProc = fn (p_job &Job) Result

// JobType is C.ma_job_type
pub enum JobType {
	// 0, Miscellaneous.
	quit   = C.MA_JOB_TYPE_QUIT
	custom = C.MA_JOB_TYPE_CUSTOM
	// Resource Manager.
	resource_manager_load_data_buffer_node = C.MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE
	resource_manager_free_data_buffer_node = C.MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE
	resource_manager_page_data_buffer_node = C.MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE
	resource_manager_load_data_buffer      = C.MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER
	resource_manager_free_data_buffer      = C.MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER
	resource_manager_load_data_stream      = C.MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM
	resource_manager_free_data_stream      = C.MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM
	resource_manager_page_data_stream      = C.MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM
	resource_manager_seek_data_stream      = C.MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM
	// Device.
	device_aaudio_reroute = C.MA_JOB_TYPE_DEVICE_AAUDIO_REROUTE
	// Count. Must always be last.
	count = C.MA_JOB_TYPE_COUNT
}

@[typedef]
struct C.ma_job {
pub mut:
	// TODO// union {
	//  struct {
	//  ma_uint16 code; ma_uint16 slot; ma_uint32 refcount; } breakup
	allocation u64 // } 8 bytes. We encode the job code into the slot allocation data to save space.
	// TODO MA_ATOMIC(8, ma_uint64) next
	order u32 // Execution order. Used to create a data dependency and ensure a job is executed in order. Usage is contextual depending on the job type.
	// TODO// union {
	//  /* Miscellaneous.*/; struct {
	//  ma_job_proc proc; ma_uintptr data0; ma_uintptr data1; } custom
	// TODO// union {
	//  struct {
	//  /*ma_resource_manager**/ void*; pResourceManager void*; pDataBufferNode char*; pFilePath wchar_t*; pFilePathW ma_uint32; flags ma_async_notification*; pInitNotification ma_async_notification*; pDoneNotification ma_fence*; pInitFence ma_fence*; pDoneFence /*; Released if; initialization of; the decoder; fails. Passed; through to; PAGE_DATA_BUFFER_NODE untouched; if init; is successful.*/; } loadDataBufferNode
	// TODO// struct {
	//  /*ma_resource_manager**/ void*; pResourceManager void*; pDataBufferNode ma_async_notification*; pDoneNotification ma_fence*; pDoneFence }; freeDataBufferNode
	// TODO// struct {
	//  /*ma_resource_manager**/ void*; pResourceManager void*; pDataBufferNode void*; pDecoder ma_async_notification*; pDoneNotification ma_fence*; pDoneFence /*; Passed through; from LOAD_DATA_BUFFER_NODE; and released; when the; data buffer; completes decoding; or an; error occurs.*/; } pageDataBufferNode
	// TODO// struct {
	//  /*ma_resource_manager_data_buffer**/ void*; pDataBuffer ma_async_notification*; pInitNotification ma_async_notification*; pDoneNotification ma_fence*; pInitFence ma_fence*; pDoneFence ma_uint64; rangeBegInPCMFrames ma_uint64; rangeEndInPCMFrames ma_uint64; loopPointBegInPCMFrames ma_uint64; loopPointEndInPCMFrames ma_uint32; isLooping }; loadDataBuffer
	// TODO// struct {
	//  /*ma_resource_manager_data_buffer**/ void*; pDataBuffer ma_async_notification*; pDoneNotification ma_fence*; pDoneFence }; freeDataBuffer
	// TODO// struct {
	//  /*ma_resource_manager_data_stream**/ void*; pDataStream char*; pFilePath wchar_t*; pFilePathW ma_uint64; initialSeekPoint ma_async_notification*; pInitNotification ma_fence*; pInitFence }; loadDataStream
	// TODO// struct {
	//  /*ma_resource_manager_data_stream**/ void*; pDataStream ma_async_notification*; pDoneNotification ma_fence*; pDoneFence }; freeDataStream
	// TODO// struct {
	//  /*ma_resource_manager_data_stream**/ void*; pDataStream ma_uint32; pageIndex /*; The index; of the; page to; decode into.*/; } pageDataStream
	// TODO// struct {
	//  /*ma_resource_manager_data_stream**/ void*; pDataStream ma_uint64; frameIndex }; seekDataStream }; resourceManager
	// TODO// union {
	//  union {
	//  struct {
	//  /*ma_device**/ void*; pDevice ma_uint32; deviceType }; reroute }; aaudio }; device }; data
}

pub type Job = C.ma_job

// C: `MA_API ma_job ma_job_init(ma_uint16 code)`
fn C.ma_job_init(code u16) Job

// job_init is currently undocumented
pub fn job_init(code u16) Job {
	return C.ma_job_init(code)
}

// C: `MA_API ma_result ma_job_process(ma_job* pJob)`
fn C.ma_job_process(p_job &Job) Result

// job_process is currently undocumented
pub fn job_process(p_job &Job) Result {
	return C.ma_job_process(p_job)
}

// JobQueueFlags is C.ma_job_queue_flags
pub enum JobQueueFlags {
	job_queue_flag_non_blocking = C.MA_JOB_QUEUE_FLAG_NON_BLOCKING // 0x00000001,
}

@[typedef]
struct C.ma_job_queue_config {
pub mut:
	flags    u32
	capacity u32 // The maximum number of jobs that can fit in the queue at a time.
}

pub type JobQueueConfig = C.ma_job_queue_config

// C: `MA_API ma_job_queue_config ma_job_queue_config_init(ma_uint32 flags, ma_uint32 capacity)`
fn C.ma_job_queue_config_init(flags u32, capacity u32) JobQueueConfig

// job_queue_config_init is currently undocumented
pub fn job_queue_config_init(flags u32, capacity u32) JobQueueConfig {
	return C.ma_job_queue_config_init(flags, capacity)
}

@[typedef]
struct C.ma_job_queue {
pub mut:
	flags    u32 // Flags passed in at initialization time.
	capacity u32 // The maximum number of jobs that can fit in the queue at a time. Set by the config.
	// TODO MA_ATOMIC(8, ma_uint64) head
	// TODO MA_ATOMIC(8, ma_uint64) tail
	// TODO 	MA_NO_THREADING C.#ifndef // ma_semaphore Only used when MA_JOB_QUEUE_FLAG_NON_BLOCKING is unset.
	allocator SlotAllocator
	pJobs     &Job = unsafe { nil }
	// TODO 	MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE C.#ifndef // ma_spinlock Memory management.
	_pHeap    voidptr
	_ownsHeap u32
}

pub type JobQueue = C.ma_job_queue

// C: `MA_API ma_result ma_job_queue_get_heap_size(const ma_job_queue_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_job_queue_get_heap_size(const_p_config &JobQueueConfig, p_heap_size_in_bytes &usize) Result

// job_queue_get_heap_size is currently undocumented
pub fn job_queue_get_heap_size(const_p_config &JobQueueConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_job_queue_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_job_queue_init_preallocated(const ma_job_queue_config* pConfig, void* pHeap, ma_job_queue* pQueue)`
fn C.ma_job_queue_init_preallocated(const_p_config &JobQueueConfig, p_heap voidptr, p_queue &JobQueue) Result

// job_queue_init_preallocated is currently undocumented
pub fn job_queue_init_preallocated(const_p_config &JobQueueConfig, p_heap voidptr, p_queue &JobQueue) Result {
	return C.ma_job_queue_init_preallocated(const_p_config, p_heap, p_queue)
}

// C: `MA_API ma_result ma_job_queue_init(const ma_job_queue_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_job_queue* pQueue)`
fn C.ma_job_queue_init(const_p_config &JobQueueConfig, const_p_allocation_callbacks &AllocationCallbacks, p_queue &JobQueue) Result

// job_queue_init is currently undocumented
pub fn job_queue_init(const_p_config &JobQueueConfig, const_p_allocation_callbacks &AllocationCallbacks, p_queue &JobQueue) Result {
	return C.ma_job_queue_init(const_p_config, const_p_allocation_callbacks, p_queue)
}

// C: `MA_API void ma_job_queue_uninit(ma_job_queue* pQueue, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_job_queue_uninit(p_queue &JobQueue, const_p_allocation_callbacks &AllocationCallbacks)

// job_queue_uninit is currently undocumented
pub fn job_queue_uninit(p_queue &JobQueue, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_job_queue_uninit(p_queue, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_job_queue_post(ma_job_queue* pQueue, const ma_job* pJob)`
fn C.ma_job_queue_post(p_queue &JobQueue, const_p_job &Job) Result

// job_queue_post is currently undocumented
pub fn job_queue_post(p_queue &JobQueue, const_p_job &Job) Result {
	return C.ma_job_queue_post(p_queue, const_p_job)
}

// C: `MA_API ma_result ma_job_queue_next(ma_job_queue* pQueue, ma_job* pJob); /* Returns MA_CANCELLED if the next job is a quit job. */`
fn C.ma_job_queue_next(p_queue &JobQueue, p_job &Job) Result

// job_queue_next returns MA_CANCELLED if the next job is a quit job.
pub fn job_queue_next(p_queue &JobQueue, p_job &Job) Result {
	return C.ma_job_queue_next(p_queue, p_job)
}

/*
TODO Non-numerical: #define MA_SUPPORT_CUSTOM
*/

/*
TODO Non-numerical: #define MA_SUPPORT_NULL
*/

// DeviceState is C.ma_device_state
pub enum DeviceState {
	uninitialized = C.ma_device_state_uninitialized // 0,
	stopped       = C.ma_device_state_stopped       // 1, The device's default state after initialization.
	started       = C.ma_device_state_started       // 2, The device is started and is requesting and/or delivering audio data.
	starting      = C.ma_device_state_starting      // 3, Transitioning from a stopped state to started.
	stopping      = C.ma_device_state_stopping      // 4, Transitioning from a started state to stopped.
}

/*
TODO
[typedef]
struct C.ma_IMMNotificationClient {
pub mut:
	lpVtbl voidptr
	counter u32
	pDevice &Device = unsafe { nil }
}
pub type IMMNotificationClient = C.ma_IMMNotificationClient
*/

// Backend is C.ma_backend
pub enum Backend {
	wasapi     = C.ma_backend_wasapi
	dsound     = C.ma_backend_dsound
	winmm      = C.ma_backend_winmm
	coreaudio  = C.ma_backend_coreaudio
	sndio      = C.ma_backend_sndio
	audio4     = C.ma_backend_audio4
	oss        = C.ma_backend_oss
	pulseaudio = C.ma_backend_pulseaudio
	alsa       = C.ma_backend_alsa
	jack       = C.ma_backend_jack
	aaudio     = C.ma_backend_aaudio
	opensl     = C.ma_backend_opensl
	webaudio   = C.ma_backend_webaudio
	custom     = C.ma_backend_custom // <-- Custom backend, with callbacks defined by the context config.
	null       = C.ma_backend_null   // <-- Must always be the last item. Lowest priority, and used as the terminator for backend enumeration.
}

/*
TODO Function: #define MA_BACKEND_COUNT (ma_backend_null+1)
*/

@[typedef]
struct C.ma_device_job_thread_config {
pub mut:
	noThread         u32 // Set this to true if you want to process jobs yourself.
	jobQueueCapacity u32
	jobQueueFlags    u32
}

pub type DeviceJobThreadConfig = C.ma_device_job_thread_config

// C: `MA_API ma_device_job_thread_config ma_device_job_thread_config_init(void)`
fn C.ma_device_job_thread_config_init() DeviceJobThreadConfig

// device_job_thread_config_init is currently undocumented
pub fn device_job_thread_config_init() DeviceJobThreadConfig {
	return C.ma_device_job_thread_config_init()
}

@[typedef]
struct C.ma_device_job_thread {
pub mut:
	thread     C.ma_thread
	jobQueue   JobQueue
	_hasThread u32
}

pub type DeviceJobThread = C.ma_device_job_thread

// C: `MA_API ma_result ma_device_job_thread_init(const ma_device_job_thread_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_device_job_thread* pJobThread)`
fn C.ma_device_job_thread_init(const_p_config &DeviceJobThreadConfig, const_p_allocation_callbacks &AllocationCallbacks, p_job_thread &DeviceJobThread) Result

// device_job_thread_init is currently undocumented
pub fn device_job_thread_init(const_p_config &DeviceJobThreadConfig, const_p_allocation_callbacks &AllocationCallbacks, p_job_thread &DeviceJobThread) Result {
	return C.ma_device_job_thread_init(const_p_config, const_p_allocation_callbacks, p_job_thread)
}

// C: `MA_API void ma_device_job_thread_uninit(ma_device_job_thread* pJobThread, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_device_job_thread_uninit(p_job_thread &DeviceJobThread, const_p_allocation_callbacks &AllocationCallbacks)

// device_job_thread_uninit is currently undocumented
pub fn device_job_thread_uninit(p_job_thread &DeviceJobThread, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_device_job_thread_uninit(p_job_thread, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_device_job_thread_post(ma_device_job_thread* pJobThread, const ma_job* pJob)`
fn C.ma_device_job_thread_post(p_job_thread &DeviceJobThread, const_p_job &Job) Result

// device_job_thread_post is currently undocumented
pub fn device_job_thread_post(p_job_thread &DeviceJobThread, const_p_job &Job) Result {
	return C.ma_device_job_thread_post(p_job_thread, const_p_job)
}

// C: `MA_API ma_result ma_device_job_thread_next(ma_device_job_thread* pJobThread, ma_job* pJob)`
fn C.ma_device_job_thread_next(p_job_thread &DeviceJobThread, p_job &Job) Result

// device_job_thread_next is currently undocumented
pub fn device_job_thread_next(p_job_thread &DeviceJobThread, p_job &Job) Result {
	return C.ma_device_job_thread_next(p_job_thread, p_job)
}

// DeviceNotificationType is C.ma_device_notification_type
pub enum DeviceNotificationType {
	started            = C.ma_device_notification_type_started
	stopped            = C.ma_device_notification_type_stopped
	rerouted           = C.ma_device_notification_type_rerouted
	interruption_began = C.ma_device_notification_type_interruption_began
	interruption_ended = C.ma_device_notification_type_interruption_ended
}

@[typedef]
struct C.ma_device_notification {
pub mut:
	pDevice &Device = unsafe { nil }
	@type   DeviceNotificationType
	// TODO// union {
	//  struct {
	//  int _unused; } started
	// TODO// struct {
	//  int _unused; } stopped
	// TODO// struct {
	//  int _unused; } rerouted
	// TODO// struct {
	//  int _unused; } interruption; } data
}

pub type DeviceNotification = C.ma_device_notification

// DeviceNotificationProc thes notification callback for when the application should be notified of a change to the device.
//
// This callback is used for notifying the application of changes such as when the device has started,
// stopped, rerouted or an interruption has occurred. Note that not all backends will post all
// notification types. For example, some backends will perform automatic stream routing without any
// kind of notification to the host program which means miniaudio will never know about it and will
// never be able to fire the rerouted notification. You should keep this in mind when designing your
// program.
//
// not* get fired when a device is rerouted.
//
//
// Parameters
//----------
// pNotification (in)
//    A pointer to a structure containing information about the event. Use the `pDevice` member of
//    this object to retrieve the relevant device. The `type` member can be used to discriminate
//    against each of the notification types.
//
//
// Remarks
//-------
// Do not restart or uninitialize the device from the callback.
//
// Not all notifications will be triggered by all backends, however the started and stopped events
// should be reliable for all backends. Some backends do not have a good way to detect device
// stoppages due to unplugging the device which may result in the stopped callback not getting
// fired. This has been observed with at least one BSD variant.
//
// after* the reroute has occurred. The stopped notification will
// not* get fired when a device is rerouted. The following backends are known to do automatic stream
// rerouting, but do not have a way to be notified of the change:
//
// DirectSound
//
// The interruption notifications are used on mobile platforms for detecting when audio is interrupted
// due to things like an incoming phone call. Currently this is only implemented on iOS. None of the
// Android backends will report this notification.
// C: typedef void (* ma_device_notification_proc)(const ma_device_notification* pNotification);
pub type DeviceNotificationProc = fn (const_p_notification &DeviceNotification)

// DeviceDataProc thes callback for processing audio data from the device.
//
// The data callback is fired by miniaudio whenever the device needs to have more data delivered to a playback device, or when a capture device has some data
// available. This is called as soon as the backend asks for more data which means it may be called with inconsistent frame counts. You cannot assume the
// callback will be fired with a consistent frame count.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the relevant device.
//
// pOutput (out)
//    A pointer to the output buffer that will receive audio data that will later be played back through the speakers. This will be non-null for a playback or
//    full-duplex device and null for a capture and loopback device.
//
// pInput (in)
//    A pointer to the buffer containing input data from a recording device. This will be non-null for a capture, full-duplex or loopback device and null for a
//    playback device.
//
// frameCount (in)
//    The number of PCM frames to process. Note that this will not necessarily be equal to what you requested when you initialized the device. The
//    `periodSizeInFrames` and `periodSizeInMilliseconds` members of the device config are just hints, and are not necessarily exactly what you'll get. You must
//    not assume this will always be the same value each time the callback is fired.
//
//
// Remarks
//-------
// You cannot stop and start the device from inside the callback or else you'll get a deadlock. You must also not uninitialize the device from inside the
// callback. The following APIs cannot be called from inside the callback:
//
//    ma_device_init()
//    ma_device_init_ex()
//    ma_device_uninit()
//    ma_device_start()
//    ma_device_stop()
//
// The proper way to stop the device is to call `ma_device_stop()` from a different thread, normally the main application thread.
// C: typedef void (* ma_device_data_proc)(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount);
pub type DeviceDataProc = fn (p_device &Device, p_output voidptr, const_p_input voidptr, frame_count u32)

// StopProc deprecated.s Use ma_device_notification_proc instead.
//
// The callback for when the device has been stopped.
//
// This will be called when the device is stopped explicitly with `ma_device_stop()` and also called implicitly when the device is stopped through external forces
// such as being unplugged or an internal error occuring.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device that has just stopped.
//
//
// Remarks
//-------
// Do not restart or uninitialize the device from the callback.
//
// DEPRECATED. Use ma_device_notification_proc instead.
// C: typedef void (* ma_stop_proc)(ma_device* pDevice);
pub type StopProc = fn (p_device &Device)

// DeviceType is C.ma_device_type
pub enum DeviceType {
	playback = C.ma_device_type_playback // 1,
	capture  = C.ma_device_type_capture  // 2,
	duplex   = C.ma_device_type_duplex   // ma_device_type_playback | ma_device_type_capture, 3
	loopback = C.ma_device_type_loopback // 4,
}

// ShareMode is C.ma_share_mode
pub enum ShareMode {
	@shared   = C.ma_share_mode_shared // 0,
	exclusive = C.ma_share_mode_exclusive
}

// IosSessionCategory is C.ma_ios_session_category
pub enum IosSessionCategory {
	default         = C.ma_ios_session_category_default         // 0, AVAudioSessionCategoryPlayAndRecord.
	@none           = C.ma_ios_session_category_none            // Leave the session category unchanged.
	ambient         = C.ma_ios_session_category_ambient         // AVAudioSessionCategoryAmbient
	solo_ambient    = C.ma_ios_session_category_solo_ambient    // AVAudioSessionCategorySoloAmbient
	playback        = C.ma_ios_session_category_playback        // AVAudioSessionCategoryPlayback
	record          = C.ma_ios_session_category_record          // AVAudioSessionCategoryRecord
	play_and_record = C.ma_ios_session_category_play_and_record // AVAudioSessionCategoryPlayAndRecord
	multi_route     = C.ma_ios_session_category_multi_route     // AVAudioSessionCategoryMultiRoute
}

// IosSessionCategoryOption is C.ma_ios_session_category_option
pub enum IosSessionCategoryOption {
	mix_with_others                            = C.ma_ios_session_category_option_mix_with_others                            // 0x01, AVAudioSessionCategoryOptionMixWithOthers
	duck_others                                = C.ma_ios_session_category_option_duck_others                                // 0x02, AVAudioSessionCategoryOptionDuckOthers
	allow_bluetooth                            = C.ma_ios_session_category_option_allow_bluetooth                            // 0x04, AVAudioSessionCategoryOptionAllowBluetooth
	default_to_speaker                         = C.ma_ios_session_category_option_default_to_speaker                         // 0x08, AVAudioSessionCategoryOptionDefaultToSpeaker
	interrupt_spoken_audio_and_mix_with_others = C.ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others // 0x11, AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers
	allow_bluetooth_a2dp                       = C.ma_ios_session_category_option_allow_bluetooth_a2dp                       // 0x20, AVAudioSessionCategoryOptionAllowBluetoothA2DP
	allow_air_play                             = C.ma_ios_session_category_option_allow_air_play // 0x40, AVAudioSessionCategoryOptionAllowAirPlay
}

// OpenslStreamType is C.ma_opensl_stream_type
pub enum OpenslStreamType {
	default      = C.ma_opensl_stream_type_default      // 0, Leaves the stream type unset.
	voice        = C.ma_opensl_stream_type_voice        // SL_ANDROID_STREAM_VOICE
	system       = C.ma_opensl_stream_type_system       // SL_ANDROID_STREAM_SYSTEM
	ring         = C.ma_opensl_stream_type_ring         // SL_ANDROID_STREAM_RING
	media        = C.ma_opensl_stream_type_media        // SL_ANDROID_STREAM_MEDIA
	alarm        = C.ma_opensl_stream_type_alarm        // SL_ANDROID_STREAM_ALARM
	notification = C.ma_opensl_stream_type_notification // SL_ANDROID_STREAM_NOTIFICATION
}

// OpenslRecordingPreset is C.ma_opensl_recording_preset
pub enum OpenslRecordingPreset {
	default             = C.ma_opensl_recording_preset_default             // 0, Leaves the input preset unset.
	generic             = C.ma_opensl_recording_preset_generic             // SL_ANDROID_RECORDING_PRESET_GENERIC
	camcorder           = C.ma_opensl_recording_preset_camcorder           // SL_ANDROID_RECORDING_PRESET_CAMCORDER
	voice_recognition   = C.ma_opensl_recording_preset_voice_recognition   // SL_ANDROID_RECORDING_PRESET_VOICE_RECOGNITION
	voice_communication = C.ma_opensl_recording_preset_voice_communication // SL_ANDROID_RECORDING_PRESET_VOICE_COMMUNICATION
	voice_unprocessed   = C.ma_opensl_recording_preset_voice_unprocessed   // SL_ANDROID_RECORDING_PRESET_UNPROCESSED
}

// WasapiUsage is C.ma_wasapi_usage
pub enum WasapiUsage {
	default   = C.ma_wasapi_usage_default // 0,
	games     = C.ma_wasapi_usage_games
	pro_audio = C.ma_wasapi_usage_pro_audio
}

// AaudioUsage is C.ma_aaudio_usage
pub enum AaudioUsage {
	default                        = C.ma_aaudio_usage_default                        // 0, Leaves the usage type unset.
	media                          = C.ma_aaudio_usage_media                          // AAUDIO_USAGE_MEDIA
	voice_communication            = C.ma_aaudio_usage_voice_communication            // AAUDIO_USAGE_VOICE_COMMUNICATION
	voice_communication_signalling = C.ma_aaudio_usage_voice_communication_signalling // AAUDIO_USAGE_VOICE_COMMUNICATION_SIGNALLING
	alarm                          = C.ma_aaudio_usage_alarm                          // AAUDIO_USAGE_ALARM
	notification                   = C.ma_aaudio_usage_notification                   // AAUDIO_USAGE_NOTIFICATION
	notification_ringtone          = C.ma_aaudio_usage_notification_ringtone          // AAUDIO_USAGE_NOTIFICATION_RINGTONE
	notification_event             = C.ma_aaudio_usage_notification_event             // AAUDIO_USAGE_NOTIFICATION_EVENT
	assistance_accessibility       = C.ma_aaudio_usage_assistance_accessibility       // AAUDIO_USAGE_ASSISTANCE_ACCESSIBILITY
	assistance_navigation_guidance = C.ma_aaudio_usage_assistance_navigation_guidance // AAUDIO_USAGE_ASSISTANCE_NAVIGATION_GUIDANCE
	assistance_sonification        = C.ma_aaudio_usage_assistance_sonification        // AAUDIO_USAGE_ASSISTANCE_SONIFICATION
	game                           = C.ma_aaudio_usage_game           // AAUDIO_USAGE_GAME
	assitant                       = C.ma_aaudio_usage_assitant       // AAUDIO_USAGE_ASSISTANT
	emergency                      = C.ma_aaudio_usage_emergency      // AAUDIO_SYSTEM_USAGE_EMERGENCY
	safety                         = C.ma_aaudio_usage_safety         // AAUDIO_SYSTEM_USAGE_SAFETY
	vehicle_status                 = C.ma_aaudio_usage_vehicle_status // AAUDIO_SYSTEM_USAGE_VEHICLE_STATUS
	announcement                   = C.ma_aaudio_usage_announcement   // AAUDIO_SYSTEM_USAGE_ANNOUNCEMENT
}

// AaudioContentType is C.ma_aaudio_content_type
pub enum AaudioContentType {
	default      = C.ma_aaudio_content_type_default      // 0, Leaves the content type unset.
	speech       = C.ma_aaudio_content_type_speech       // AAUDIO_CONTENT_TYPE_SPEECH
	music        = C.ma_aaudio_content_type_music        // AAUDIO_CONTENT_TYPE_MUSIC
	movie        = C.ma_aaudio_content_type_movie        // AAUDIO_CONTENT_TYPE_MOVIE
	sonification = C.ma_aaudio_content_type_sonification // AAUDIO_CONTENT_TYPE_SONIFICATION
}

// AaudioInputPreset is C.ma_aaudio_input_preset
pub enum AaudioInputPreset {
	default             = C.ma_aaudio_input_preset_default             // 0, Leaves the input preset unset.
	generic             = C.ma_aaudio_input_preset_generic             // AAUDIO_INPUT_PRESET_GENERIC
	camcorder           = C.ma_aaudio_input_preset_camcorder           // AAUDIO_INPUT_PRESET_CAMCORDER
	voice_recognition   = C.ma_aaudio_input_preset_voice_recognition   // AAUDIO_INPUT_PRESET_VOICE_RECOGNITION
	voice_communication = C.ma_aaudio_input_preset_voice_communication // AAUDIO_INPUT_PRESET_VOICE_COMMUNICATION
	unprocessed         = C.ma_aaudio_input_preset_unprocessed         // AAUDIO_INPUT_PRESET_UNPROCESSED
	voice_performance   = C.ma_aaudio_input_preset_voice_performance   // AAUDIO_INPUT_PRESET_VOICE_PERFORMANCE
}

@[typedef]
union C.ma_timer {
pub mut:
	counter  i64
	counterD f64
}

pub type Timer = C.ma_timer

@[typedef]
union C.ma_device_id {
pub mut:
	// TODO 	wasapi [64]u16 // WASAPI uses a wchar_t string for identification.
	// TODO 	dsound [16]u8 // DirectSound uses a GUID for identification.
	winmm u32 // When creating a device, WinMM expects a Win32 UINT_PTR for device identification. In practice it's actually just a UINT.
	// TODO 	alsa [256]char // ALSA uses a name string for identification.
	// TODO 	pulse [256]char // PulseAudio uses a name string for identification.
	jack int // JACK always uses default devices.
	// TODO 	coreaudio [256]char // Core Audio uses a string for identification.
	// TODO 	sndio [256]char // "snd/0", etc.
	// TODO 	audio4 [256]char // "/dev/audio", etc.
	// TODO 	oss [64]char // "dev/dsp0", etc. "dev/dsp" for the default device.
	aaudio int // AAudio uses a 32-bit integer for identification.
	opensl u32 // OpenSL|ES uses a 32-bit unsigned integer for identification.
	// TODO 	webaudio [32]char // Web Audio always uses default devices for now, but if this changes it'll be a GUID.
	// TODO// union {
	//  int i; char s[256]; void* p; } custom
	nullbackend int // The null backend uses an integer for device IDs.
}

pub type DeviceId = C.ma_device_id

/*
TODO Function: #define MA_DATA_FORMAT_FLAG_EXCLUSIVE_MODE (1U << 1)
*/

pub const max_device_name_length = 255

@[typedef]
struct C.ma_device_info {
pub mut:
	// Basic info. This is the only information guaranteed to be filled in during device enumeration.
	id DeviceId
	// TODO 	name [MA_MAX_DEVICE_NAME_LENGTHchar // + +1 for null terminator.
	isDefault             u32
	nativeDataFormatCount u32 // Sample format. If set to ma_format_unknown, all sample formats are supported.
	// TODO// struct {
	//  ma_format format; ma_uint32 channels; ma_uint32 sampleRate; ma_uint32 flags; /* A; combination of; MA_DATA_FORMAT_FLAG_* flags.*/; } nativeDataFormats[/*ma_format_count*; ma_standard_sample_rate_count* MA_MAX_CHANNELS*/
}

pub type DeviceInfo = C.ma_device_info

@[typedef]
struct C.ma_device_config {
pub mut:
	deviceType                DeviceType
	sampleRate                u32
	periodSizeInFrames        u32
	periodSizeInMilliseconds  u32
	periods                   u32
	performanceProfile        PerformanceProfile
	noPreSilencedOutputBuffer u8 // When set to true, the contents of the output buffer passed into the data callback will be left undefined rather than initialized to silence.
	noClip                    u8 // When set to true, the contents of the output buffer passed into the data callback will be clipped after returning. Only applies when the playback sample format is f32.
	noDisableDenormals        u8 // Do not disable denormals when firing the data callback.
	noFixedSizedCallback      u8 // Disables strict fixed-sized data callbacks. Setting this to true will result in the period size being treated only as a hint to the backend. This is an optimization for those who don't need fixed sized callbacks.
	dataCallback              DeviceDataProc
	notificationCallback      DeviceNotificationProc
	stopCallback              StopProc
	pUserData                 voidptr
	resampling                ResamplerConfig // When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present.
	// TODO// struct {
	//  const ma_device_id*; pDeviceID ma_format; format ma_uint32; channels ma_channel*; pChannelMap ma_channel_mix_mode; channelMixMode ma_bool32; calculateLFEFromSpatialChannels ma_share_mode; shareMode }; playback
	// TODO// struct {
	//  const ma_device_id*; pDeviceID ma_format; format ma_uint32; channels ma_channel*; pChannelMap ma_channel_mix_mode; channelMixMode ma_bool32; calculateLFEFromSpatialChannels ma_share_mode; shareMode }; capture
	// TODO// struct {
	//  ma_wasapi_usage usage; ma_bool8 noAutoConvertSRC; ma_bool8 noDefaultQualitySRC; ma_bool8 noAutoStreamRouting; ma_bool8 noHardwareOffloading; ma_uint32 loopbackProcessID; ma_bool8 loopbackProcessExclude; /* When; set to; true, excludes; the process; specified by; loopbackProcessID. By; default, the; process will; be included.*/; } wasapi
	// TODO// struct {
	//  ma_bool32 noMMap; ma_bool32 noAutoFormat; ma_bool32 noAutoChannels; ma_bool32 noAutoResample; /* Opens; the ALSA; device with; SND_PCM_NO_AUTO_RESAMPLE.*/ }; alsa
	// TODO// struct {
	//  const char*; pStreamNamePlayback const; char* pStreamNameCapture; } pulse
	// TODO// struct {
	//  ma_bool32 allowNominalSampleRateChange; /* Desktop; only. When; enabled, allows; changing of; the sample; rate at; the operating; system level.*/; } coreaudio
	// TODO// struct {
	//  ma_opensl_stream_type streamType; ma_opensl_recording_preset recordingPreset; } opensl
	// TODO// struct {
	//  ma_aaudio_usage usage; ma_aaudio_content_type contentType; ma_aaudio_input_preset inputPreset; ma_bool32 noAutoStartAfterReroute; } aaudio
	playback Playback // NOTE Added from chew config
	capture  Capture  // NOTE Added from chew config
}

pub type DeviceConfig = C.ma_device_config

// EnumDevicesCallbackProc thes callback for handling device enumeration. This is fired from `ma_context_enumerated_devices()`.
//
//
// Parameters
//----------
// pContext (in)
//    A pointer to the context performing the enumeration.
//
// deviceType (in)
//    The type of the device being enumerated. This will always be either `ma_device_type_playback` or `ma_device_type_capture`.
//
// pInfo (in)
//    A pointer to a `ma_device_info` containing the ID and name of the enumerated device. Note that this will not include detailed information about the device,
//    only basic information (ID and name). The reason for this is that it would otherwise require opening the backend device to probe for the information which
//    is too inefficient.
//
// pUserData (in)
//    The user data pointer passed into `ma_context_enumerate_devices()`.
// C: typedef ma_bool32 (* ma_enum_devices_callback_proc)(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pInfo, void* pUserData);
pub type EnumDevicesCallbackProc = fn (p_context &Context, device_type DeviceType, const_p_info &DeviceInfo, p_user_data voidptr) u32

@[typedef]
struct C.ma_device_descriptor {
pub mut:
	pDeviceID  &DeviceId = unsafe { nil }
	shareMode  ShareMode
	format     Format
	channels   u32
	sampleRate u32
	// TODO 	channelMap [MA_MAX_CHANNELS]u8
	periodSizeInFrames       u32
	periodSizeInMilliseconds u32
	periodCount              u32
}

pub type DeviceDescriptor = C.ma_device_descriptor

@[typedef]
struct C.ma_backend_callbacks {
pub mut:
	onContextInit             fn (p_context &Context, const_p_config &ContextConfig, p_callbacks &BackendCallbacks) Result // onContextInit)(ma_context*
	onContextUninit           fn (p_context &Context) Result // onContextUninit)(ma_context*
	onContextEnumerateDevices fn (p_context &Context, callback EnumDevicesCallbackProc, p_user_data voidptr) Result // onContextEnumerateDevices)(ma_context*
	onContextGetDeviceInfo    fn (p_context &Context, device_type DeviceType, const_p_device_id &DeviceId, p_device_info &DeviceInfo) Result // onContextGetDeviceInfo)(ma_context*
	onDeviceInit              fn (p_device &Device, const_p_config &DeviceConfig, p_descriptor_playback &DeviceDescriptor, p_descriptor_capture &DeviceDescriptor) Result // onDeviceInit)(ma_device*
	onDeviceUninit            fn (p_device &Device) Result // onDeviceUninit)(ma_device*
	onDeviceStart             fn (p_device &Device) Result // onDeviceStart)(ma_device*
	onDeviceStop              fn (p_device &Device) Result // onDeviceStop)(ma_device*
	onDeviceRead              fn (p_device &Device, p_frames voidptr, frame_count u32, p_frames_read &u32) Result          // onDeviceRead)(ma_device*
	onDeviceWrite             fn (p_device &Device, const_p_frames voidptr, frame_count u32, p_frames_written &u32) Result // onDeviceWrite)(ma_device*
	onDeviceDataLoop          fn (p_device &Device) Result // onDeviceDataLoop)(ma_device*
	onDeviceDataLoopWakeup    fn (p_device &Device) Result // onDeviceDataLoopWakeup)(ma_device*
	onDeviceGetInfo           fn (p_device &Device, @type DeviceType, p_device_info &DeviceInfo) Result // onDeviceGetInfo)(ma_device*
}

pub type BackendCallbacks = C.ma_backend_callbacks

@[typedef]
struct C.ma_context_config {
pub mut:
	pLog                &Log = unsafe { nil }
	threadPriority      ThreadPriority
	threadStackSize     usize
	pUserData           voidptr
	allocationCallbacks AllocationCallbacks
	// TODO// struct {
	//  ma_bool32 useVerboseDeviceEnumeration; } alsa
	// TODO// struct {
	//  const char*; pApplicationName const; char* pServerName; ma_bool32 tryAutoSpawn; /* Enables; autospawning of; the PulseAudio; daemon if; necessary.*/ }; pulse
	// TODO// struct {
	//  ma_ios_session_category sessionCategory; ma_uint32 sessionCategoryOptions; ma_bool32 noAudioSessionActivate; ma_bool32 noAudioSessionDeactivate; /* iOS; only. When; set to; true, does; not perform; an explicit; [[AVAudioSession sharedInstace]; setActive:false] on; uninitialization.*/ }; coreaudio
	// TODO// struct {
	//  const char*; pClientName ma_bool32; tryStartServer }; jack
	custom BackendCallbacks
}

pub type ContextConfig = C.ma_context_config

@[typedef]
struct C.ma_context_command__wasapi {
pub mut:
	code   int
	pEvent &Event = unsafe { nil } // This will be signalled when the event is complete.
	// TODO// union {
	//  struct {
	//  int _unused; } quit
	// TODO// struct {
	//  ma_device_type deviceType; void* pAudioClient; void** ppAudioClientService; ma_result* pResult; /* The; result from; creating the; audio client; service.*/ }; createAudioClient
	// TODO// struct {
	//  ma_device* pDevice; ma_device_type deviceType; } releaseAudioClient; } data
}

pub type ContextCommandWasapi = C.ma_context_command__wasapi

@[typedef]
struct C.ma_context {
pub mut:
	callbacks               BackendCallbacks
	backend                 Backend // DirectSound, ALSA, etc.
	pLog                    &Log = unsafe { nil }
	log                     Log // Only used if the log is owned by the context. The pLog member will be set to &log in this case.
	threadPriority          ThreadPriority
	threadStackSize         usize
	pUserData               voidptr
	allocationCallbacks     AllocationCallbacks
	deviceEnumLock          C.ma_mutex // Used to make ma_context_get_devices() thread safe.
	deviceInfoLock          C.ma_mutex // Used to make ma_context_get_device_info() thread safe.
	deviceInfoCapacity      u32        // Total capacity of pDeviceInfos.
	playbackDeviceInfoCount u32
	captureDeviceInfoCount  u32
	pDeviceInfos            &DeviceInfo = unsafe { nil } // Playback devices first, then capture.
	// TODO// union {
	//  }
	// TODO// union {
	//  int _unused; }
}

pub type Context = C.ma_context

@[typedef]
struct C.ma_device {
pub mut:
	pContext   &Context = unsafe { nil }
	@type      DeviceType
	sampleRate u32
	// TODO MA_ATOMIC(4, ma_device_state) state
	onData                    DeviceDataProc         // Set once at initialization time and should not be changed after.
	onNotification            DeviceNotificationProc // Set once at initialization time and should not be changed after.
	onStop                    StopProc               // DEPRECATED. Use the notification callback instead. Set once at initialization time and should not be changed after.
	pUserData                 voidptr                // Application defined data.
	startStopLock             C.ma_mutex
	wakeupEvent               Event
	startEvent                Event
	stopEvent                 Event
	thread                    C.ma_thread
	workResult                Result // This is set by the worker thread after it's finished doing a job.
	isOwnerOfContext          u8     // When set to true, uninitializing the device will also uninitialize the context. Set to true when NULL is passed into ma_device_init().
	noPreSilencedOutputBuffer u8
	noClip                    u8
	noDisableDenormals        u8
	noFixedSizedCallback      u8
	// TODO MA_ATOMIC(4, float) masterVolumeFactor
	duplexRB DuplexRb // Intermediary buffer for duplex device on asynchronous backends.
	// TODO// struct {
	//  ma_resample_algorithm algorithm; ma_resampling_backend_vtable* pBackendVTable; void* pBackendUserData; struct {
	//  ma_uint32 lpfOrder; } linear; } resampling
	// TODO// struct {
	//  ma_device_id* pID; ma_device_id id; char name[MA_MAX_DEVICE_NAME_LENGTH; + 1]; ma_share_mode shareMode; ma_format format; ma_uint32 channels; ma_channel channelMap[MA_MAX_CHANNELS]; ma_format internalFormat; ma_uint32 internalChannels; ma_uint32 internalSampleRate; ma_channel internalChannelMap[MA_MAX_CHANNELS]; ma_uint32 internalPeriodSizeInFrames; ma_uint32 internalPeriods; ma_channel_mix_mode channelMixMode; ma_bool32 calculateLFEFromSpatialChannels; ma_data_converter converter; void* pIntermediaryBuffer; ma_uint32 intermediaryBufferCap; ma_uint32 intermediaryBufferLen; void* pInputCache; ma_uint64 inputCacheCap; ma_uint64 inputCacheConsumed; ma_uint64 inputCacheRemaining; } playback
	// TODO// struct {
	//  ma_device_id* pID; ma_device_id id; char name[MA_MAX_DEVICE_NAME_LENGTH; + 1]; ma_share_mode shareMode; ma_format format; ma_uint32 channels; ma_channel channelMap[MA_MAX_CHANNELS]; ma_format internalFormat; ma_uint32 internalChannels; ma_uint32 internalSampleRate; ma_channel internalChannelMap[MA_MAX_CHANNELS]; ma_uint32 internalPeriodSizeInFrames; ma_uint32 internalPeriods; ma_channel_mix_mode channelMixMode; ma_bool32 calculateLFEFromSpatialChannels; ma_data_converter converter; void* pIntermediaryBuffer; ma_uint32 intermediaryBufferCap; ma_uint32 intermediaryBufferLen; /* How; many valid; frames are; sitting in; the intermediary; buffer.*/ }; capture
	// TODO// union {
	//  }
}

pub type Device = C.ma_device

// C: `MA_API ma_context_config ma_context_config_init(void)`
fn C.ma_context_config_init() ContextConfig

// context_config_init initializes a `ma_context_config` object.
//
//
// Return Value
//------------
// A `ma_context_config` initialized to defaults.
//
//
// Remarks
//-------
// You must always use this to initialize the default state of the `ma_context_config` object. Not using this will result in your program breaking when miniaudio
// is updated and new members are added to `ma_context_config`. It also sets logical defaults.
//
// You can override members of the returned object by changing it's members directly.
//
//
// See Also
//--------
// ma_context_init()
pub fn context_config_init() ContextConfig {
	return C.ma_context_config_init()
}

// C: `MA_API ma_result ma_context_init(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pConfig, ma_context* pContext)`
fn C.ma_context_init(const_backends voidptr, backend_count u32, const_p_config &ContextConfig, p_context &Context) Result

// context_init initializes a context.
//
// The context is used for selecting and initializing an appropriate backend and to represent the backend at a more global level than that of an individual
// device. There is one context to many devices, and a device is created from a context. A context is required to enumerate devices.
//
//
// Parameters
//----------
// backends (in, optional)
//    A list of backends to try initializing, in priority order. Can be NULL, in which case it uses default priority order.
//
// backendCount (in, optional)
//    The number of items in `backend`. Ignored if `backend` is NULL.
//
// pConfig (in, optional)
//    The context configuration.
//
// pContext (in)
//    A pointer to the context object being initialized.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. Do not call this function across multiple threads as some backends read and write to global state.
//
//
// Remarks
//-------
// When `backends` is NULL, the default priority order will be used. Below is a list of backends in priority order:
//
//    |-------------|-----------------------|--------------------------------------------------------|
//    | Name        | Enum Name             | Supported Operating Systems                            |
//    |-------------|-----------------------|--------------------------------------------------------|
//    | WASAPI      | ma_backend_wasapi     | Windows Vista+                                         |
//    | DirectSound | ma_backend_dsound     | Windows XP+                                            |
//    | WinMM       | ma_backend_winmm      | Windows XP+ (may work on older versions, but untested) |
//    | Core Audio  | ma_backend_coreaudio  | macOS, iOS                                             |
//    | ALSA        | ma_backend_alsa       | Linux                                                  |
//    | PulseAudio  | ma_backend_pulseaudio | Cross Platform (disabled on Windows, BSD and Android)  |
//    | JACK        | ma_backend_jack       | Cross Platform (disabled on BSD and Android)           |
//    | sndio       | ma_backend_sndio      | OpenBSD                                                |
//    | audio(4)    | ma_backend_audio4     | NetBSD, OpenBSD                                        |
//    | OSS         | ma_backend_oss        | FreeBSD                                                |
//    | AAudio      | ma_backend_aaudio     | Android 8+                                             |
//    | OpenSL|ES   | ma_backend_opensl     | Android (API level 16+)                                |
//    | Web Audio   | ma_backend_webaudio   | Web (via Emscripten)                                   |
//    | Null        | ma_backend_null       | Cross Platform (not used on Web)                       |
//    |-------------|-----------------------|--------------------------------------------------------|
//
// The context can be configured via the `pConfig` argument. The config object is initialized with `ma_context_config_init()`. Individual configuration settings
// can then be set directly on the structure. Below are the members of the `ma_context_config` object.
//
//    pLog
//        A pointer to the `ma_log` to post log messages to. Can be NULL if the application does not
//        require logging. See the `ma_log` API for details on how to use the logging system.
//
//    threadPriority
//        The desired priority to use for the audio thread. Allowable values include the following:
//
//        |--------------------------------------|
//        | Thread Priority                      |
//        |--------------------------------------|
//        | ma_thread_priority_idle              |
//        | ma_thread_priority_lowest            |
//        | ma_thread_priority_low               |
//        | ma_thread_priority_normal            |
//        | ma_thread_priority_high              |
//        | ma_thread_priority_highest (default) |
//        | ma_thread_priority_realtime          |
//        | ma_thread_priority_default           |
//        |--------------------------------------|
//
//    threadStackSize
//        The desired size of the stack for the audio thread. Defaults to the operating system's default.
//
//    pUserData
//        A pointer to application-defined data. This can be accessed from the context object directly such as `context.pUserData`.
//
//    allocationCallbacks
//        Structure containing custom allocation callbacks. Leaving this at defaults will cause it to use MA_MALLOC, MA_REALLOC and MA_FREE. These allocation
//        callbacks will be used for anything tied to the context, including devices.
//
//    alsa.useVerboseDeviceEnumeration
//        ALSA will typically enumerate many different devices which can be intrusive and not user-friendly. To combat this, miniaudio will enumerate only unique
//        card/device pairs by default. The problem with this is that you lose a bit of flexibility and control. Setting alsa.useVerboseDeviceEnumeration makes
//        it so the ALSA backend includes all devices. Defaults to false.
//
//    pulse.pApplicationName
//        PulseAudio only. The application name to use when initializing the PulseAudio context with `pa_context_new()`.
//
//    pulse.pServerName
//        PulseAudio only. The name of the server to connect to with `pa_context_connect()`.
//
//    pulse.tryAutoSpawn
//        PulseAudio only. Whether or not to try automatically starting the PulseAudio daemon. Defaults to false. If you set this to true, keep in mind that
//        miniaudio uses a trial and error method to find the most appropriate backend, and this will result in the PulseAudio daemon starting which may be
//        intrusive for the end user.
//
//    coreaudio.sessionCategory
//        iOS only. The session category to use for the shared AudioSession instance. Below is a list of allowable values and their Core Audio equivalents.
//
//        |-----------------------------------------|-------------------------------------|
//        | miniaudio Token                         | Core Audio Token                    |
//        |-----------------------------------------|-------------------------------------|
//        | ma_ios_session_category_ambient         | AVAudioSessionCategoryAmbient       |
//        | ma_ios_session_category_solo_ambient    | AVAudioSessionCategorySoloAmbient   |
//        | ma_ios_session_category_playback        | AVAudioSessionCategoryPlayback      |
//        | ma_ios_session_category_record          | AVAudioSessionCategoryRecord        |
//        | ma_ios_session_category_play_and_record | AVAudioSessionCategoryPlayAndRecord |
//        | ma_ios_session_category_multi_route     | AVAudioSessionCategoryMultiRoute    |
//        | ma_ios_session_category_none            | AVAudioSessionCategoryAmbient       |
//        | ma_ios_session_category_default         | AVAudioSessionCategoryAmbient       |
//        |-----------------------------------------|-------------------------------------|
//
//    coreaudio.sessionCategoryOptions
//        iOS only. Session category options to use with the shared AudioSession instance. Below is a list of allowable values and their Core Audio equivalents.
//
//        |---------------------------------------------------------------------------|------------------------------------------------------------------|
//        | miniaudio Token                                                           | Core Audio Token                                                 |
//        |---------------------------------------------------------------------------|------------------------------------------------------------------|
//        | ma_ios_session_category_option_mix_with_others                            | AVAudioSessionCategoryOptionMixWithOthers                        |
//        | ma_ios_session_category_option_duck_others                                | AVAudioSessionCategoryOptionDuckOthers                           |
//        | ma_ios_session_category_option_allow_bluetooth                            | AVAudioSessionCategoryOptionAllowBluetooth                       |
//        | ma_ios_session_category_option_default_to_speaker                         | AVAudioSessionCategoryOptionDefaultToSpeaker                     |
//        | ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others | AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers |
//        | ma_ios_session_category_option_allow_bluetooth_a2dp                       | AVAudioSessionCategoryOptionAllowBluetoothA2DP                   |
//        | ma_ios_session_category_option_allow_air_play                             | AVAudioSessionCategoryOptionAllowAirPlay                         |
//        |---------------------------------------------------------------------------|------------------------------------------------------------------|
//
//    coreaudio.noAudioSessionActivate
//        iOS only. When set to true, does not perform an explicit [[AVAudioSession sharedInstace] setActive:true] on initialization.
//
//    coreaudio.noAudioSessionDeactivate
//        iOS only. When set to true, does not perform an explicit [[AVAudioSession sharedInstace] setActive:false] on uninitialization.
//
//    jack.pClientName
//        The name of the client to pass to `jack_client_open()`.
//
//    jack.tryStartServer
//        Whether or not to try auto-starting the JACK server. Defaults to false.
//
//
// It is recommended that only a single context is active at any given time because it's a bulky data structure which performs run-time linking for the
// relevant backends every time it's initialized.
//
// The location of the context cannot change throughout it's lifetime. Consider allocating the `ma_context` object with `malloc()` if this is an issue. The
// reason for this is that a pointer to the context is stored in the `ma_device` structure.
//
//
// Example 1 - Default Initialization
//----------------------------------
// The example below shows how to initialize the context using the default configuration.
//
//```c
// ma_context context;
// ma_result result = ma_context_init(NULL, 0, NULL, &context);
// if (result != MA_SUCCESS) {
//    // Error.
//}
//```
//
//
// Example 2 - Custom Configuration
//--------------------------------
// The example below shows how to initialize the context using custom backend priorities and a custom configuration. In this hypothetical example, the program
// wants to prioritize ALSA over PulseAudio on Linux. They also want to avoid using the WinMM backend on Windows because it's latency is too high. They also
// want an error to be returned if no valid backend is available which they achieve by excluding the Null backend.
//
// For the configuration, the program wants to capture any log messages so they can, for example, route it to a log file and user interface.
//
//```c
// ma_backend backends[] = {
//    ma_backend_alsa,
//    ma_backend_pulseaudio,
//    ma_backend_wasapi,
//    ma_backend_dsound
//};
//
// ma_log log;
// ma_log_init(&log);
// ma_log_register_callback(&log, ma_log_callback_init(my_log_callbac, pMyLogUserData));
//
// ma_context_config config = ma_context_config_init();
// config.pLog = &log; // Specify a custom log object in the config so any logs that are posted from ma_context_init() are captured.
//
// ma_context context;
// ma_result result = ma_context_init(backends, sizeof(backends)/sizeof(backends[0]), &config, &context);
// if (result != MA_SUCCESS) {
//    // Error.
//    if (result == MA_NO_BACKEND) {
//        // Couldn't find an appropriate backend.
//    }
//}
//
//// You could also attach a log callback post-initialization:
// ma_log_register_callback(ma_context_get_log(&context), ma_log_callback_init(my_log_callback, pMyLogUserData));
//```
//
//
// See Also
//--------
// ma_context_config_init()
// ma_context_uninit()
pub fn context_init(const_backends []Backend, backend_count u32, const_p_config &ContextConfig, p_context &Context) Result {
	return C.ma_context_init(const_backends.data, backend_count, const_p_config, p_context)
}

// C: `MA_API ma_result ma_context_uninit(ma_context* pContext)`
fn C.ma_context_uninit(p_context &Context) Result

// context_uninit uninitializes a context.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. Do not call this function across multiple threads as some backends read and write to global state.
//
//
// Remarks
//-------
// Results are undefined if you call this while any device created by this context is still active.
//
//
// See Also
//--------
// ma_context_init()
pub fn context_uninit(p_context &Context) Result {
	return C.ma_context_uninit(p_context)
}

// C: `MA_API size_t ma_context_sizeof(void)`
fn C.ma_context_sizeof() usize

// context_sizeof retrieves the size of the ma_context object.
//
// This is mainly for the purpose of bindings to know how much memory to allocate.
pub fn context_sizeof() usize {
	return C.ma_context_sizeof()
}

// C: `MA_API ma_log* ma_context_get_log(ma_context* pContext)`
fn C.ma_context_get_log(p_context &Context) &Log

// context_get_log retrieves a pointer to the log object associated with this context.
//
//
// Remarks
//-------
// Pass the returned pointer to `ma_log_post()`, `ma_log_postv()` or `ma_log_postf()` to post a log
// message.
//
// You can attach your own logging callback to the log with `ma_log_register_callback()`
//
//
// Return Value
//------------
// A pointer to the `ma_log` object that the context uses to post log messages. If some error occurs,
// NULL will be returned.
pub fn context_get_log(p_context &Context) &Log {
	return C.ma_context_get_log(p_context)
}

// C: `MA_API ma_result ma_context_enumerate_devices(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)`
fn C.ma_context_enumerate_devices(p_context &Context, callback EnumDevicesCallbackProc, p_user_data voidptr) Result

// context_enumerate_devices enumerates over every device (both playback and capture).
//
// This is a lower-level enumeration function to the easier to use `ma_context_get_devices()`. Use `ma_context_enumerate_devices()` if you would rather not incur
// an internal heap allocation, or it simply suits your code better.
//
// Note that this only retrieves the ID and name/description of the device. The reason for only retrieving basic information is that it would otherwise require
// opening the backend device in order to probe it for more detailed information which can be inefficient. Consider using `ma_context_get_device_info()` for this,
// but don't call it from within the enumeration callback.
//
// Returning false from the callback will stop enumeration. Returning true will continue enumeration.
//
//
// Parameters
//----------
// pContext (in)
//    A pointer to the context performing the enumeration.
//
// callback (in)
//    The callback to fire for each enumerated device.
//
// pUserData (in)
//    A pointer to application-defined data passed to the callback.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Safe. This is guarded using a simple mutex lock.
//
//
// Remarks
//-------
// Do _not_ assume the first enumerated device of a given type is the default device.
//
// Some backends and platforms may only support default playback and capture devices.
//
// In general, you should not do anything complicated from within the callback. In particular, do not try initializing a device from within the callback. Also,
// do not try to call `ma_context_get_device_info()` from within the callback.
//
// Consider using `ma_context_get_devices()` for a simpler and safer API, albeit at the expense of an internal heap allocation.
//
//
// Example 1 - Simple Enumeration
//------------------------------
// pContext, ma_device_type deviceType, const ma_device_info* pInfo, void* pUserData)
//{
//    printf("Device Name: %s\n", pInfo->name);
//    return MA_TRUE;
//}
//
// ma_result result = ma_context_enumerate_devices(&context, my_device_enum_callback, pMyUserData);
// if (result != MA_SUCCESS) {
//    // Error.
//}
//
//
// See Also
//--------
// ma_context_get_devices()
pub fn context_enumerate_devices(p_context &Context, callback EnumDevicesCallbackProc, p_user_data voidptr) Result {
	return C.ma_context_enumerate_devices(p_context, callback, p_user_data)
}

// C: `MA_API ma_result ma_context_get_devices(ma_context* pContext, ma_device_info** ppPlaybackDeviceInfos, ma_uint32* pPlaybackDeviceCount, ma_device_info** ppCaptureDeviceInfos, ma_uint32* pCaptureDeviceCount)`
fn C.ma_context_get_devices(p_context &Context, pp_playback_device_infos &&DeviceInfo, p_playback_device_count &u32, pp_capture_device_infos &&DeviceInfo, p_capture_device_count &u32) Result

// context_get_devices retrieves basic information about every active playback and/or capture device.
//
// This function will allocate memory internally for the device lists and return a pointer to them through the `ppPlaybackDeviceInfos` and `ppCaptureDeviceInfos`
// parameters. If you do not want to incur the overhead of these allocations consider using `ma_context_enumerate_devices()` which will instead use a callback.
//
//
// Parameters
//----------
// pContext (in)
//    A pointer to the context performing the enumeration.
//
// ppPlaybackDeviceInfos (out)
//    A pointer to a pointer that will receive the address of a buffer containing the list of `ma_device_info` structures for playback devices.
//
// pPlaybackDeviceCount (out)
//    A pointer to an unsigned integer that will receive the number of playback devices.
//
// ppCaptureDeviceInfos (out)
//    A pointer to a pointer that will receive the address of a buffer containing the list of `ma_device_info` structures for capture devices.
//
// pCaptureDeviceCount (out)
//    A pointer to an unsigned integer that will receive the number of capture devices.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. Since each call to this function invalidates the pointers from the previous call, you should not be calling this simultaneously across multiple
// threads. Instead, you need to make a copy of the returned data with your own higher level synchronization.
//
//
// Remarks
//-------
// It is _not_ safe to assume the first device in the list is the default device.
//
// You can pass in NULL for the playback or capture lists in which case they'll be ignored.
//
// The returned pointers will become invalid upon the next call this this function, or when the context is uninitialized. Do not free the returned pointers.
//
//
// See Also
//--------
// ma_context_get_devices()
pub fn context_get_devices(p_context &Context, pp_playback_device_infos &&DeviceInfo, p_playback_device_count &u32, pp_capture_device_infos &&DeviceInfo, p_capture_device_count &u32) Result {
	return C.ma_context_get_devices(p_context, pp_playback_device_infos, p_playback_device_count,
		pp_capture_device_infos, p_capture_device_count)
}

// C: `MA_API ma_result ma_context_get_device_info(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_device_info* pDeviceInfo)`
fn C.ma_context_get_device_info(p_context &Context, device_type DeviceType, const_p_device_id &DeviceId, p_device_info &DeviceInfo) Result

// context_get_device_info retrieves information about a device of the given type, with the specified ID and share mode.
//
//
// Parameters
//----------
// pContext (in)
//    A pointer to the context performing the query.
//
// deviceType (in)
//    The type of the device being queried. Must be either `ma_device_type_playback` or `ma_device_type_capture`.
//
// pDeviceID (in)
//    The ID of the device being queried.
//
// pDeviceInfo (out)
//    A pointer to the `ma_device_info` structure that will receive the device information.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Safe. This is guarded using a simple mutex lock.
//
//
// Remarks
//-------
// Do _not_ call this from within the `ma_context_enumerate_devices()` callback.
//
// It's possible for a device to have different information and capabilities depending on whether or not it's opened in shared or exclusive mode. For example, in
// shared mode, WASAPI always uses floating point samples for mixing, but in exclusive mode it can be anything. Therefore, this function allows you to specify
// which share mode you want information for. Note that not all backends and devices support shared or exclusive mode, in which case this function will fail if
// the requested share mode is unsupported.
//
// This leaves pDeviceInfo unmodified in the result of an error.
pub fn context_get_device_info(p_context &Context, device_type DeviceType, const_p_device_id &DeviceId, p_device_info &DeviceInfo) Result {
	return C.ma_context_get_device_info(p_context, device_type, const_p_device_id, p_device_info)
}

// C: `MA_API ma_bool32 ma_context_is_loopback_supported(ma_context* pContext)`
fn C.ma_context_is_loopback_supported(p_context &Context) u32

// context_is_loopback_supported determines if the given context supports loopback mode.
//
//
// Parameters
//----------
// pContext (in)
//    A pointer to the context getting queried.
//
//
// Return Value
//------------
// MA_TRUE if the context supports loopback mode; MA_FALSE otherwise.
pub fn context_is_loopback_supported(p_context &Context) u32 {
	return C.ma_context_is_loopback_supported(p_context)
}

// C: `MA_API ma_device_config ma_device_config_init(ma_device_type deviceType)`
fn C.ma_device_config_init(device_type DeviceType) DeviceConfig

// device_config_init initializes a device config with default settings.
//
//
// Parameters
//----------
// deviceType (in)
//    The type of the device this config is being initialized for. This must set to one of the following:
//
//    |-------------------------|
//    | Device Type             |
//    |-------------------------|
//    | ma_device_type_playback |
//    | ma_device_type_capture  |
//    | ma_device_type_duplex   |
//    | ma_device_type_loopback |
//    |-------------------------|
//
//
// Return Value
//------------
// A new device config object with default settings. You will typically want to adjust the config after this function returns. See remarks.
//
//
// Thread Safety
//-------------
// Safe.
//
//
// Callback Safety
//---------------
// Safe, but don't try initializing a device in a callback.
//
//
// Remarks
//-------
// The returned config will be initialized to defaults. You will normally want to customize a few variables before initializing the device. See Example 1 for a
// typical configuration which sets the sample format, channel count, sample rate, data callback and user data. These are usually things you will want to change
// before initializing the device.
//
// See `ma_device_init()` for details on specific configuration options.
//
//
// Example 1 - Simple Configuration
//--------------------------------
// The example below is what a program will typically want to configure for each device at a minimum. Notice how `ma_device_config_init()` is called first, and
// then the returned object is modified directly. This is important because it ensures that your program continues to work as new configuration options are added
// to the `ma_device_config` structure.
//
//```c
// ma_device_config config = ma_device_config_init(ma_device_type_playback);
// config.playback.format   = ma_format_f32;
// config.playback.channels = 2;
// config.sampleRate        = 48000;
// config.dataCallback      = ma_data_callback;
// config.pUserData         = pMyUserData;
//```
//
//
// See Also
//--------
// ma_device_init()
// ma_device_init_ex()
pub fn device_config_init(device_type DeviceType) DeviceConfig {
	return C.ma_device_config_init(device_type)
}

// C: `MA_API ma_result ma_device_init(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)`
fn C.ma_device_init(p_context &Context, const_p_config &DeviceConfig, p_device &Device) Result

// device_init initializes a device.
//
// A device represents a physical audio device. The idea is you send or receive audio data from the device to either play it back through a speaker, or capture it
// from a microphone. Whether or not you should send or receive data from the device (or both) depends on the type of device you are initializing which can be
// playback, capture, full-duplex or loopback. (Note that loopback mode is only supported on select backends.) Sending and receiving audio data to and from the
// device is done via a callback which is fired by miniaudio at periodic time intervals.
//
// The frequency at which data is delivered to and from a device depends on the size of it's period. The size of the period can be defined in terms of PCM frames
// or milliseconds, whichever is more convenient. Generally speaking, the smaller the period, the lower the latency at the expense of higher CPU usage and
// increased risk of glitching due to the more frequent and granular data deliver intervals. The size of a period will depend on your requirements, but
// miniaudio's defaults should work fine for most scenarios. If you're building a game you should leave this fairly small, whereas if you're building a simple
// media player you can make it larger. Note that the period size you request is actually just a hint - miniaudio will tell the backend what you want, but the
// backend is ultimately responsible for what it gives you. You cannot assume you will get exactly what you ask for.
//
// When delivering data to and from a device you need to make sure it's in the correct format which you can set through the device configuration. You just set the
// format that you want to use and miniaudio will perform all of the necessary conversion for you internally. When delivering data to and from the callback you
// can assume the format is the same as what you requested when you initialized the device. See Remarks for more details on miniaudio's data conversion pipeline.
//
//
// Parameters
//----------
// pContext (in, optional)
//    A pointer to the context that owns the device. This can be null, in which case it creates a default context internally.
//
// pConfig (in)
//    A pointer to the device configuration. Cannot be null. See remarks for details.
//
// pDevice (out)
//    A pointer to the device object being initialized.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. It is not safe to call this function simultaneously for different devices because some backends depend on and mutate global state. The same applies to
// calling this at the same time as `ma_device_uninit()`.
//
//
// Callback Safety
//---------------
// Unsafe. It is not safe to call this inside any callback.
//
//
// Remarks
//-------
// Setting `pContext` to NULL will result in miniaudio creating a default context internally and is equivalent to passing in a context initialized like so:
//
//    ```c
//    ma_context_init(NULL, 0, NULL, &context);
//    ```
//
// Do not set `pContext` to NULL if you are needing to open multiple devices. You can, however, use NULL when initializing the first device, and then use
// device.pContext for the initialization of other devices.
//
// The device can be configured via the `pConfig` argument. The config object is initialized with `ma_device_config_init()`. Individual configuration settings can
// then be set directly on the structure. Below are the members of the `ma_device_config` object.
//
//    deviceType
//        Must be `ma_device_type_playback`, `ma_device_type_capture`, `ma_device_type_duplex` of `ma_device_type_loopback`.
//
//    sampleRate
//        The sample rate, in hertz. The most common sample rates are 48000 and 44100. Setting this to 0 will use the device's native sample rate.
//
//    periodSizeInFrames
//        The desired size of a period in PCM frames. If this is 0, `periodSizeInMilliseconds` will be used instead. If both are 0 the default buffer size will
//        be used depending on the selected performance profile. This value affects latency. See below for details.
//
//    periodSizeInMilliseconds
//        The desired size of a period in milliseconds. If this is 0, `periodSizeInFrames` will be used instead. If both are 0 the default buffer size will be
//        used depending on the selected performance profile. The value affects latency. See below for details.
//
//    periods
//        The number of periods making up the device's entire buffer. The total buffer size is `periodSizeInFrames` or `periodSizeInMilliseconds` multiplied by
//        this value. This is just a hint as backends will be the ones who ultimately decide how your periods will be configured.
//
//    performanceProfile
//        A hint to miniaudio as to the performance requirements of your program. Can be either `ma_performance_profile_low_latency` (default) or
//        `ma_performance_profile_conservative`. This mainly affects the size of default buffers and can usually be left at it's default value.
//
//    noPreSilencedOutputBuffer
//        When set to true, the contents of the output buffer passed into the data callback will be left undefined. When set to false (default), the contents of
//        the output buffer will be cleared the zero. You can use this to avoid the overhead of zeroing out the buffer if you can guarantee that your data
//        callback will write to every sample in the output buffer, or if you are doing your own clearing.
//
//    noClip
//        When set to true, the contents of the output buffer passed into the data callback will be clipped after returning. When set to false (default), the
//        contents of the output buffer are left alone after returning and it will be left up to the backend itself to decide whether or not the clip. This only
//        applies when the playback sample format is f32.
//
//    noDisableDenormals
//        By default, miniaudio will disable denormals when the data callback is called. Setting this to true will prevent the disabling of denormals.
//
//    noFixedSizedCallback
//        Allows miniaudio to fire the data callback with any frame count. When this is set to false (the default), the data callback will be fired with a
//        consistent frame count as specified by `periodSizeInFrames` or `periodSizeInMilliseconds`. When set to true, miniaudio will fire the callback with
//        whatever the backend requests, which could be anything.
//
//    dataCallback
//        The callback to fire whenever data is ready to be delivered to or from the device.
//
//    notificationCallback
//        The callback to fire when something has changed with the device, such as whether or not it has been started or stopped.
//
//    pUserData
//        The user data pointer to use with the device. You can access this directly from the device object like `device.pUserData`.
//
//    resampling.algorithm
//        The resampling algorithm to use when miniaudio needs to perform resampling between the rate specified by `sampleRate` and the device's native rate. The
//        default value is `ma_resample_algorithm_linear`, and the quality can be configured with `resampling.linear.lpfOrder`.
//
//    resampling.pBackendVTable
//        A pointer to an optional vtable that can be used for plugging in a custom resampler.
//
//    resampling.pBackendUserData
//        A pointer that will passed to callbacks in pBackendVTable.
//
//    resampling.linear.lpfOrder
//        The linear resampler applies a low-pass filter as part of it's procesing for anti-aliasing. This setting controls the order of the filter. The higher
//        the value, the better the quality, in general. Setting this to 0 will disable low-pass filtering altogether. The maximum value is
//        `MA_MAX_FILTER_ORDER`. The default value is `min(4, MA_MAX_FILTER_ORDER)`.
//
//    playback.pDeviceID
//        A pointer to a `ma_device_id` structure containing the ID of the playback device to initialize. Setting this NULL (default) will use the system's
//        default playback device. Retrieve the device ID from the `ma_device_info` structure, which can be retrieved using device enumeration.
//
//    playback.format
//        The sample format to use for playback. When set to `ma_format_unknown` the device's native format will be used. This can be retrieved after
//        initialization from the device object directly with `device.playback.format`.
//
//    playback.channels
//        The number of channels to use for playback. When set to 0 the device's native channel count will be used. This can be retrieved after initialization
//        from the device object directly with `device.playback.channels`.
//
//    playback.pChannelMap
//        The channel map to use for playback. When left empty, the device's native channel map will be used. This can be retrieved after initialization from the
//        device object direct with `device.playback.pChannelMap`. When set, the buffer should contain `channels` items.
//
//    playback.shareMode
//        The preferred share mode to use for playback. Can be either `ma_share_mode_shared` (default) or `ma_share_mode_exclusive`. Note that if you specify
//        exclusive mode, but it's not supported by the backend, initialization will fail. You can then fall back to shared mode if desired by changing this to
//        ma_share_mode_shared and reinitializing.
//
//    capture.pDeviceID
//        A pointer to a `ma_device_id` structure containing the ID of the capture device to initialize. Setting this NULL (default) will use the system's
//        default capture device. Retrieve the device ID from the `ma_device_info` structure, which can be retrieved using device enumeration.
//
//    capture.format
//        The sample format to use for capture. When set to `ma_format_unknown` the device's native format will be used. This can be retrieved after
//        initialization from the device object directly with `device.capture.format`.
//
//    capture.channels
//        The number of channels to use for capture. When set to 0 the device's native channel count will be used. This can be retrieved after initialization
//        from the device object directly with `device.capture.channels`.
//
//    capture.pChannelMap
//        The channel map to use for capture. When left empty, the device's native channel map will be used. This can be retrieved after initialization from the
//        device object direct with `device.capture.pChannelMap`. When set, the buffer should contain `channels` items.
//
//    capture.shareMode
//        The preferred share mode to use for capture. Can be either `ma_share_mode_shared` (default) or `ma_share_mode_exclusive`. Note that if you specify
//        exclusive mode, but it's not supported by the backend, initialization will fail. You can then fall back to shared mode if desired by changing this to
//        ma_share_mode_shared and reinitializing.
//
//    wasapi.noAutoConvertSRC
//        WASAPI only. When set to true, disables WASAPI's automatic resampling and forces the use of miniaudio's resampler. Defaults to false.
//
//    wasapi.noDefaultQualitySRC
//        WASAPI only. Only used when `wasapi.noAutoConvertSRC` is set to false. When set to true, disables the use of `AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY`.
//        You should usually leave this set to false, which is the default.
//
//    wasapi.noAutoStreamRouting
//        WASAPI only. When set to true, disables automatic stream routing on the WASAPI backend. Defaults to false.
//
//    wasapi.noHardwareOffloading
//        WASAPI only. When set to true, disables the use of WASAPI's hardware offloading feature. Defaults to false.
//
//    alsa.noMMap
//        ALSA only. When set to true, disables MMap mode. Defaults to false.
//
//    alsa.noAutoFormat
//        ALSA only. When set to true, disables ALSA's automatic format conversion by including the SND_PCM_NO_AUTO_FORMAT flag. Defaults to false.
//
//    alsa.noAutoChannels
//        ALSA only. When set to true, disables ALSA's automatic channel conversion by including the SND_PCM_NO_AUTO_CHANNELS flag. Defaults to false.
//
//    alsa.noAutoResample
//        ALSA only. When set to true, disables ALSA's automatic resampling by including the SND_PCM_NO_AUTO_RESAMPLE flag. Defaults to false.
//
//    pulse.pStreamNamePlayback
//        PulseAudio only. Sets the stream name for playback.
//
//    pulse.pStreamNameCapture
//        PulseAudio only. Sets the stream name for capture.
//
//    coreaudio.allowNominalSampleRateChange
//        Core Audio only. Desktop only. When enabled, allows the sample rate of the device to be changed at the operating system level. This
//        is disabled by default in order to prevent intrusive changes to the user's system. This is useful if you want to use a sample rate
//        that is known to be natively supported by the hardware thereby avoiding the cost of resampling. When set to true, miniaudio will
//        find the closest match between the sample rate requested in the device config and the sample rates natively supported by the
//        hardware. When set to false, the sample rate currently set by the operating system will always be used.
//
//    opensl.streamType
//        OpenSL only. Explicitly sets the stream type. If left unset (`ma_opensl_stream_type_default`), the
//        stream type will be left unset. Think of this as the type of audio you're playing.
//
//    opensl.recordingPreset
//        OpenSL only. Explicitly sets the type of recording your program will be doing. When left
//        unset, the recording preset will be left unchanged.
//
//    aaudio.usage
//        AAudio only. Explicitly sets the nature of the audio the program will be consuming. When
//        left unset, the usage will be left unchanged.
//
//    aaudio.contentType
//        AAudio only. Sets the content type. When left unset, the content type will be left unchanged.
//
//    aaudio.inputPreset
//        AAudio only. Explicitly sets the type of recording your program will be doing. When left
//        unset, the input preset will be left unchanged.
//
//    aaudio.noAutoStartAfterReroute
//        AAudio only. Controls whether or not the device should be automatically restarted after a
//        stream reroute. When set to false (default) the device will be restarted automatically;
//        otherwise the device will be stopped.
//
//
// Once initialized, the device's config is immutable. If you need to change the config you will need to initialize a new device.
//
// After initializing the device it will be in a stopped state. To start it, use `ma_device_start()`.
//
// If both `periodSizeInFrames` and `periodSizeInMilliseconds` are set to zero, it will default to `MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY` or
//`MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE`, depending on whether or not `performanceProfile` is set to `ma_performance_profile_low_latency` or
//`ma_performance_profile_conservative`.
//
// If you request exclusive mode and the backend does not support it an error will be returned. For robustness, you may want to first try initializing the device
// in exclusive mode, and then fall back to shared mode if required. Alternatively you can just request shared mode (the default if you leave it unset in the
// config) which is the most reliable option. Some backends do not have a practical way of choosing whether or not the device should be exclusive or not (ALSA,
// for example) in which case it just acts as a hint. Unless you have special requirements you should try avoiding exclusive mode as it's intrusive to the user.
// Starting with Windows 10, miniaudio will use low-latency shared mode where possible which may make exclusive mode unnecessary.
//
// When sending or receiving data to/from a device, miniaudio will internally perform a format conversion to convert between the format specified by the config
// and the format used internally by the backend. If you pass in 0 for the sample format, channel count, sample rate _and_ channel map, data transmission will run
// on an optimized pass-through fast path. You can retrieve the format, channel count and sample rate by inspecting the `playback/capture.format`,
//`playback/capture.channels` and `sampleRate` members of the device object.
//
// When compiling for UWP you must ensure you call this function on the main UI thread because the operating system may need to present the user with a message
// asking for permissions. Please refer to the official documentation for ActivateAudioInterfaceAsync() for more information.
//
// ALSA Specific: When initializing the default device, requesting shared mode will try using the "dmix" device for playback and the "dsnoop" device for capture.
// If these fail it will try falling back to the "hw" device.
//
//
// Example 1 - Simple Initialization
//---------------------------------
// This example shows how to initialize a simple playback device using a standard configuration. If you are just needing to do simple playback from the default
// playback device this is usually all you need.
//
//```c
// ma_device_config config = ma_device_config_init(ma_device_type_playback);
// config.playback.format   = ma_format_f32;
// config.playback.channels = 2;
// config.sampleRate        = 48000;
// config.dataCallback      = ma_data_callback;
// config.pMyUserData       = pMyUserData;
//
// ma_device device;
// ma_result result = ma_device_init(NULL, &config, &device);
// if (result != MA_SUCCESS) {
//    // Error
//}
//```
//
//
// Example 2 - Advanced Initialization
//-----------------------------------
// This example shows how you might do some more advanced initialization. In this hypothetical example we want to control the latency by setting the buffer size
// and period count. We also want to allow the user to be able to choose which device to output from which means we need a context so we can perform device
// enumeration.
//
//```c
// ma_context context;
// ma_result result = ma_context_init(NULL, 0, NULL, &context);
// if (result != MA_SUCCESS) {
//    // Error
//}
//
// pPlaybackDeviceInfos;
// ma_uint32 playbackDeviceCount;
// result = ma_context_get_devices(&context, &pPlaybackDeviceInfos, &playbackDeviceCount, NULL, NULL);
// if (result != MA_SUCCESS) {
//    // Error
//}
//
//// ... choose a device from pPlaybackDeviceInfos ...
//
// ma_device_config config = ma_device_config_init(ma_device_type_playback);
// config.playback.pDeviceID       = pMyChosenDeviceID;    // <-- Get this from the `id` member of one of the `ma_device_info` objects returned by ma_context_get_devices().
// config.playback.format          = ma_format_f32;
// config.playback.channels        = 2;
// config.sampleRate               = 48000;
// config.dataCallback             = ma_data_callback;
// config.pUserData                = pMyUserData;
// config.periodSizeInMilliseconds = 10;
// config.periods                  = 3;
//
// ma_device device;
// result = ma_device_init(&context, &config, &device);
// if (result != MA_SUCCESS) {
//    // Error
//}
//```
//
//
// See Also
//--------
// ma_device_config_init()
// ma_device_uninit()
// ma_device_start()
// ma_context_init()
// ma_context_get_devices()
// ma_context_enumerate_devices()
pub fn device_init(p_context &Context, const_p_config &DeviceConfig, p_device &Device) Result {
	return C.ma_device_init(p_context, const_p_config, p_device)
}

// C: `MA_API ma_result ma_device_init_ex(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pContextConfig, const ma_device_config* pConfig, ma_device* pDevice)`
fn C.ma_device_init_ex(const_backends voidptr, backend_count u32, const_p_context_config &ContextConfig, const_p_config &DeviceConfig, p_device &Device) Result

// device_init_ex initializes a device without a context, with extra parameters for controlling the configuration of the internal self-managed context.
//
// This is the same as `ma_device_init()`, only instead of a context being passed in, the parameters from `ma_context_init()` are passed in instead. This function
// allows you to configure the internally created context.
//
//
// Parameters
//----------
// backends (in, optional)
//    A list of backends to try initializing, in priority order. Can be NULL, in which case it uses default priority order.
//
// backendCount (in, optional)
//    The number of items in `backend`. Ignored if `backend` is NULL.
//
// pContextConfig (in, optional)
//    The context configuration.
//
// pConfig (in)
//    A pointer to the device configuration. Cannot be null. See remarks for details.
//
// pDevice (out)
//    A pointer to the device object being initialized.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. It is not safe to call this function simultaneously for different devices because some backends depend on and mutate global state. The same applies to
// calling this at the same time as `ma_device_uninit()`.
//
//
// Callback Safety
//---------------
// Unsafe. It is not safe to call this inside any callback.
//
//
// Remarks
//-------
// You only need to use this function if you want to configure the context differently to it's defaults. You should never use this function if you want to manage
// your own context.
//
// See the documentation for `ma_context_init()` for information on the different context configuration options.
//
//
// See Also
//--------
// ma_device_init()
// ma_device_uninit()
// ma_device_config_init()
// ma_context_init()
pub fn device_init_ex(const_backends []Backend, backend_count u32, const_p_context_config &ContextConfig, const_p_config &DeviceConfig, p_device &Device) Result {
	return C.ma_device_init_ex(const_backends.data, backend_count, const_p_context_config,
		const_p_config, p_device)
}

// C: `MA_API void ma_device_uninit(ma_device* pDevice)`
fn C.ma_device_uninit(p_device &Device)

// device_uninit uninitializes a device.
//
// This will explicitly stop the device. You do not need to call `ma_device_stop()` beforehand, but it's harmless if you do.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device to stop.
//
//
// Return Value
//------------
// Nothing
//
//
// Thread Safety
//-------------
// Unsafe. As soon as this API is called the device should be considered undefined.
//
//
// Callback Safety
//---------------
// Unsafe. It is not safe to call this inside any callback. Doing this will result in a deadlock.
//
//
// See Also
//--------
// ma_device_init()
// ma_device_stop()
pub fn device_uninit(p_device &Device) {
	C.ma_device_uninit(p_device)
}

// C: `MA_API ma_context* ma_device_get_context(ma_device* pDevice)`
fn C.ma_device_get_context(p_device &Device) &Context

// device_get_context retrieves a pointer to the context that owns the given device.
pub fn device_get_context(p_device &Device) &Context {
	return C.ma_device_get_context(p_device)
}

// C: `MA_API ma_log* ma_device_get_log(ma_device* pDevice)`
fn C.ma_device_get_log(p_device &Device) &Log

// device_get_log helpers function for retrieving the log object associated with the context that owns this device.
pub fn device_get_log(p_device &Device) &Log {
	return C.ma_device_get_log(p_device)
}

// C: `MA_API ma_result ma_device_get_info(ma_device* pDevice, ma_device_type type, ma_device_info* pDeviceInfo)`
fn C.ma_device_get_info(p_device &Device, @type DeviceType, p_device_info &DeviceInfo) Result

// device_get_info retrieves information about the device.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose information is being retrieved.
//
// type (in)
//    The device type. This parameter is required for duplex devices. When retrieving device
//    information, you are doing so for an individual playback or capture device.
//
// pDeviceInfo (out)
//    A pointer to the `ma_device_info` that will receive the device information.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. This should be considered unsafe because it may be calling into the backend which may or
// may not be safe.
//
//
// Callback Safety
//---------------
// Unsafe. You should avoid calling this in the data callback because it may call into the backend
// which may or may not be safe.
pub fn device_get_info(p_device &Device, @type DeviceType, p_device_info &DeviceInfo) Result {
	return C.ma_device_get_info(p_device, @type, p_device_info)
}

// C: `MA_API ma_result ma_device_get_name(ma_device* pDevice, ma_device_type type, char* pName, size_t nameCap, size_t* pLengthNotIncludingNullTerminator)`
fn C.ma_device_get_name(p_device &Device, @type DeviceType, p_name &char, name_cap usize, p_length_not_including_null_terminator &usize) Result

// device_get_name retrieves the name of the device.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose information is being retrieved.
//
// type (in)
//    The device type. This parameter is required for duplex devices. When retrieving device
//    information, you are doing so for an individual playback or capture device.
//
// pName (out)
//    A pointer to the buffer that will receive the name.
//
// nameCap (in)
//    The capacity of the output buffer, including space for the null terminator.
//
// pLengthNotIncludingNullTerminator (out, optional)
//    A pointer to the variable that will receive the length of the name, not including the null
//    terminator.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. This should be considered unsafe because it may be calling into the backend which may or
// may not be safe.
//
//
// Callback Safety
//---------------
// Unsafe. You should avoid calling this in the data callback because it may call into the backend
// which may or may not be safe.
//
//
// Remarks
//-------
// If the name does not fully fit into the output buffer, it'll be truncated. You can pass in NULL to
//`pName` if you want to first get the length of the name for the purpose of memory allocation of the
// output buffer. Allocating a buffer of size `MA_MAX_DEVICE_NAME_LENGTH + 1` should be enough for
// most cases and will avoid the need for the inefficiency of calling this function twice.
//
// This is implemented in terms of `ma_device_get_info()`.
pub fn device_get_name(p_device &Device, @type DeviceType, p_name &char, name_cap usize, p_length_not_including_null_terminator &usize) Result {
	return C.ma_device_get_name(p_device, @type, p_name, name_cap, p_length_not_including_null_terminator)
}

// C: `MA_API ma_result ma_device_start(ma_device* pDevice)`
fn C.ma_device_start(p_device &Device) Result

// device_start starts the device. For playback devices this begins playback. For capture devices it begins recording.
//
// Use `ma_device_stop()` to stop the device.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device to start.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Safe. It's safe to call this from any thread with the exception of the callback thread.
//
//
// Callback Safety
//---------------
// Unsafe. It is not safe to call this inside any callback.
//
//
// Remarks
//-------
// For a playback device, this will retrieve an initial chunk of audio data from the client before returning. The reason for this is to ensure there is valid
// audio data in the buffer, which needs to be done before the device begins playback.
//
// This API waits until the backend device has been started for real by the worker thread. It also waits on a mutex for thread-safety.
//
// Do not call this in any callback.
//
//
// See Also
//--------
// ma_device_stop()
pub fn device_start(p_device &Device) Result {
	return C.ma_device_start(p_device)
}

// C: `MA_API ma_result ma_device_stop(ma_device* pDevice)`
fn C.ma_device_stop(p_device &Device) Result

// device_stop stops the device. For playback devices this stops playback. For capture devices it stops recording.
//
// Use `ma_device_start()` to start the device again.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device to stop.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error code otherwise.
//
//
// Thread Safety
//-------------
// Safe. It's safe to call this from any thread with the exception of the callback thread.
//
//
// Callback Safety
//---------------
// Unsafe. It is not safe to call this inside any callback. Doing this will result in a deadlock.
//
//
// Remarks
//-------
// This API needs to wait on the worker thread to stop the backend device properly before returning. It also waits on a mutex for thread-safety. In addition, some
// backends need to wait for the device to finish playback/recording of the current fragment which can take some time (usually proportionate to the buffer size
// that was specified at initialization time).
//
// Backends are required to either pause the stream in-place or drain the buffer if pausing is not possible. The reason for this is that stopping the device and
// the resuming it with ma_device_start() (which you might do when your program loses focus) may result in a situation where those samples are never output to the
// speakers or received from the microphone which can in turn result in de-syncs.
//
// Do not call this in any callback.
//
// This will be called implicitly by `ma_device_uninit()`.
//
//
// See Also
//--------
// ma_device_start()
pub fn device_stop(p_device &Device) Result {
	return C.ma_device_stop(p_device)
}

// C: `MA_API ma_bool32 ma_device_is_started(const ma_device* pDevice)`
fn C.ma_device_is_started(const_p_device &Device) u32

// device_is_started determines whether or not the device is started.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose start state is being retrieved.
//
//
// Return Value
//------------
// True if the device is started, false otherwise.
//
//
// Thread Safety
//-------------
// Safe. If another thread calls `ma_device_start()` or `ma_device_stop()` at this same time as this function is called, there's a very small chance the return
// value will be out of sync.
//
//
// Callback Safety
//---------------
// Safe. This is implemented as a simple accessor.
//
//
// See Also
//--------
// ma_device_start()
// ma_device_stop()
pub fn device_is_started(const_p_device &Device) u32 {
	return C.ma_device_is_started(const_p_device)
}

// C: `MA_API ma_device_state ma_device_get_state(const ma_device* pDevice)`
fn C.ma_device_get_state(const_p_device &Device) DeviceState

// device_get_state retrieves the state of the device.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose state is being retrieved.
//
//
// Return Value
//------------
// The current state of the device. The return value will be one of the following:
//
//    +-------------------------------+------------------------------------------------------------------------------+
//    | ma_device_state_uninitialized | Will only be returned if the device is in the middle of initialization.      |
//    +-------------------------------+------------------------------------------------------------------------------+
//    | ma_device_state_stopped       | The device is stopped. The initial state of the device after initialization. |
//    +-------------------------------+------------------------------------------------------------------------------+
//    | ma_device_state_started       | The device started and requesting and/or delivering audio data.              |
//    +-------------------------------+------------------------------------------------------------------------------+
//    | ma_device_state_starting      | The device is in the process of starting.                                    |
//    +-------------------------------+------------------------------------------------------------------------------+
//    | ma_device_state_stopping      | The device is in the process of stopping.                                    |
//    +-------------------------------+------------------------------------------------------------------------------+
//
//
// Thread Safety
//-------------
// Safe. This is implemented as a simple accessor. Note that if the device is started or stopped at the same time as this function is called,
// there's a possibility the return value could be out of sync. See remarks.
//
//
// Callback Safety
//---------------
// Safe. This is implemented as a simple accessor.
//
//
// Remarks
//-------
// The general flow of a devices state goes like this:
//
//    ```
//    ma_device_init()  -> ma_device_state_uninitialized -> ma_device_state_stopped
//    ma_device_start() -> ma_device_state_starting      -> ma_device_state_started
//    ma_device_stop()  -> ma_device_state_stopping      -> ma_device_state_stopped
//    ```
//
// When the state of the device is changed with `ma_device_start()` or `ma_device_stop()` at this same time as this function is called, the
// value returned by this function could potentially be out of sync. If this is significant to your program you need to implement your own
// synchronization.
pub fn device_get_state(const_p_device &Device) DeviceState {
	return C.ma_device_get_state(const_p_device)
}

// C: `MA_API ma_result ma_device_post_init(ma_device* pDevice, ma_device_type deviceType, const ma_device_descriptor* pPlaybackDescriptor, const ma_device_descriptor* pCaptureDescriptor)`
fn C.ma_device_post_init(p_device &Device, device_type DeviceType, const_p_playback_descriptor &DeviceDescriptor, const_p_capture_descriptor &DeviceDescriptor) Result

// device_post_init performs post backend initialization routines for setting up internal data conversion.
//
// This should be called whenever the backend is initialized. The only time this should be called from
// outside of miniaudio is if you're implementing a custom backend, and you would only do it if you
// are reinitializing the backend due to rerouting or reinitializing for some reason.
//
//
// Parameters
//----------
// pDevice [in]
//    A pointer to the device.
//
// deviceType [in]
//    The type of the device that was just reinitialized.
//
// pPlaybackDescriptor [in]
//    The descriptor of the playback device containing the internal data format and buffer sizes.
//
// pPlaybackDescriptor [in]
//    The descriptor of the capture device containing the internal data format and buffer sizes.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other error otherwise.
//
//
// Thread Safety
//-------------
// Unsafe. This will be reinitializing internal data converters which may be in use by another thread.
//
//
// Callback Safety
//---------------
// Unsafe. This will be reinitializing internal data converters which may be in use by the callback.
//
//
// Remarks
//-------
// For a duplex device, you can call this for only one side of the system. This is why the deviceType
// is specified as a parameter rather than deriving it from the device.
//
// You do not need to call this manually unless you are doing a custom backend, in which case you need
// only do it if you're manually performing rerouting or reinitialization.
pub fn device_post_init(p_device &Device, device_type DeviceType, const_p_playback_descriptor &DeviceDescriptor, const_p_capture_descriptor &DeviceDescriptor) Result {
	return C.ma_device_post_init(p_device, device_type, const_p_playback_descriptor, const_p_capture_descriptor)
}

// C: `MA_API ma_result ma_device_set_master_volume(ma_device* pDevice, float volume)`
fn C.ma_device_set_master_volume(p_device &Device, volume f32) Result

// device_set_master_volume sets the master volume factor for the device.
//
// The volume factor must be between 0 (silence) and 1 (full volume). Use `ma_device_set_master_volume_db()` to use decibel notation, where 0 is full volume and
// values less than 0 decreases the volume.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose volume is being set.
//
// volume (in)
//    The new volume factor. Must be >= 0.
//
//
// Return Value
//------------
// MA_SUCCESS if the volume was set successfully.
// MA_INVALID_ARGS if pDevice is NULL.
// MA_INVALID_ARGS if volume is negative.
//
//
// Thread Safety
//-------------
// Safe. This just sets a local member of the device object.
//
//
// Callback Safety
//---------------
// Safe. If you set the volume in the data callback, that data written to the output buffer will have the new volume applied.
//
//
// Remarks
//-------
// This applies the volume factor across all channels.
//
// This does not change the operating system's volume. It only affects the volume for the given `ma_device` object's audio stream.
//
//
// See Also
//--------
// ma_device_get_master_volume()
// ma_device_set_master_volume_db()
// ma_device_get_master_volume_db()
pub fn device_set_master_volume(p_device &Device, volume f32) Result {
	return C.ma_device_set_master_volume(p_device, volume)
}

// C: `MA_API ma_result ma_device_get_master_volume(ma_device* pDevice, float* pVolume)`
fn C.ma_device_get_master_volume(p_device &Device, p_volume &f32) Result

// device_get_master_volume retrieves the master volume factor for the device.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose volume factor is being retrieved.
//
// pVolume (in)
//    A pointer to the variable that will receive the volume factor. The returned value will be in the range of [0, 1].
//
//
// Return Value
//------------
// MA_SUCCESS if successful.
// MA_INVALID_ARGS if pDevice is NULL.
// MA_INVALID_ARGS if pVolume is NULL.
//
//
// Thread Safety
//-------------
// Safe. This just a simple member retrieval.
//
//
// Callback Safety
//---------------
// Safe.
//
//
// Remarks
//-------
// pVolume` will be set to 0.
//
//
// See Also
//--------
// ma_device_set_master_volume()
// ma_device_set_master_volume_gain_db()
// ma_device_get_master_volume_gain_db()
pub fn device_get_master_volume(p_device &Device, p_volume &f32) Result {
	return C.ma_device_get_master_volume(p_device, p_volume)
}

// C: `MA_API ma_result ma_device_set_master_volume_db(ma_device* pDevice, float gainDB)`
fn C.ma_device_set_master_volume_db(p_device &Device, gain_db f32) Result

// device_set_master_volume_db sets the master volume for the device as gain in decibels.
//
// A gain of 0 is full volume, whereas a gain of < 0 will decrease the volume.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose gain is being set.
//
// gainDB (in)
//    The new volume as gain in decibels. Must be less than or equal to 0, where 0 is full volume and anything less than 0 decreases the volume.
//
//
// Return Value
//------------
// MA_SUCCESS if the volume was set successfully.
// MA_INVALID_ARGS if pDevice is NULL.
// MA_INVALID_ARGS if the gain is > 0.
//
//
// Thread Safety
//-------------
// Safe. This just sets a local member of the device object.
//
//
// Callback Safety
//---------------
// Safe. If you set the volume in the data callback, that data written to the output buffer will have the new volume applied.
//
//
// Remarks
//-------
// This applies the gain across all channels.
//
// This does not change the operating system's volume. It only affects the volume for the given `ma_device` object's audio stream.
//
//
// See Also
//--------
// ma_device_get_master_volume_gain_db()
// ma_device_set_master_volume()
// ma_device_get_master_volume()
pub fn device_set_master_volume_db(p_device &Device, gain_db f32) Result {
	return C.ma_device_set_master_volume_db(p_device, gain_db)
}

// C: `MA_API ma_result ma_device_get_master_volume_db(ma_device* pDevice, float* pGainDB)`
fn C.ma_device_get_master_volume_db(p_device &Device, p_gain_db &f32) Result

// device_get_master_volume_db retrieves the master gain in decibels.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to the device whose gain is being retrieved.
//
// pGainDB (in)
//    A pointer to the variable that will receive the gain in decibels. The returned value will be <= 0.
//
//
// Return Value
//------------
// MA_SUCCESS if successful.
// MA_INVALID_ARGS if pDevice is NULL.
// MA_INVALID_ARGS if pGainDB is NULL.
//
//
// Thread Safety
//-------------
// Safe. This just a simple member retrieval.
//
//
// Callback Safety
//---------------
// Safe.
//
//
// Remarks
//-------
// pGainDB` will be set to 0.
//
//
// See Also
//--------
// ma_device_set_master_volume_db()
// ma_device_set_master_volume()
// ma_device_get_master_volume()
pub fn device_get_master_volume_db(p_device &Device, p_gain_db &f32) Result {
	return C.ma_device_get_master_volume_db(p_device, p_gain_db)
}

// C: `MA_API ma_result ma_device_handle_backend_data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)`
fn C.ma_device_handle_backend_data_callback(p_device &Device, p_output voidptr, const_p_input voidptr, frame_count u32) Result

// device_handle_backend_data_callback calleds from the data callback of asynchronous backends to allow miniaudio to process the data and fire the miniaudio data callback.
//
//
// Parameters
//----------
// pDevice (in)
//    A pointer to device whose processing the data callback.
//
// pOutput (out)
//    A pointer to the buffer that will receive the output PCM frame data. On a playback device this must not be NULL. On a duplex device
//    this can be NULL, in which case pInput must not be NULL.
//
// pInput (in)
//    A pointer to the buffer containing input PCM frame data. On a capture device this must not be NULL. On a duplex device this can be
//    NULL, in which case `pOutput` must not be NULL.
//
// frameCount (in)
//    The number of frames being processed.
//
//
// Return Value
//------------
// MA_SUCCESS if successful; any other result code otherwise.
//
//
// Thread Safety
//-------------
// This function should only ever be called from the internal data callback of the backend. It is safe to call this simultaneously between a
// playback and capture device in duplex setups.
//
//
// Callback Safety
//---------------
// Do not call this from the miniaudio data callback. It should only ever be called from the internal data callback of the backend.
//
//
// Remarks
//-------
// If both `pOutput` and `pInput` are NULL, and error will be returned. In duplex scenarios, both `pOutput` and `pInput` can be non-NULL, in
// which case `pInput` will be processed first, followed by `pOutput`.
//
// If you are implementing a custom backend, and that backend uses a callback for data delivery, you'll need to call this from inside that
// callback.
pub fn device_handle_backend_data_callback(p_device &Device, p_output voidptr, const_p_input voidptr, frame_count u32) Result {
	return C.ma_device_handle_backend_data_callback(p_device, p_output, const_p_input,
		frame_count)
}

// C: `MA_API ma_uint32 ma_calculate_buffer_size_in_frames_from_descriptor(const ma_device_descriptor* pDescriptor, ma_uint32 nativeSampleRate, ma_performance_profile performanceProfile)`
fn C.ma_calculate_buffer_size_in_frames_from_descriptor(const_p_descriptor &DeviceDescriptor, native_sample_rate u32, performance_profile PerformanceProfile) u32

// calculate_buffer_size_in_frames_from_descriptor calculates an appropriate buffer size from a descriptor, native sample rate and performance profile.
//
// This function is used by backends for helping determine an appropriately sized buffer to use with
// the device depending on the values of `periodSizeInFrames` and `periodSizeInMilliseconds` in the
//`pDescriptor` object. Since buffer size calculations based on time depends on the sample rate, a
// best guess at the device's native sample rate is also required which is where `nativeSampleRate`
// comes in. In addition, the performance profile is also needed for cases where both the period size
// in frames and milliseconds are both zero.
//
//
// Parameters
//----------
// pDescriptor (in)
//    A pointer to device descriptor whose `periodSizeInFrames` and `periodSizeInMilliseconds` members
//    will be used for the calculation of the buffer size.
//
// nativeSampleRate (in)
//    The device's native sample rate. This is only ever used when the `periodSizeInFrames` member of
//    `pDescriptor` is zero. In this case, `periodSizeInMilliseconds` will be used instead, in which
//    case a sample rate is required to convert to a size in frames.
//
// performanceProfile (in)
//    When both the `periodSizeInFrames` and `periodSizeInMilliseconds` members of `pDescriptor` are
//    zero, miniaudio will fall back to a buffer size based on the performance profile. The profile
//    to use for this calculation is determine by this parameter.
//
//
// Return Value
//------------
// The calculated buffer size in frames.
//
//
// Thread Safety
//-------------
// This is safe so long as nothing modifies `pDescriptor` at the same time. However, this function
// should only ever be called from within the backend's device initialization routine and therefore
// shouldn't have any multithreading concerns.
//
//
// Callback Safety
//---------------
// This is safe to call within the data callback, but there is no reason to ever do this.
//
//
// Remarks
//-------
// If `nativeSampleRate` is zero, this function will fall back to `pDescriptor->sampleRate`. If that
// is also zero, `MA_DEFAULT_SAMPLE_RATE` will be used instead.
pub fn calculate_buffer_size_in_frames_from_descriptor(const_p_descriptor &DeviceDescriptor, native_sample_rate u32, performance_profile PerformanceProfile) u32 {
	return C.ma_calculate_buffer_size_in_frames_from_descriptor(const_p_descriptor, native_sample_rate,
		performance_profile)
}

// C: `MA_API const char* ma_get_backend_name(ma_backend backend)`
fn C.ma_get_backend_name(backend Backend) &char

// get_backend_name retrieves a friendly name for a backend.
pub fn get_backend_name(backend Backend) &char {
	return C.ma_get_backend_name(backend)
}

// C: `MA_API ma_bool32 ma_is_backend_enabled(ma_backend backend)`
fn C.ma_is_backend_enabled(backend Backend) u32

// is_backend_enabled determines whether or not the given backend is available by the compilation environment.
pub fn is_backend_enabled(backend Backend) u32 {
	return C.ma_is_backend_enabled(backend)
}

// C: `MA_API ma_result ma_get_enabled_backends(ma_backend* pBackends, size_t backendCap, size_t* pBackendCount)`
fn C.ma_get_enabled_backends(p_backends &Backend, backend_cap usize, p_backend_count &usize) Result

// get_enabled_backends retrieves compile-time enabled backends.
//
//
// Parameters
//----------
// pBackends (out, optional)
//    A pointer to the buffer that will receive the enabled backends. Set to NULL to retrieve the backend count. Setting
//    the capacity of the buffer to `MA_BUFFER_COUNT` will guarantee it's large enough for all backends.
//
// backendCap (in)
//    The capacity of the `pBackends` buffer.
//
// pBackendCount (out)
//    A pointer to the variable that will receive the enabled backend count.
//
//
// Return Value
//------------
// MA_SUCCESS if successful.
// MA_INVALID_ARGS if `pBackendCount` is NULL.
// MA_NO_SPACE if the capacity of `pBackends` is not large enough.
//
// pBackendCount` values.
//
//
// Thread Safety
//-------------
// Safe.
//
//
// Callback Safety
//---------------
// Safe.
//
//
// Remarks
//-------
// If you want to retrieve the number of backends so you can determine the capacity of `pBackends` buffer, you can call
// this function with `pBackends` set to NULL.
//
// This will also enumerate the null backend. If you don't want to include this you need to check for `ma_backend_null`
// when you enumerate over the returned backends and handle it appropriately. Alternatively, you can disable it at
// compile time with `MA_NO_NULL`.
//
// The returned backends are determined based on compile time settings, not the platform it's currently running on. For
// example, PulseAudio will be returned if it was enabled at compile time, even when the user doesn't actually have
// PulseAudio installed.
//
//
// Example 1
//---------
// The example below retrieves the enabled backend count using a fixed sized buffer allocated on the stack. The buffer is
// given a capacity of `MA_BACKEND_COUNT` which will guarantee it'll be large enough to store all available backends.
// Since `MA_BACKEND_COUNT` is always a relatively small value, this should be suitable for most scenarios.
//
//```
// ma_backend enabledBackends[MA_BACKEND_COUNT];
// size_t enabledBackendCount;
//
// result = ma_get_enabled_backends(enabledBackends, MA_BACKEND_COUNT, &enabledBackendCount);
// if (result != MA_SUCCESS) {
//    // Failed to retrieve enabled backends. Should never happen in this example since all inputs are valid.
//}
//```
//
//
// See Also
//--------
// ma_is_backend_enabled()
pub fn get_enabled_backends(p_backends &Backend, backend_cap usize, p_backend_count &usize) Result {
	return C.ma_get_enabled_backends(&p_backends, backend_cap, p_backend_count)
}

// C: `MA_API ma_bool32 ma_is_loopback_supported(ma_backend backend)`
fn C.ma_is_loopback_supported(backend Backend) u32

// is_loopback_supported determines whether or not loopback mode is support by a backend.
pub fn is_loopback_supported(backend Backend) u32 {
	return C.ma_is_loopback_supported(backend)
}

// C: `MA_API ma_uint32 ma_calculate_buffer_size_in_milliseconds_from_frames(ma_uint32 bufferSizeInFrames, ma_uint32 sampleRate)`
fn C.ma_calculate_buffer_size_in_milliseconds_from_frames(buffer_size_in_frames u32, sample_rate u32) u32

// calculate_buffer_size_in_milliseconds_from_frames calculates a buffer size in milliseconds from the specified number of frames and sample rate.
pub fn calculate_buffer_size_in_milliseconds_from_frames(buffer_size_in_frames u32, sample_rate u32) u32 {
	return C.ma_calculate_buffer_size_in_milliseconds_from_frames(buffer_size_in_frames,
		sample_rate)
}

// C: `MA_API ma_uint32 ma_calculate_buffer_size_in_frames_from_milliseconds(ma_uint32 bufferSizeInMilliseconds, ma_uint32 sampleRate)`
fn C.ma_calculate_buffer_size_in_frames_from_milliseconds(buffer_size_in_milliseconds u32, sample_rate u32) u32

// calculate_buffer_size_in_frames_from_milliseconds calculates a buffer size in frames from the specified number of milliseconds and sample rate.
pub fn calculate_buffer_size_in_frames_from_milliseconds(buffer_size_in_milliseconds u32, sample_rate u32) u32 {
	return C.ma_calculate_buffer_size_in_frames_from_milliseconds(buffer_size_in_milliseconds,
		sample_rate)
}

// C: `MA_API void ma_copy_pcm_frames(void* dst, const void* src, ma_uint64 frameCount, ma_format format, ma_uint32 channels)`
fn C.ma_copy_pcm_frames(dst voidptr, const_src voidptr, frame_count u64, format Format, channels u32)

// copy_pcm_frames copies PCM frames from one buffer to another.
pub fn copy_pcm_frames(dst voidptr, const_src voidptr, frame_count u64, format Format, channels u32) {
	C.ma_copy_pcm_frames(dst, const_src, frame_count, format, channels)
}

// C: `MA_API void ma_silence_pcm_frames(void* p, ma_uint64 frameCount, ma_format format, ma_uint32 channels)`
fn C.ma_silence_pcm_frames(p voidptr, frame_count u64, format Format, channels u32)

// silence_pcm_frames copies silent frames into the given buffer.
//
// Remarks
//-------
// For all formats except `ma_format_u8`, the output buffer will be filled with 0. For `ma_format_u8` it will be filled with 128. The reason for this is that it
// makes more sense for the purpose of mixing to initialize it to the center point.
pub fn silence_pcm_frames(p voidptr, frame_count u64, format Format, channels u32) {
	C.ma_silence_pcm_frames(p, frame_count, format, channels)
}

// C: `MA_API void* ma_offset_pcm_frames_ptr(void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels)`
fn C.ma_offset_pcm_frames_ptr(p voidptr, offset_in_frames u64, format Format, channels u32) voidptr

// offset_pcm_frames_ptr offsets a pointer by the specified number of PCM frames.
pub fn offset_pcm_frames_ptr(p voidptr, offset_in_frames u64, format Format, channels u32) voidptr {
	return C.ma_offset_pcm_frames_ptr(p, offset_in_frames, format, channels)
}

// C: `MA_API const void* ma_offset_pcm_frames_const_ptr(const void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels)`
fn C.ma_offset_pcm_frames_const_ptr(const_p voidptr, offset_in_frames u64, format Format, channels u32) voidptr

// offset_pcm_frames_const_ptr is currently undocumented
pub fn offset_pcm_frames_const_ptr(const_p voidptr, offset_in_frames u64, format Format, channels u32) voidptr {
	return C.ma_offset_pcm_frames_const_ptr(const_p, offset_in_frames, format, channels)
}

// C: `MA_API void ma_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count)`
fn C.ma_clip_samples_u8(p_dst &u8, const_p_src &i16, count u64)

// clip_samples_u8 clips samples.
pub fn clip_samples_u8(p_dst &u8, const_p_src &i16, count u64) {
	C.ma_clip_samples_u8(p_dst, const_p_src, count)
}

// C: `MA_API void ma_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count)`
fn C.ma_clip_samples_s16(p_dst &i16, const_p_src &int, count u64)

// clip_samples_s16 is currently undocumented
pub fn clip_samples_s16(p_dst &i16, const_p_src &int, count u64) {
	C.ma_clip_samples_s16(p_dst, const_p_src, count)
}

// C: `MA_API void ma_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count)`
fn C.ma_clip_samples_s24(p_dst &u8, const_p_src &i64, count u64)

// clip_samples_s24 is currently undocumented
pub fn clip_samples_s24(p_dst &u8, const_p_src &i64, count u64) {
	C.ma_clip_samples_s24(p_dst, const_p_src, count)
}

// C: `MA_API void ma_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count)`
fn C.ma_clip_samples_s32(p_dst &int, const_p_src &i64, count u64)

// clip_samples_s32 is currently undocumented
pub fn clip_samples_s32(p_dst &int, const_p_src &i64, count u64) {
	C.ma_clip_samples_s32(p_dst, const_p_src, count)
}

// C: `MA_API void ma_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count)`
fn C.ma_clip_samples_f32(p_dst &f32, const_p_src &f32, count u64)

// clip_samples_f32 is currently undocumented
pub fn clip_samples_f32(p_dst &f32, const_p_src &f32, count u64) {
	C.ma_clip_samples_f32(p_dst, const_p_src, count)
}

// C: `MA_API void ma_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels)`
fn C.ma_clip_pcm_frames(p_dst voidptr, const_p_src voidptr, frame_count u64, format Format, channels u32)

// clip_pcm_frames is currently undocumented
pub fn clip_pcm_frames(p_dst voidptr, const_p_src voidptr, frame_count u64, format Format, channels u32) {
	C.ma_clip_pcm_frames(p_dst, const_p_src, frame_count, format, channels)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_u8(ma_uint8* pSamplesOut, const ma_uint8* pSamplesIn, ma_uint64 sampleCount, float factor)`
fn C.ma_copy_and_apply_volume_factor_u8(p_samples_out &u8, const_p_samples_in &u8, sample_count u64, factor f32)

// copy_and_apply_volume_factor_u8 helpers for applying a volume factor to samples.
//
// Note that the source and destination buffers can be the same, in which case it'll perform the operation in-place.
pub fn copy_and_apply_volume_factor_u8(p_samples_out &u8, const_p_samples_in &u8, sample_count u64, factor f32) {
	C.ma_copy_and_apply_volume_factor_u8(p_samples_out, const_p_samples_in, sample_count,
		factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_s16(ma_int16* pSamplesOut, const ma_int16* pSamplesIn, ma_uint64 sampleCount, float factor)`
fn C.ma_copy_and_apply_volume_factor_s16(p_samples_out &i16, const_p_samples_in &i16, sample_count u64, factor f32)

// copy_and_apply_volume_factor_s16 is currently undocumented
pub fn copy_and_apply_volume_factor_s16(p_samples_out &i16, const_p_samples_in &i16, sample_count u64, factor f32) {
	C.ma_copy_and_apply_volume_factor_s16(p_samples_out, const_p_samples_in, sample_count,
		factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_s24(void* pSamplesOut, const void* pSamplesIn, ma_uint64 sampleCount, float factor)`
fn C.ma_copy_and_apply_volume_factor_s24(p_samples_out voidptr, const_p_samples_in voidptr, sample_count u64, factor f32)

// copy_and_apply_volume_factor_s24 is currently undocumented
pub fn copy_and_apply_volume_factor_s24(p_samples_out voidptr, const_p_samples_in voidptr, sample_count u64, factor f32) {
	C.ma_copy_and_apply_volume_factor_s24(p_samples_out, const_p_samples_in, sample_count,
		factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_s32(ma_int32* pSamplesOut, const ma_int32* pSamplesIn, ma_uint64 sampleCount, float factor)`
fn C.ma_copy_and_apply_volume_factor_s32(p_samples_out &int, const_p_samples_in &int, sample_count u64, factor f32)

// copy_and_apply_volume_factor_s32 is currently undocumented
pub fn copy_and_apply_volume_factor_s32(p_samples_out &int, const_p_samples_in &int, sample_count u64, factor f32) {
	C.ma_copy_and_apply_volume_factor_s32(p_samples_out, const_p_samples_in, sample_count,
		factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_f32(float* pSamplesOut, const float* pSamplesIn, ma_uint64 sampleCount, float factor)`
fn C.ma_copy_and_apply_volume_factor_f32(p_samples_out &f32, const_p_samples_in &f32, sample_count u64, factor f32)

// copy_and_apply_volume_factor_f32 is currently undocumented
pub fn copy_and_apply_volume_factor_f32(p_samples_out &f32, const_p_samples_in &f32, sample_count u64, factor f32) {
	C.ma_copy_and_apply_volume_factor_f32(p_samples_out, const_p_samples_in, sample_count,
		factor)
}

// C: `MA_API void ma_apply_volume_factor_u8(ma_uint8* pSamples, ma_uint64 sampleCount, float factor)`
fn C.ma_apply_volume_factor_u8(p_samples &u8, sample_count u64, factor f32)

// apply_volume_factor_u8 is currently undocumented
pub fn apply_volume_factor_u8(p_samples &u8, sample_count u64, factor f32) {
	C.ma_apply_volume_factor_u8(p_samples, sample_count, factor)
}

// C: `MA_API void ma_apply_volume_factor_s16(ma_int16* pSamples, ma_uint64 sampleCount, float factor)`
fn C.ma_apply_volume_factor_s16(p_samples &i16, sample_count u64, factor f32)

// apply_volume_factor_s16 is currently undocumented
pub fn apply_volume_factor_s16(p_samples &i16, sample_count u64, factor f32) {
	C.ma_apply_volume_factor_s16(p_samples, sample_count, factor)
}

// C: `MA_API void ma_apply_volume_factor_s24(void* pSamples, ma_uint64 sampleCount, float factor)`
fn C.ma_apply_volume_factor_s24(p_samples voidptr, sample_count u64, factor f32)

// apply_volume_factor_s24 is currently undocumented
pub fn apply_volume_factor_s24(p_samples voidptr, sample_count u64, factor f32) {
	C.ma_apply_volume_factor_s24(p_samples, sample_count, factor)
}

// C: `MA_API void ma_apply_volume_factor_s32(ma_int32* pSamples, ma_uint64 sampleCount, float factor)`
fn C.ma_apply_volume_factor_s32(p_samples &int, sample_count u64, factor f32)

// apply_volume_factor_s32 is currently undocumented
pub fn apply_volume_factor_s32(p_samples &int, sample_count u64, factor f32) {
	C.ma_apply_volume_factor_s32(p_samples, sample_count, factor)
}

// C: `MA_API void ma_apply_volume_factor_f32(float* pSamples, ma_uint64 sampleCount, float factor)`
fn C.ma_apply_volume_factor_f32(p_samples &f32, sample_count u64, factor f32)

// apply_volume_factor_f32 is currently undocumented
pub fn apply_volume_factor_f32(p_samples &f32, sample_count u64, factor f32) {
	C.ma_apply_volume_factor_f32(p_samples, sample_count, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames_u8(ma_uint8* pFramesOut, const ma_uint8* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames_u8(p_frames_out &u8, const_p_frames_in &u8, frame_count u64, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames_u8 is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames_u8(p_frames_out &u8, const_p_frames_in &u8, frame_count u64, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames_u8(p_frames_out, const_p_frames_in, frame_count,
		channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s16(ma_int16* pFramesOut, const ma_int16* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames_s16(p_frames_out &i16, const_p_frames_in &i16, frame_count u64, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames_s16 is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames_s16(p_frames_out &i16, const_p_frames_in &i16, frame_count u64, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames_s16(p_frames_out, const_p_frames_in,
		frame_count, channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s24(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames_s24(p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames_s24 is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames_s24(p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames_s24(p_frames_out, const_p_frames_in,
		frame_count, channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s32(ma_int32* pFramesOut, const ma_int32* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames_s32(p_frames_out &int, const_p_frames_in &int, frame_count u64, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames_s32 is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames_s32(p_frames_out &int, const_p_frames_in &int, frame_count u64, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames_s32(p_frames_out, const_p_frames_in,
		frame_count, channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames_f32(p_frames_out &f32, const_p_frames_in &f32, frame_count u64, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames_f32 is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames_f32(p_frames_out &f32, const_p_frames_in &f32, frame_count u64, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames_f32(p_frames_out, const_p_frames_in,
		frame_count, channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor)`
fn C.ma_copy_and_apply_volume_factor_pcm_frames(p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64, format Format, channels u32, factor f32)

// copy_and_apply_volume_factor_pcm_frames is currently undocumented
pub fn copy_and_apply_volume_factor_pcm_frames(p_frames_out voidptr, const_p_frames_in voidptr, frame_count u64, format Format, channels u32, factor f32) {
	C.ma_copy_and_apply_volume_factor_pcm_frames(p_frames_out, const_p_frames_in, frame_count,
		format, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames_u8(ma_uint8* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames_u8(p_frames &u8, frame_count u64, channels u32, factor f32)

// apply_volume_factor_pcm_frames_u8 is currently undocumented
pub fn apply_volume_factor_pcm_frames_u8(p_frames &u8, frame_count u64, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames_u8(p_frames, frame_count, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames_s16(ma_int16* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames_s16(p_frames &i16, frame_count u64, channels u32, factor f32)

// apply_volume_factor_pcm_frames_s16 is currently undocumented
pub fn apply_volume_factor_pcm_frames_s16(p_frames &i16, frame_count u64, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames_s16(p_frames, frame_count, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames_s24(void* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames_s24(p_frames voidptr, frame_count u64, channels u32, factor f32)

// apply_volume_factor_pcm_frames_s24 is currently undocumented
pub fn apply_volume_factor_pcm_frames_s24(p_frames voidptr, frame_count u64, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames_s24(p_frames, frame_count, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames_s32(ma_int32* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames_s32(p_frames &int, frame_count u64, channels u32, factor f32)

// apply_volume_factor_pcm_frames_s32 is currently undocumented
pub fn apply_volume_factor_pcm_frames_s32(p_frames &int, frame_count u64, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames_s32(p_frames, frame_count, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames_f32(float* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames_f32(p_frames &f32, frame_count u64, channels u32, factor f32)

// apply_volume_factor_pcm_frames_f32 is currently undocumented
pub fn apply_volume_factor_pcm_frames_f32(p_frames &f32, frame_count u64, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames_f32(p_frames, frame_count, channels, factor)
}

// C: `MA_API void ma_apply_volume_factor_pcm_frames(void* pFrames, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor)`
fn C.ma_apply_volume_factor_pcm_frames(p_frames voidptr, frame_count u64, format Format, channels u32, factor f32)

// apply_volume_factor_pcm_frames is currently undocumented
pub fn apply_volume_factor_pcm_frames(p_frames voidptr, frame_count u64, format Format, channels u32, factor f32) {
	C.ma_apply_volume_factor_pcm_frames(p_frames, frame_count, format, channels, factor)
}

// C: `MA_API void ma_copy_and_apply_volume_factor_per_channel_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float* pChannelGains)`
fn C.ma_copy_and_apply_volume_factor_per_channel_f32(p_frames_out &f32, const_p_frames_in &f32, frame_count u64, channels u32, p_channel_gains &f32)

// copy_and_apply_volume_factor_per_channel_f32 is currently undocumented
pub fn copy_and_apply_volume_factor_per_channel_f32(p_frames_out &f32, const_p_frames_in &f32, frame_count u64, channels u32, p_channel_gains &f32) {
	C.ma_copy_and_apply_volume_factor_per_channel_f32(p_frames_out, const_p_frames_in,
		frame_count, channels, p_channel_gains)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_samples_u8(p_dst &u8, const_p_src &i16, count u64, volume f32)

// copy_and_apply_volume_and_clip_samples_u8 is currently undocumented
pub fn copy_and_apply_volume_and_clip_samples_u8(p_dst &u8, const_p_src &i16, count u64, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_samples_u8(p_dst, const_p_src, count, volume)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_samples_s16(p_dst &i16, const_p_src &int, count u64, volume f32)

// copy_and_apply_volume_and_clip_samples_s16 is currently undocumented
pub fn copy_and_apply_volume_and_clip_samples_s16(p_dst &i16, const_p_src &int, count u64, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_samples_s16(p_dst, const_p_src, count, volume)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_samples_s24(p_dst &u8, const_p_src &i64, count u64, volume f32)

// copy_and_apply_volume_and_clip_samples_s24 is currently undocumented
pub fn copy_and_apply_volume_and_clip_samples_s24(p_dst &u8, const_p_src &i64, count u64, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_samples_s24(p_dst, const_p_src, count, volume)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_samples_s32(p_dst &int, const_p_src &i64, count u64, volume f32)

// copy_and_apply_volume_and_clip_samples_s32 is currently undocumented
pub fn copy_and_apply_volume_and_clip_samples_s32(p_dst &int, const_p_src &i64, count u64, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_samples_s32(p_dst, const_p_src, count, volume)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_samples_f32(p_dst &f32, const_p_src &f32, count u64, volume f32)

// copy_and_apply_volume_and_clip_samples_f32 is currently undocumented
pub fn copy_and_apply_volume_and_clip_samples_f32(p_dst &f32, const_p_src &f32, count u64, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_samples_f32(p_dst, const_p_src, count, volume)
}

// C: `MA_API void ma_copy_and_apply_volume_and_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float volume)`
fn C.ma_copy_and_apply_volume_and_clip_pcm_frames(p_dst voidptr, const_p_src voidptr, frame_count u64, format Format, channels u32, volume f32)

// copy_and_apply_volume_and_clip_pcm_frames is currently undocumented
pub fn copy_and_apply_volume_and_clip_pcm_frames(p_dst voidptr, const_p_src voidptr, frame_count u64, format Format, channels u32, volume f32) {
	C.ma_copy_and_apply_volume_and_clip_pcm_frames(p_dst, const_p_src, frame_count, format,
		channels, volume)
}

// C: `MA_API float ma_volume_linear_to_db(float factor)`
fn C.ma_volume_linear_to_db(factor f32) f32

// volume_linear_to_db helpers for converting a linear factor to gain in decibels.
pub fn volume_linear_to_db(factor f32) f32 {
	return C.ma_volume_linear_to_db(factor)
}

// C: `MA_API float ma_volume_db_to_linear(float gain)`
fn C.ma_volume_db_to_linear(gain f32) f32

// volume_db_to_linear helpers for converting gain in decibels to a linear factor.
pub fn volume_db_to_linear(gain f32) f32 {
	return C.ma_volume_db_to_linear(gain)
}

pub const data_source_self_managed_range_and_loop_point = 0x00000001

@[typedef]
struct C.ma_data_source_vtable {
pub mut:
	onRead          fn (p_data_source voidptr, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result // onRead)(ma_data_source*
	onSeek          fn (p_data_source voidptr, frame_index u64) Result // onSeek)(ma_data_source*
	onGetDataFormat fn (p_data_source voidptr, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result // onGetDataFormat)(ma_data_source*
	onGetCursor     fn (p_data_source voidptr, p_cursor &u64) Result  // onGetCursor)(ma_data_source*
	onGetLength     fn (p_data_source voidptr, p_length &u64) Result  // onGetLength)(ma_data_source*
	onSetLooping    fn (p_data_source voidptr, is_looping u32) Result // onSetLooping)(ma_data_source*
	flags           u32
}

pub type DataSourceVtable = C.ma_data_source_vtable

// DataSourceGetNextProc is currently undocumented
// C: typedef ma_data_source* (* ma_data_source_get_next_proc)(ma_data_source* pDataSource);
pub type DataSourceGetNextProc = fn (p_data_source voidptr) voidptr

@[typedef]
struct C.ma_data_source_config {
pub mut:
	vtable &DataSourceVtable = unsafe { nil }
}

pub type DataSourceConfig = C.ma_data_source_config

// C: `MA_API ma_data_source_config ma_data_source_config_init(void)`
fn C.ma_data_source_config_init() DataSourceConfig

// data_source_config_init is currently undocumented
pub fn data_source_config_init() DataSourceConfig {
	return C.ma_data_source_config_init()
}

@[typedef]
struct C.ma_data_source_base {
pub mut:
	vtable           &DataSourceVtable = unsafe { nil }
	rangeBegInFrames u64
	rangeEndInFrames u64                   // Set to -1 for unranged (default).
	loopBegInFrames  u64                   // Relative to rangeBegInFrames.
	loopEndInFrames  u64                   // Relative to rangeBegInFrames. Set to -1 for the end of the range.
	pCurrent         voidptr               // When non-NULL, the data source being initialized will act as a proxy and will route all operations to pCurrent. Used in conjunction with pNext/onGetNext for seamless chaining.
	pNext            voidptr               // When set to NULL, onGetNext will be used.
	onGetNext        DataSourceGetNextProc // Will be used when pNext is NULL. If both are NULL, no next will be used.
	// TODO MA_ATOMIC(4, ma_bool32) isLooping
}

pub type DataSourceBase = C.ma_data_source_base

// C: `MA_API ma_result ma_data_source_init(const ma_data_source_config* pConfig, ma_data_source* pDataSource)`
fn C.ma_data_source_init(const_p_config &DataSourceConfig, p_data_source voidptr) Result

// data_source_init is currently undocumented
pub fn data_source_init(const_p_config &DataSourceConfig, p_data_source voidptr) Result {
	return C.ma_data_source_init(const_p_config, p_data_source)
}

// C: `MA_API void ma_data_source_uninit(ma_data_source* pDataSource)`
fn C.ma_data_source_uninit(p_data_source voidptr)

// data_source_uninit is currently undocumented
pub fn data_source_uninit(p_data_source voidptr) {
	C.ma_data_source_uninit(p_data_source)
}

// C: `MA_API ma_result ma_data_source_read_pcm_frames(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead); /* Must support pFramesOut = NULL in which case a forward seek should be performed. */`
fn C.ma_data_source_read_pcm_frames(p_data_source voidptr, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// data_source_read_pcm_frames musts support pFramesOut = NULL in which case a forward seek should be performed.
pub fn data_source_read_pcm_frames(p_data_source voidptr, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_data_source_read_pcm_frames(p_data_source, p_frames_out, frame_count,
		p_frames_read)
}

// C: `MA_API ma_result ma_data_source_seek_pcm_frames(ma_data_source* pDataSource, ma_uint64 frameCount, ma_uint64* pFramesSeeked); /* Can only seek forward. Equivalent to ma_data_source_read_pcm_frames(pDataSource, NULL, frameCount, &framesRead); */`
fn C.ma_data_source_seek_pcm_frames(p_data_source voidptr, frame_count u64, p_frames_seeked &u64) Result

// data_source_seek_pcm_frames cans only seek forward. Equivalent to ma_data_source_read_pcm_frames(pDataSource, NULL, frameCount, &framesRead);
pub fn data_source_seek_pcm_frames(p_data_source voidptr, frame_count u64, p_frames_seeked &u64) Result {
	return C.ma_data_source_seek_pcm_frames(p_data_source, frame_count, p_frames_seeked)
}

// C: `MA_API ma_result ma_data_source_seek_to_pcm_frame(ma_data_source* pDataSource, ma_uint64 frameIndex)`
fn C.ma_data_source_seek_to_pcm_frame(p_data_source voidptr, frame_index u64) Result

// data_source_seek_to_pcm_frame is currently undocumented
pub fn data_source_seek_to_pcm_frame(p_data_source voidptr, frame_index u64) Result {
	return C.ma_data_source_seek_to_pcm_frame(p_data_source, frame_index)
}

// C: `MA_API ma_result ma_data_source_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_data_source_get_data_format(p_data_source voidptr, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// data_source_get_data_format is currently undocumented
pub fn data_source_get_data_format(p_data_source voidptr, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_data_source_get_data_format(p_data_source, &p_format, p_channels, p_sample_rate,
		p_channel_map, channel_map_cap)
}

// C: `MA_API ma_result ma_data_source_get_cursor_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pCursor)`
fn C.ma_data_source_get_cursor_in_pcm_frames(p_data_source voidptr, p_cursor &u64) Result

// data_source_get_cursor_in_pcm_frames is currently undocumented
pub fn data_source_get_cursor_in_pcm_frames(p_data_source voidptr, p_cursor &u64) Result {
	return C.ma_data_source_get_cursor_in_pcm_frames(p_data_source, p_cursor)
}

// C: `MA_API ma_result ma_data_source_get_length_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pLength);/* Returns MA_NOT_IMPLEMENTED if the length is unknown or cannot be determined. Decoders can return this. */`
fn C.ma_data_source_get_length_in_pcm_frames(p_data_source voidptr, p_length &u64) Result

// data_source_get_length_in_pcm_frames returns MA_NOT_IMPLEMENTED if the length is unknown or cannot be determined. Decoders can return this.
pub fn data_source_get_length_in_pcm_frames(p_data_source voidptr, p_length &u64) Result {
	return C.ma_data_source_get_length_in_pcm_frames(p_data_source, p_length)
}

// C: `MA_API ma_result ma_data_source_get_cursor_in_seconds(ma_data_source* pDataSource, float* pCursor)`
fn C.ma_data_source_get_cursor_in_seconds(p_data_source voidptr, p_cursor &f32) Result

// data_source_get_cursor_in_seconds is currently undocumented
pub fn data_source_get_cursor_in_seconds(p_data_source voidptr, p_cursor &f32) Result {
	return C.ma_data_source_get_cursor_in_seconds(p_data_source, p_cursor)
}

// C: `MA_API ma_result ma_data_source_get_length_in_seconds(ma_data_source* pDataSource, float* pLength)`
fn C.ma_data_source_get_length_in_seconds(p_data_source voidptr, p_length &f32) Result

// data_source_get_length_in_seconds is currently undocumented
pub fn data_source_get_length_in_seconds(p_data_source voidptr, p_length &f32) Result {
	return C.ma_data_source_get_length_in_seconds(p_data_source, p_length)
}

// C: `MA_API ma_result ma_data_source_set_looping(ma_data_source* pDataSource, ma_bool32 isLooping)`
fn C.ma_data_source_set_looping(p_data_source voidptr, is_looping u32) Result

// data_source_set_looping is currently undocumented
pub fn data_source_set_looping(p_data_source voidptr, is_looping u32) Result {
	return C.ma_data_source_set_looping(p_data_source, is_looping)
}

// C: `MA_API ma_bool32 ma_data_source_is_looping(const ma_data_source* pDataSource)`
fn C.ma_data_source_is_looping(const_p_data_source voidptr) u32

// data_source_is_looping is currently undocumented
pub fn data_source_is_looping(const_p_data_source voidptr) u32 {
	return C.ma_data_source_is_looping(const_p_data_source)
}

// C: `MA_API ma_result ma_data_source_set_range_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 rangeBegInFrames, ma_uint64 rangeEndInFrames)`
fn C.ma_data_source_set_range_in_pcm_frames(p_data_source voidptr, range_beg_in_frames u64, range_end_in_frames u64) Result

// data_source_set_range_in_pcm_frames is currently undocumented
pub fn data_source_set_range_in_pcm_frames(p_data_source voidptr, range_beg_in_frames u64, range_end_in_frames u64) Result {
	return C.ma_data_source_set_range_in_pcm_frames(p_data_source, range_beg_in_frames,
		range_end_in_frames)
}

// C: `MA_API void ma_data_source_get_range_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pRangeBegInFrames, ma_uint64* pRangeEndInFrames)`
fn C.ma_data_source_get_range_in_pcm_frames(const_p_data_source voidptr, p_range_beg_in_frames &u64, p_range_end_in_frames &u64)

// data_source_get_range_in_pcm_frames is currently undocumented
pub fn data_source_get_range_in_pcm_frames(const_p_data_source voidptr, p_range_beg_in_frames &u64, p_range_end_in_frames &u64) {
	C.ma_data_source_get_range_in_pcm_frames(const_p_data_source, p_range_beg_in_frames,
		p_range_end_in_frames)
}

// C: `MA_API ma_result ma_data_source_set_loop_point_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 loopBegInFrames, ma_uint64 loopEndInFrames)`
fn C.ma_data_source_set_loop_point_in_pcm_frames(p_data_source voidptr, loop_beg_in_frames u64, loop_end_in_frames u64) Result

// data_source_set_loop_point_in_pcm_frames is currently undocumented
pub fn data_source_set_loop_point_in_pcm_frames(p_data_source voidptr, loop_beg_in_frames u64, loop_end_in_frames u64) Result {
	return C.ma_data_source_set_loop_point_in_pcm_frames(p_data_source, loop_beg_in_frames,
		loop_end_in_frames)
}

// C: `MA_API void ma_data_source_get_loop_point_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pLoopBegInFrames, ma_uint64* pLoopEndInFrames)`
fn C.ma_data_source_get_loop_point_in_pcm_frames(const_p_data_source voidptr, p_loop_beg_in_frames &u64, p_loop_end_in_frames &u64)

// data_source_get_loop_point_in_pcm_frames is currently undocumented
pub fn data_source_get_loop_point_in_pcm_frames(const_p_data_source voidptr, p_loop_beg_in_frames &u64, p_loop_end_in_frames &u64) {
	C.ma_data_source_get_loop_point_in_pcm_frames(const_p_data_source, p_loop_beg_in_frames,
		p_loop_end_in_frames)
}

// C: `MA_API ma_result ma_data_source_set_current(ma_data_source* pDataSource, ma_data_source* pCurrentDataSource)`
fn C.ma_data_source_set_current(p_data_source voidptr, p_current_data_source voidptr) Result

// data_source_set_current is currently undocumented
pub fn data_source_set_current(p_data_source voidptr, p_current_data_source voidptr) Result {
	return C.ma_data_source_set_current(p_data_source, p_current_data_source)
}

// C: `MA_API ma_data_source* ma_data_source_get_current(const ma_data_source* pDataSource)`
fn C.ma_data_source_get_current(const_p_data_source voidptr) voidptr

// data_source_get_current is currently undocumented
pub fn data_source_get_current(const_p_data_source voidptr) voidptr {
	return C.ma_data_source_get_current(const_p_data_source)
}

// C: `MA_API ma_result ma_data_source_set_next(ma_data_source* pDataSource, ma_data_source* pNextDataSource)`
fn C.ma_data_source_set_next(p_data_source voidptr, p_next_data_source voidptr) Result

// data_source_set_next is currently undocumented
pub fn data_source_set_next(p_data_source voidptr, p_next_data_source voidptr) Result {
	return C.ma_data_source_set_next(p_data_source, p_next_data_source)
}

// C: `MA_API ma_data_source* ma_data_source_get_next(const ma_data_source* pDataSource)`
fn C.ma_data_source_get_next(const_p_data_source voidptr) voidptr

// data_source_get_next is currently undocumented
pub fn data_source_get_next(const_p_data_source voidptr) voidptr {
	return C.ma_data_source_get_next(const_p_data_source)
}

// C: `MA_API ma_result ma_data_source_set_next_callback(ma_data_source* pDataSource, ma_data_source_get_next_proc onGetNext)`
fn C.ma_data_source_set_next_callback(p_data_source voidptr, on_get_next DataSourceGetNextProc) Result

// data_source_set_next_callback is currently undocumented
pub fn data_source_set_next_callback(p_data_source voidptr, on_get_next DataSourceGetNextProc) Result {
	return C.ma_data_source_set_next_callback(p_data_source, on_get_next)
}

// C: `MA_API ma_data_source_get_next_proc ma_data_source_get_next_callback(const ma_data_source* pDataSource)`
fn C.ma_data_source_get_next_callback(const_p_data_source voidptr) DataSourceGetNextProc

// data_source_get_next_callback is currently undocumented
pub fn data_source_get_next_callback(const_p_data_source voidptr) DataSourceGetNextProc {
	return C.ma_data_source_get_next_callback(const_p_data_source)
}

@[typedef]
struct C.ma_audio_buffer_ref {
pub mut:
	ds           DataSourceBase
	format       Format
	channels     u32
	sampleRate   u32
	cursor       u64
	sizeInFrames u64
	pData        voidptr
}

pub type AudioBufferRef = C.ma_audio_buffer_ref

// C: `MA_API ma_result ma_audio_buffer_ref_init(ma_format format, ma_uint32 channels, const void* pData, ma_uint64 sizeInFrames, ma_audio_buffer_ref* pAudioBufferRef)`
fn C.ma_audio_buffer_ref_init(format Format, channels u32, const_p_data voidptr, size_in_frames u64, p_audio_buffer_ref &AudioBufferRef) Result

// audio_buffer_ref_init is currently undocumented
pub fn audio_buffer_ref_init(format Format, channels u32, const_p_data voidptr, size_in_frames u64, p_audio_buffer_ref &AudioBufferRef) Result {
	return C.ma_audio_buffer_ref_init(format, channels, const_p_data, size_in_frames,
		p_audio_buffer_ref)
}

// C: `MA_API void ma_audio_buffer_ref_uninit(ma_audio_buffer_ref* pAudioBufferRef)`
fn C.ma_audio_buffer_ref_uninit(p_audio_buffer_ref &AudioBufferRef)

// audio_buffer_ref_uninit is currently undocumented
pub fn audio_buffer_ref_uninit(p_audio_buffer_ref &AudioBufferRef) {
	C.ma_audio_buffer_ref_uninit(p_audio_buffer_ref)
}

// C: `MA_API ma_result ma_audio_buffer_ref_set_data(ma_audio_buffer_ref* pAudioBufferRef, const void* pData, ma_uint64 sizeInFrames)`
fn C.ma_audio_buffer_ref_set_data(p_audio_buffer_ref &AudioBufferRef, const_p_data voidptr, size_in_frames u64) Result

// audio_buffer_ref_set_data is currently undocumented
pub fn audio_buffer_ref_set_data(p_audio_buffer_ref &AudioBufferRef, const_p_data voidptr, size_in_frames u64) Result {
	return C.ma_audio_buffer_ref_set_data(p_audio_buffer_ref, const_p_data, size_in_frames)
}

// C: `MA_API ma_uint64 ma_audio_buffer_ref_read_pcm_frames(ma_audio_buffer_ref* pAudioBufferRef, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop)`
fn C.ma_audio_buffer_ref_read_pcm_frames(p_audio_buffer_ref &AudioBufferRef, p_frames_out voidptr, frame_count u64, loop u32) u64

// audio_buffer_ref_read_pcm_frames is currently undocumented
pub fn audio_buffer_ref_read_pcm_frames(p_audio_buffer_ref &AudioBufferRef, p_frames_out voidptr, frame_count u64, loop u32) u64 {
	return C.ma_audio_buffer_ref_read_pcm_frames(p_audio_buffer_ref, p_frames_out, frame_count,
		loop)
}

// C: `MA_API ma_result ma_audio_buffer_ref_seek_to_pcm_frame(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameIndex)`
fn C.ma_audio_buffer_ref_seek_to_pcm_frame(p_audio_buffer_ref &AudioBufferRef, frame_index u64) Result

// audio_buffer_ref_seek_to_pcm_frame is currently undocumented
pub fn audio_buffer_ref_seek_to_pcm_frame(p_audio_buffer_ref &AudioBufferRef, frame_index u64) Result {
	return C.ma_audio_buffer_ref_seek_to_pcm_frame(p_audio_buffer_ref, frame_index)
}

// C: `MA_API ma_result ma_audio_buffer_ref_map(ma_audio_buffer_ref* pAudioBufferRef, void** ppFramesOut, ma_uint64* pFrameCount)`
fn C.ma_audio_buffer_ref_map(p_audio_buffer_ref &AudioBufferRef, pp_frames_out voidptr, p_frame_count &u64) Result

// audio_buffer_ref_map is currently undocumented
pub fn audio_buffer_ref_map(p_audio_buffer_ref &AudioBufferRef, pp_frames_out voidptr, p_frame_count &u64) Result {
	return C.ma_audio_buffer_ref_map(p_audio_buffer_ref, pp_frames_out, p_frame_count)
}

// C: `MA_API ma_result ma_audio_buffer_ref_unmap(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameCount);/* Returns MA_AT_END if the end has been reached. This should be considered successful. */`
fn C.ma_audio_buffer_ref_unmap(p_audio_buffer_ref &AudioBufferRef, frame_count u64) Result

// audio_buffer_ref_unmap returns MA_AT_END if the end has been reached. This should be considered successful.
pub fn audio_buffer_ref_unmap(p_audio_buffer_ref &AudioBufferRef, frame_count u64) Result {
	return C.ma_audio_buffer_ref_unmap(p_audio_buffer_ref, frame_count)
}

// C: `MA_API ma_bool32 ma_audio_buffer_ref_at_end(const ma_audio_buffer_ref* pAudioBufferRef)`
fn C.ma_audio_buffer_ref_at_end(const_p_audio_buffer_ref &AudioBufferRef) u32

// audio_buffer_ref_at_end is currently undocumented
pub fn audio_buffer_ref_at_end(const_p_audio_buffer_ref &AudioBufferRef) u32 {
	return C.ma_audio_buffer_ref_at_end(const_p_audio_buffer_ref)
}

// C: `MA_API ma_result ma_audio_buffer_ref_get_cursor_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pCursor)`
fn C.ma_audio_buffer_ref_get_cursor_in_pcm_frames(const_p_audio_buffer_ref &AudioBufferRef, p_cursor &u64) Result

// audio_buffer_ref_get_cursor_in_pcm_frames is currently undocumented
pub fn audio_buffer_ref_get_cursor_in_pcm_frames(const_p_audio_buffer_ref &AudioBufferRef, p_cursor &u64) Result {
	return C.ma_audio_buffer_ref_get_cursor_in_pcm_frames(const_p_audio_buffer_ref, p_cursor)
}

// C: `MA_API ma_result ma_audio_buffer_ref_get_length_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pLength)`
fn C.ma_audio_buffer_ref_get_length_in_pcm_frames(const_p_audio_buffer_ref &AudioBufferRef, p_length &u64) Result

// audio_buffer_ref_get_length_in_pcm_frames is currently undocumented
pub fn audio_buffer_ref_get_length_in_pcm_frames(const_p_audio_buffer_ref &AudioBufferRef, p_length &u64) Result {
	return C.ma_audio_buffer_ref_get_length_in_pcm_frames(const_p_audio_buffer_ref, p_length)
}

// C: `MA_API ma_result ma_audio_buffer_ref_get_available_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pAvailableFrames)`
fn C.ma_audio_buffer_ref_get_available_frames(const_p_audio_buffer_ref &AudioBufferRef, p_available_frames &u64) Result

// audio_buffer_ref_get_available_frames is currently undocumented
pub fn audio_buffer_ref_get_available_frames(const_p_audio_buffer_ref &AudioBufferRef, p_available_frames &u64) Result {
	return C.ma_audio_buffer_ref_get_available_frames(const_p_audio_buffer_ref, p_available_frames)
}

@[typedef]
struct C.ma_audio_buffer_config {
pub mut:
	format              Format
	channels            u32
	sampleRate          u32
	sizeInFrames        u64
	pData               voidptr // If set to NULL, will allocate a block of memory for you.
	allocationCallbacks AllocationCallbacks
}

pub type AudioBufferConfig = C.ma_audio_buffer_config

// C: `MA_API ma_audio_buffer_config ma_audio_buffer_config_init(ma_format format, ma_uint32 channels, ma_uint64 sizeInFrames, const void* pData, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_audio_buffer_config_init(format Format, channels u32, size_in_frames u64, const_p_data voidptr, const_p_allocation_callbacks &AllocationCallbacks) AudioBufferConfig

// audio_buffer_config_init is currently undocumented
pub fn audio_buffer_config_init(format Format, channels u32, size_in_frames u64, const_p_data voidptr, const_p_allocation_callbacks &AllocationCallbacks) AudioBufferConfig {
	return C.ma_audio_buffer_config_init(format, channels, size_in_frames, const_p_data,
		const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_audio_buffer {
pub mut:
	ref                 AudioBufferRef
	allocationCallbacks AllocationCallbacks
	ownsData            u32 // Used to control whether or not miniaudio owns the data buffer. If set to true, pData will be freed in ma_audio_buffer_uninit().
	// TODO 	_pExtraData [1]u8 // For allocating a buffer with the memory located directly after the other memory of the structure.
}

pub type AudioBuffer = C.ma_audio_buffer

// C: `MA_API ma_result ma_audio_buffer_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer)`
fn C.ma_audio_buffer_init(const_p_config &AudioBufferConfig, p_audio_buffer &AudioBuffer) Result

// audio_buffer_init is currently undocumented
pub fn audio_buffer_init(const_p_config &AudioBufferConfig, p_audio_buffer &AudioBuffer) Result {
	return C.ma_audio_buffer_init(const_p_config, p_audio_buffer)
}

// C: `MA_API ma_result ma_audio_buffer_init_copy(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer)`
fn C.ma_audio_buffer_init_copy(const_p_config &AudioBufferConfig, p_audio_buffer &AudioBuffer) Result

// audio_buffer_init_copy is currently undocumented
pub fn audio_buffer_init_copy(const_p_config &AudioBufferConfig, p_audio_buffer &AudioBuffer) Result {
	return C.ma_audio_buffer_init_copy(const_p_config, p_audio_buffer)
}

// C: `MA_API ma_result ma_audio_buffer_alloc_and_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer** ppAudioBuffer);/* Always copies the data. Doesn't make sense to use this otherwise. Use ma_audio_buffer_uninit_and_free() to uninit. */`
fn C.ma_audio_buffer_alloc_and_init(const_p_config &AudioBufferConfig, pp_audio_buffer &&AudioBuffer) Result

// audio_buffer_alloc_and_init always copies the data. Doesn't make sense to use this otherwise. Use ma_audio_buffer_uninit_and_free() to uninit.
pub fn audio_buffer_alloc_and_init(const_p_config &AudioBufferConfig, pp_audio_buffer &&AudioBuffer) Result {
	return C.ma_audio_buffer_alloc_and_init(const_p_config, pp_audio_buffer)
}

// C: `MA_API void ma_audio_buffer_uninit(ma_audio_buffer* pAudioBuffer)`
fn C.ma_audio_buffer_uninit(p_audio_buffer &AudioBuffer)

// audio_buffer_uninit is currently undocumented
pub fn audio_buffer_uninit(p_audio_buffer &AudioBuffer) {
	C.ma_audio_buffer_uninit(p_audio_buffer)
}

// C: `MA_API void ma_audio_buffer_uninit_and_free(ma_audio_buffer* pAudioBuffer)`
fn C.ma_audio_buffer_uninit_and_free(p_audio_buffer &AudioBuffer)

// audio_buffer_uninit_and_free is currently undocumented
pub fn audio_buffer_uninit_and_free(p_audio_buffer &AudioBuffer) {
	C.ma_audio_buffer_uninit_and_free(p_audio_buffer)
}

// C: `MA_API ma_uint64 ma_audio_buffer_read_pcm_frames(ma_audio_buffer* pAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop)`
fn C.ma_audio_buffer_read_pcm_frames(p_audio_buffer &AudioBuffer, p_frames_out voidptr, frame_count u64, loop u32) u64

// audio_buffer_read_pcm_frames is currently undocumented
pub fn audio_buffer_read_pcm_frames(p_audio_buffer &AudioBuffer, p_frames_out voidptr, frame_count u64, loop u32) u64 {
	return C.ma_audio_buffer_read_pcm_frames(p_audio_buffer, p_frames_out, frame_count,
		loop)
}

// C: `MA_API ma_result ma_audio_buffer_seek_to_pcm_frame(ma_audio_buffer* pAudioBuffer, ma_uint64 frameIndex)`
fn C.ma_audio_buffer_seek_to_pcm_frame(p_audio_buffer &AudioBuffer, frame_index u64) Result

// audio_buffer_seek_to_pcm_frame is currently undocumented
pub fn audio_buffer_seek_to_pcm_frame(p_audio_buffer &AudioBuffer, frame_index u64) Result {
	return C.ma_audio_buffer_seek_to_pcm_frame(p_audio_buffer, frame_index)
}

// C: `MA_API ma_result ma_audio_buffer_map(ma_audio_buffer* pAudioBuffer, void** ppFramesOut, ma_uint64* pFrameCount)`
fn C.ma_audio_buffer_map(p_audio_buffer &AudioBuffer, pp_frames_out voidptr, p_frame_count &u64) Result

// audio_buffer_map is currently undocumented
pub fn audio_buffer_map(p_audio_buffer &AudioBuffer, pp_frames_out voidptr, p_frame_count &u64) Result {
	return C.ma_audio_buffer_map(p_audio_buffer, pp_frames_out, p_frame_count)
}

// C: `MA_API ma_result ma_audio_buffer_unmap(ma_audio_buffer* pAudioBuffer, ma_uint64 frameCount);/* Returns MA_AT_END if the end has been reached. This should be considered successful. */`
fn C.ma_audio_buffer_unmap(p_audio_buffer &AudioBuffer, frame_count u64) Result

// audio_buffer_unmap returns MA_AT_END if the end has been reached. This should be considered successful.
pub fn audio_buffer_unmap(p_audio_buffer &AudioBuffer, frame_count u64) Result {
	return C.ma_audio_buffer_unmap(p_audio_buffer, frame_count)
}

// C: `MA_API ma_bool32 ma_audio_buffer_at_end(const ma_audio_buffer* pAudioBuffer)`
fn C.ma_audio_buffer_at_end(const_p_audio_buffer &AudioBuffer) u32

// audio_buffer_at_end is currently undocumented
pub fn audio_buffer_at_end(const_p_audio_buffer &AudioBuffer) u32 {
	return C.ma_audio_buffer_at_end(const_p_audio_buffer)
}

// C: `MA_API ma_result ma_audio_buffer_get_cursor_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pCursor)`
fn C.ma_audio_buffer_get_cursor_in_pcm_frames(const_p_audio_buffer &AudioBuffer, p_cursor &u64) Result

// audio_buffer_get_cursor_in_pcm_frames is currently undocumented
pub fn audio_buffer_get_cursor_in_pcm_frames(const_p_audio_buffer &AudioBuffer, p_cursor &u64) Result {
	return C.ma_audio_buffer_get_cursor_in_pcm_frames(const_p_audio_buffer, p_cursor)
}

// C: `MA_API ma_result ma_audio_buffer_get_length_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pLength)`
fn C.ma_audio_buffer_get_length_in_pcm_frames(const_p_audio_buffer &AudioBuffer, p_length &u64) Result

// audio_buffer_get_length_in_pcm_frames is currently undocumented
pub fn audio_buffer_get_length_in_pcm_frames(const_p_audio_buffer &AudioBuffer, p_length &u64) Result {
	return C.ma_audio_buffer_get_length_in_pcm_frames(const_p_audio_buffer, p_length)
}

// C: `MA_API ma_result ma_audio_buffer_get_available_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pAvailableFrames)`
fn C.ma_audio_buffer_get_available_frames(const_p_audio_buffer &AudioBuffer, p_available_frames &u64) Result

// audio_buffer_get_available_frames is currently undocumented
pub fn audio_buffer_get_available_frames(const_p_audio_buffer &AudioBuffer, p_available_frames &u64) Result {
	return C.ma_audio_buffer_get_available_frames(const_p_audio_buffer, p_available_frames)
}

@[typedef]
struct C.ma_paged_audio_buffer_page {
pub mut:
	// TODO MA_ATOMIC(MA_SIZEOF_PTR, ma_paged_audio_buffer_page*) pNext
	sizeInFrames u64
	// TODO 	pAudioData [1]u8
}

pub type PagedAudioBufferPage = C.ma_paged_audio_buffer_page

@[typedef]
struct C.ma_paged_audio_buffer_data {
pub mut:
	format   Format
	channels u32
	head     PagedAudioBufferPage // Dummy head for the lock-free algorithm. Always has a size of 0.
	// TODO MA_ATOMIC(MA_SIZEOF_PTR, ma_paged_audio_buffer_page*) pTail
}

pub type PagedAudioBufferData = C.ma_paged_audio_buffer_data

// C: `MA_API ma_result ma_paged_audio_buffer_data_init(ma_format format, ma_uint32 channels, ma_paged_audio_buffer_data* pData)`
fn C.ma_paged_audio_buffer_data_init(format Format, channels u32, p_data &PagedAudioBufferData) Result

// paged_audio_buffer_data_init is currently undocumented
pub fn paged_audio_buffer_data_init(format Format, channels u32, p_data &PagedAudioBufferData) Result {
	return C.ma_paged_audio_buffer_data_init(format, channels, p_data)
}

// C: `MA_API void ma_paged_audio_buffer_data_uninit(ma_paged_audio_buffer_data* pData, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_paged_audio_buffer_data_uninit(p_data &PagedAudioBufferData, const_p_allocation_callbacks &AllocationCallbacks)

// paged_audio_buffer_data_uninit is currently undocumented
pub fn paged_audio_buffer_data_uninit(p_data &PagedAudioBufferData, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_paged_audio_buffer_data_uninit(p_data, const_p_allocation_callbacks)
}

// C: `MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_head(ma_paged_audio_buffer_data* pData)`
fn C.ma_paged_audio_buffer_data_get_head(p_data &PagedAudioBufferData) &PagedAudioBufferPage

// paged_audio_buffer_data_get_head is currently undocumented
pub fn paged_audio_buffer_data_get_head(p_data &PagedAudioBufferData) &PagedAudioBufferPage {
	return C.ma_paged_audio_buffer_data_get_head(p_data)
}

// C: `MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_tail(ma_paged_audio_buffer_data* pData)`
fn C.ma_paged_audio_buffer_data_get_tail(p_data &PagedAudioBufferData) &PagedAudioBufferPage

// paged_audio_buffer_data_get_tail is currently undocumented
pub fn paged_audio_buffer_data_get_tail(p_data &PagedAudioBufferData) &PagedAudioBufferPage {
	return C.ma_paged_audio_buffer_data_get_tail(p_data)
}

// C: `MA_API ma_result ma_paged_audio_buffer_data_get_length_in_pcm_frames(ma_paged_audio_buffer_data* pData, ma_uint64* pLength)`
fn C.ma_paged_audio_buffer_data_get_length_in_pcm_frames(p_data &PagedAudioBufferData, p_length &u64) Result

// paged_audio_buffer_data_get_length_in_pcm_frames is currently undocumented
pub fn paged_audio_buffer_data_get_length_in_pcm_frames(p_data &PagedAudioBufferData, p_length &u64) Result {
	return C.ma_paged_audio_buffer_data_get_length_in_pcm_frames(p_data, p_length)
}

// C: `MA_API ma_result ma_paged_audio_buffer_data_allocate_page(ma_paged_audio_buffer_data* pData, ma_uint64 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks, ma_paged_audio_buffer_page** ppPage)`
fn C.ma_paged_audio_buffer_data_allocate_page(p_data &PagedAudioBufferData, page_size_in_frames u64, const_p_initial_data voidptr, const_p_allocation_callbacks &AllocationCallbacks, pp_page &&PagedAudioBufferPage) Result

// paged_audio_buffer_data_allocate_page is currently undocumented
pub fn paged_audio_buffer_data_allocate_page(p_data &PagedAudioBufferData, page_size_in_frames u64, const_p_initial_data voidptr, const_p_allocation_callbacks &AllocationCallbacks, pp_page &&PagedAudioBufferPage) Result {
	return C.ma_paged_audio_buffer_data_allocate_page(p_data, page_size_in_frames, const_p_initial_data,
		const_p_allocation_callbacks, pp_page)
}

// C: `MA_API ma_result ma_paged_audio_buffer_data_free_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_paged_audio_buffer_data_free_page(p_data &PagedAudioBufferData, p_page &PagedAudioBufferPage, const_p_allocation_callbacks &AllocationCallbacks) Result

// paged_audio_buffer_data_free_page is currently undocumented
pub fn paged_audio_buffer_data_free_page(p_data &PagedAudioBufferData, p_page &PagedAudioBufferPage, const_p_allocation_callbacks &AllocationCallbacks) Result {
	return C.ma_paged_audio_buffer_data_free_page(p_data, p_page, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_paged_audio_buffer_data_append_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage)`
fn C.ma_paged_audio_buffer_data_append_page(p_data &PagedAudioBufferData, p_page &PagedAudioBufferPage) Result

// paged_audio_buffer_data_append_page is currently undocumented
pub fn paged_audio_buffer_data_append_page(p_data &PagedAudioBufferData, p_page &PagedAudioBufferPage) Result {
	return C.ma_paged_audio_buffer_data_append_page(p_data, p_page)
}

// C: `MA_API ma_result ma_paged_audio_buffer_data_allocate_and_append_page(ma_paged_audio_buffer_data* pData, ma_uint32 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_paged_audio_buffer_data_allocate_and_append_page(p_data &PagedAudioBufferData, page_size_in_frames u32, const_p_initial_data voidptr, const_p_allocation_callbacks &AllocationCallbacks) Result

// paged_audio_buffer_data_allocate_and_append_page is currently undocumented
pub fn paged_audio_buffer_data_allocate_and_append_page(p_data &PagedAudioBufferData, page_size_in_frames u32, const_p_initial_data voidptr, const_p_allocation_callbacks &AllocationCallbacks) Result {
	return C.ma_paged_audio_buffer_data_allocate_and_append_page(p_data, page_size_in_frames,
		const_p_initial_data, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_paged_audio_buffer_config {
pub mut:
	pData &PagedAudioBufferData = unsafe { nil } // Must not be null.
}

pub type PagedAudioBufferConfig = C.ma_paged_audio_buffer_config

// C: `MA_API ma_paged_audio_buffer_config ma_paged_audio_buffer_config_init(ma_paged_audio_buffer_data* pData)`
fn C.ma_paged_audio_buffer_config_init(p_data &PagedAudioBufferData) PagedAudioBufferConfig

// paged_audio_buffer_config_init is currently undocumented
pub fn paged_audio_buffer_config_init(p_data &PagedAudioBufferData) PagedAudioBufferConfig {
	return C.ma_paged_audio_buffer_config_init(p_data)
}

@[typedef]
struct C.ma_paged_audio_buffer {
pub mut:
	ds             DataSourceBase
	pData          &PagedAudioBufferData = unsafe { nil } // Audio data is read from here. Cannot be null.
	pCurrent       &PagedAudioBufferPage = unsafe { nil }
	relativeCursor u64 // Relative to the current page.
	absoluteCursor u64
}

pub type PagedAudioBuffer = C.ma_paged_audio_buffer

// C: `MA_API ma_result ma_paged_audio_buffer_init(const ma_paged_audio_buffer_config* pConfig, ma_paged_audio_buffer* pPagedAudioBuffer)`
fn C.ma_paged_audio_buffer_init(const_p_config &PagedAudioBufferConfig, p_paged_audio_buffer &PagedAudioBuffer) Result

// paged_audio_buffer_init is currently undocumented
pub fn paged_audio_buffer_init(const_p_config &PagedAudioBufferConfig, p_paged_audio_buffer &PagedAudioBuffer) Result {
	return C.ma_paged_audio_buffer_init(const_p_config, p_paged_audio_buffer)
}

// C: `MA_API void ma_paged_audio_buffer_uninit(ma_paged_audio_buffer* pPagedAudioBuffer)`
fn C.ma_paged_audio_buffer_uninit(p_paged_audio_buffer &PagedAudioBuffer)

// paged_audio_buffer_uninit is currently undocumented
pub fn paged_audio_buffer_uninit(p_paged_audio_buffer &PagedAudioBuffer) {
	C.ma_paged_audio_buffer_uninit(p_paged_audio_buffer)
}

// C: `MA_API ma_result ma_paged_audio_buffer_read_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead); /* Returns MA_AT_END if no more pages available. */`
fn C.ma_paged_audio_buffer_read_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// paged_audio_buffer_read_pcm_frames returns MA_AT_END if no more pages available.
pub fn paged_audio_buffer_read_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_paged_audio_buffer_read_pcm_frames(p_paged_audio_buffer, p_frames_out,
		frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_paged_audio_buffer_seek_to_pcm_frame(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64 frameIndex)`
fn C.ma_paged_audio_buffer_seek_to_pcm_frame(p_paged_audio_buffer &PagedAudioBuffer, frame_index u64) Result

// paged_audio_buffer_seek_to_pcm_frame is currently undocumented
pub fn paged_audio_buffer_seek_to_pcm_frame(p_paged_audio_buffer &PagedAudioBuffer, frame_index u64) Result {
	return C.ma_paged_audio_buffer_seek_to_pcm_frame(p_paged_audio_buffer, frame_index)
}

// C: `MA_API ma_result ma_paged_audio_buffer_get_cursor_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pCursor)`
fn C.ma_paged_audio_buffer_get_cursor_in_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_cursor &u64) Result

// paged_audio_buffer_get_cursor_in_pcm_frames is currently undocumented
pub fn paged_audio_buffer_get_cursor_in_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_cursor &u64) Result {
	return C.ma_paged_audio_buffer_get_cursor_in_pcm_frames(p_paged_audio_buffer, p_cursor)
}

// C: `MA_API ma_result ma_paged_audio_buffer_get_length_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pLength)`
fn C.ma_paged_audio_buffer_get_length_in_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_length &u64) Result

// paged_audio_buffer_get_length_in_pcm_frames is currently undocumented
pub fn paged_audio_buffer_get_length_in_pcm_frames(p_paged_audio_buffer &PagedAudioBuffer, p_length &u64) Result {
	return C.ma_paged_audio_buffer_get_length_in_pcm_frames(p_paged_audio_buffer, p_length)
}

// OpenModeFlags is C.ma_open_mode_flags
pub enum OpenModeFlags {
	read  = C.MA_OPEN_MODE_READ  // 0x00000001,
	write = C.MA_OPEN_MODE_WRITE // 0x00000002,
}

// SeekOrigin is C.ma_seek_origin
pub enum SeekOrigin {
	start   = C.ma_seek_origin_start
	current = C.ma_seek_origin_current
	end     = C.ma_seek_origin_end // Not used by decoders.
}

@[typedef]
struct C.ma_file_info {
pub mut:
	sizeInBytes u64
}

pub type FileInfo = C.ma_file_info

@[typedef]
struct C.ma_vfs_callbacks {
pub mut:
	onOpen  fn (p_vfs voidptr, const_p_file_path &char, open_mode u32, p_file &C.ma_vfs_file) Result // onOpen)
	onOpenW fn (p_vfs voidptr, const_p_file_path &u16, open_mode u32, p_file &C.ma_vfs_file) Result  // onOpenW)(ma_vfs*
	onClose fn (p_vfs voidptr, file C.ma_vfs_file) Result // onClose)(ma_vfs*
	onRead  fn (p_vfs voidptr, file C.ma_vfs_file, p_dst voidptr, size_in_bytes usize, p_bytes_read &usize) Result          // onRead)
	onWrite fn (p_vfs voidptr, file C.ma_vfs_file, const_p_src voidptr, size_in_bytes usize, p_bytes_written &usize) Result // onWrite)(ma_vfs*
	onSeek  fn (p_vfs voidptr, file C.ma_vfs_file, offset i64, origin SeekOrigin) Result // onSeek)
	onTell  fn (p_vfs voidptr, file C.ma_vfs_file, p_cursor &i64) Result                 // onTell)
	onInfo  fn (p_vfs voidptr, file C.ma_vfs_file, p_info &FileInfo) Result              // onInfo)
}

pub type VfsCallbacks = C.ma_vfs_callbacks

// C: `MA_API ma_result ma_vfs_open(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)`
fn C.ma_vfs_open(p_vfs voidptr, const_p_file_path &char, open_mode u32, p_file &C.ma_vfs_file) Result

// vfs_open is currently undocumented
pub fn vfs_open(p_vfs voidptr, const_p_file_path &char, open_mode u32, p_file &C.ma_vfs_file) Result {
	return C.ma_vfs_open(p_vfs, const_p_file_path, open_mode, p_file)
}

// C: `MA_API ma_result ma_vfs_open_w(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)`
fn C.ma_vfs_open_w(p_vfs voidptr, const_p_file_path &u16, open_mode u32, p_file &C.ma_vfs_file) Result

// vfs_open_w is currently undocumented
pub fn vfs_open_w(p_vfs voidptr, const_p_file_path &u16, open_mode u32, p_file &C.ma_vfs_file) Result {
	return C.ma_vfs_open_w(p_vfs, const_p_file_path, open_mode, p_file)
}

// C: `MA_API ma_result ma_vfs_close(ma_vfs* pVFS, ma_vfs_file file)`
fn C.ma_vfs_close(p_vfs voidptr, file C.ma_vfs_file) Result

// vfs_close is currently undocumented
pub fn vfs_close(p_vfs voidptr, file C.ma_vfs_file) Result {
	return C.ma_vfs_close(p_vfs, file)
}

// C: `MA_API ma_result ma_vfs_read(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)`
fn C.ma_vfs_read(p_vfs voidptr, file C.ma_vfs_file, p_dst voidptr, size_in_bytes usize, p_bytes_read &usize) Result

// vfs_read is currently undocumented
pub fn vfs_read(p_vfs voidptr, file C.ma_vfs_file, p_dst voidptr, size_in_bytes usize, p_bytes_read &usize) Result {
	return C.ma_vfs_read(p_vfs, file, p_dst, size_in_bytes, p_bytes_read)
}

// C: `MA_API ma_result ma_vfs_write(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)`
fn C.ma_vfs_write(p_vfs voidptr, file C.ma_vfs_file, const_p_src voidptr, size_in_bytes usize, p_bytes_written &usize) Result

// vfs_write is currently undocumented
pub fn vfs_write(p_vfs voidptr, file C.ma_vfs_file, const_p_src voidptr, size_in_bytes usize, p_bytes_written &usize) Result {
	return C.ma_vfs_write(p_vfs, file, const_p_src, size_in_bytes, p_bytes_written)
}

// C: `MA_API ma_result ma_vfs_seek(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)`
fn C.ma_vfs_seek(p_vfs voidptr, file C.ma_vfs_file, offset i64, origin SeekOrigin) Result

// vfs_seek is currently undocumented
pub fn vfs_seek(p_vfs voidptr, file C.ma_vfs_file, offset i64, origin SeekOrigin) Result {
	return C.ma_vfs_seek(p_vfs, file, offset, origin)
}

// C: `MA_API ma_result ma_vfs_tell(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)`
fn C.ma_vfs_tell(p_vfs voidptr, file C.ma_vfs_file, p_cursor &i64) Result

// vfs_tell is currently undocumented
pub fn vfs_tell(p_vfs voidptr, file C.ma_vfs_file, p_cursor &i64) Result {
	return C.ma_vfs_tell(p_vfs, file, p_cursor)
}

// C: `MA_API ma_result ma_vfs_info(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)`
fn C.ma_vfs_info(p_vfs voidptr, file C.ma_vfs_file, p_info &FileInfo) Result

// vfs_info is currently undocumented
pub fn vfs_info(p_vfs voidptr, file C.ma_vfs_file, p_info &FileInfo) Result {
	return C.ma_vfs_info(p_vfs, file, p_info)
}

// C: `MA_API ma_result ma_vfs_open_and_read_file(ma_vfs* pVFS, const char* pFilePath, void** ppData, size_t* pSize, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_vfs_open_and_read_file(p_vfs voidptr, const_p_file_path &char, pp_data voidptr, p_size &usize, const_p_allocation_callbacks &AllocationCallbacks) Result

// vfs_open_and_read_file is currently undocumented
pub fn vfs_open_and_read_file(p_vfs voidptr, const_p_file_path &char, pp_data voidptr, p_size &usize, const_p_allocation_callbacks &AllocationCallbacks) Result {
	return C.ma_vfs_open_and_read_file(p_vfs, const_p_file_path, pp_data, p_size, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_default_vfs {
pub mut:
	cb                  VfsCallbacks
	allocationCallbacks AllocationCallbacks // Only used for the wchar_t version of open() on non-Windows platforms.
}

pub type DefaultVfs = C.ma_default_vfs

// C: `MA_API ma_result ma_default_vfs_init(ma_default_vfs* pVFS, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_default_vfs_init(p_vfs &DefaultVfs, const_p_allocation_callbacks &AllocationCallbacks) Result

// default_vfs_init is currently undocumented
pub fn default_vfs_init(p_vfs &DefaultVfs, const_p_allocation_callbacks &AllocationCallbacks) Result {
	return C.ma_default_vfs_init(p_vfs, const_p_allocation_callbacks)
}

// ReadProc is currently undocumented
// C: typedef ma_result (* ma_read_proc)(void* pUserData, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);
pub type ReadProc = fn (p_user_data voidptr, p_buffer_out voidptr, bytes_to_read usize, p_bytes_read &usize) Result

// SeekProc is currently undocumented
// C: typedef ma_result (* ma_seek_proc)(void* pUserData, ma_int64 offset, ma_seek_origin origin);
pub type SeekProc = fn (p_user_data voidptr, offset i64, origin SeekOrigin) Result

// TellProc is currently undocumented
// C: typedef ma_result (* ma_tell_proc)(void* pUserData, ma_int64* pCursor);
pub type TellProc = fn (p_user_data voidptr, p_cursor &i64) Result

// EncodingFormat is C.ma_encoding_format
pub enum EncodingFormat {
	unknown = C.ma_encoding_format_unknown // 0,
	wav     = C.ma_encoding_format_wav
	flac    = C.ma_encoding_format_flac
	mp3     = C.ma_encoding_format_mp3
	vorbis  = C.ma_encoding_format_vorbis
}

@[typedef]
struct C.ma_decoding_backend_config {
pub mut:
	preferredFormat Format
	seekPointCount  u32 // Set to > 0 to generate a seektable if the decoding backend supports it.
}

pub type DecodingBackendConfig = C.ma_decoding_backend_config

// C: `MA_API ma_decoding_backend_config ma_decoding_backend_config_init(ma_format preferredFormat, ma_uint32 seekPointCount)`
fn C.ma_decoding_backend_config_init(preferred_format Format, seek_point_count u32) DecodingBackendConfig

// decoding_backend_config_init is currently undocumented
pub fn decoding_backend_config_init(preferred_format Format, seek_point_count u32) DecodingBackendConfig {
	return C.ma_decoding_backend_config_init(preferred_format, seek_point_count)
}

@[typedef]
struct C.ma_decoding_backend_vtable {
pub mut:
	onInit       fn (p_user_data voidptr, on_read ReadProc, on_seek SeekProc, on_tell TellProc, p_read_seek_tell_user_data voidptr, const_p_config &DecodingBackendConfig, const_p_allocation_callbacks &AllocationCallbacks, pp_backend voidptr) Result // onInit
	onInitFile   fn (p_user_data voidptr, const_p_file_path &char, const_p_config &DecodingBackendConfig, const_p_allocation_callbacks &AllocationCallbacks, pp_backend voidptr) Result               // onInitFile Optional.
	onInitFileW  fn (p_user_data voidptr, const_p_file_path &u16, const_p_config &DecodingBackendConfig, const_p_allocation_callbacks &AllocationCallbacks, pp_backend voidptr) Result                // onInitFileW Optional.
	onInitMemory fn (p_user_data voidptr, const_p_data voidptr, data_size usize, const_p_config &DecodingBackendConfig, const_p_allocation_callbacks &AllocationCallbacks, pp_backend voidptr) Result // onInitMemory)(void* Optional.
	onUninit     fn (p_user_data voidptr, p_backend voidptr, const_p_allocation_callbacks &AllocationCallbacks) // onUninit
}

pub type DecodingBackendVtable = C.ma_decoding_backend_vtable

// DecoderReadProc returns the number of bytes read.
// C: typedef ma_result (* ma_decoder_read_proc)(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);
pub type DecoderReadProc = fn (p_decoder &Decoder, p_buffer_out voidptr, bytes_to_read usize, p_bytes_read &usize) Result

// DecoderSeekProc is currently undocumented
// C: typedef ma_result (* ma_decoder_seek_proc)(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin);
pub type DecoderSeekProc = fn (p_decoder &Decoder, byte_offset i64, origin SeekOrigin) Result

// DecoderTellProc is currently undocumented
// C: typedef ma_result (* ma_decoder_tell_proc)(ma_decoder* pDecoder, ma_int64* pCursor);
pub type DecoderTellProc = fn (p_decoder &Decoder, p_cursor &i64) Result

@[typedef]
struct C.ma_decoder_config {
pub mut:
	format                 Format // Set to 0 or ma_format_unknown to use the stream's internal format.
	channels               u32    // Set to 0 to use the stream's internal channels.
	sampleRate             u32    // Set to 0 to use the stream's internal sample rate.
	pChannelMap            &u8 = unsafe { nil }
	channelMixMode         ChannelMixMode
	ditherMode             DitherMode
	resampling             ResamplerConfig
	allocationCallbacks    AllocationCallbacks
	encodingFormat         EncodingFormat
	seekPointCount         u32 // When set to > 0, specifies the number of seek points to use for the generation of a seek table. Not all decoding backends support this.
	ppCustomBackendVTables &&DecodingBackendVtable = unsafe { nil }
	customBackendCount     u32
	pCustomBackendUserData voidptr
}

pub type DecoderConfig = C.ma_decoder_config

@[typedef]
struct C.ma_decoder {
pub mut:
	ds                     DataSourceBase
	pBackend               voidptr // The decoding backend we'll be pulling data from.
	pBackendVTable         &DecodingBackendVtable = unsafe { nil } // The vtable for the decoding backend. This needs to be stored so we can access the onUninit() callback.
	pBackendUserData       voidptr
	onRead                 DecoderReadProc
	onSeek                 DecoderSeekProc
	onTell                 DecoderTellProc
	pUserData              voidptr
	readPointerInPCMFrames u64 // In output sample rate. Used for keeping track of how many frames are available for decoding.
	outputFormat           Format
	outputChannels         u32
	outputSampleRate       u32
	converter              DataConverter // Data conversion is achieved by running frames through this.
	pInputCache            voidptr       // In input format. Can be null if it's not needed.
	inputCacheCap          u64           // The capacity of the input cache.
	inputCacheConsumed     u64           // The number of frames that have been consumed in the cache. Used for determining the next valid frame.
	inputCacheRemaining    u64           // The number of valid frames remaining in the cahce.
	allocationCallbacks    AllocationCallbacks
	// TODO// union {
	//  struct {
	//  ma_vfs* pVFS; ma_vfs_file file; } vfs
	// TODO// struct {
	//  const ma_uint8*; pData size_t; dataSize size_t; currentReadPos }; memory
}

pub type Decoder = C.ma_decoder

// C: `MA_API ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate)`
fn C.ma_decoder_config_init(output_format Format, output_channels u32, output_sample_rate u32) DecoderConfig

// decoder_config_init is currently undocumented
pub fn decoder_config_init(output_format Format, output_channels u32, output_sample_rate u32) DecoderConfig {
	return C.ma_decoder_config_init(output_format, output_channels, output_sample_rate)
}

// C: `MA_API ma_decoder_config ma_decoder_config_init_default(void)`
fn C.ma_decoder_config_init_default() DecoderConfig

// decoder_config_init_default is currently undocumented
pub fn decoder_config_init_default() DecoderConfig {
	return C.ma_decoder_config_init_default()
}

// C: `MA_API ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init(on_read DecoderReadProc, on_seek DecoderSeekProc, p_user_data voidptr, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init is currently undocumented
pub fn decoder_init(on_read DecoderReadProc, on_seek DecoderSeekProc, p_user_data voidptr, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init(on_read, on_seek, p_user_data, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init_memory(const_p_data voidptr, data_size usize, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init_memory is currently undocumented
pub fn decoder_init_memory(const_p_data voidptr, data_size usize, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init_memory(const_p_data, data_size, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init_vfs(p_vfs voidptr, const_p_file_path &char, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init_vfs is currently undocumented
pub fn decoder_init_vfs(p_vfs voidptr, const_p_file_path &char, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init_vfs(p_vfs, const_p_file_path, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_init_vfs_w(ma_vfs* pVFS, const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init_vfs_w(p_vfs voidptr, const_p_file_path &u16, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init_vfs_w is currently undocumented
pub fn decoder_init_vfs_w(p_vfs voidptr, const_p_file_path &u16, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init_vfs_w(p_vfs, const_p_file_path, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init_file(const_p_file_path &char, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init_file is currently undocumented
pub fn decoder_init_file(const_p_file_path &char, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init_file(const_p_file_path, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)`
fn C.ma_decoder_init_file_w(const_p_file_path &u16, const_p_config &DecoderConfig, p_decoder &Decoder) Result

// decoder_init_file_w is currently undocumented
pub fn decoder_init_file_w(const_p_file_path &u16, const_p_config &DecoderConfig, p_decoder &Decoder) Result {
	return C.ma_decoder_init_file_w(const_p_file_path, const_p_config, p_decoder)
}

// C: `MA_API ma_result ma_decoder_uninit(ma_decoder* pDecoder)`
fn C.ma_decoder_uninit(p_decoder &Decoder) Result

// decoder_uninit uninitializes a decoder.
pub fn decoder_uninit(p_decoder &Decoder) Result {
	return C.ma_decoder_uninit(p_decoder)
}

// C: `MA_API ma_result ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_decoder_read_pcm_frames(p_decoder &Decoder, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// decoder_read_pcm_frames reads PCM frames from the given decoder.
//
// This is not thread safe without your own synchronization.
pub fn decoder_read_pcm_frames(p_decoder &Decoder, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_decoder_read_pcm_frames(p_decoder, p_frames_out, frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex)`
fn C.ma_decoder_seek_to_pcm_frame(p_decoder &Decoder, frame_index u64) Result

// decoder_seek_to_pcm_frame seeks to a PCM frame based on it's absolute index.
//
// This is not thread safe without your own synchronization.
pub fn decoder_seek_to_pcm_frame(p_decoder &Decoder, frame_index u64) Result {
	return C.ma_decoder_seek_to_pcm_frame(p_decoder, frame_index)
}

// C: `MA_API ma_result ma_decoder_get_data_format(ma_decoder* pDecoder, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_decoder_get_data_format(p_decoder &Decoder, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// decoder_get_data_format retrieves the decoder's output data format.
pub fn decoder_get_data_format(p_decoder &Decoder, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_decoder_get_data_format(p_decoder, &p_format, p_channels, p_sample_rate,
		p_channel_map, channel_map_cap)
}

// C: `MA_API ma_result ma_decoder_get_cursor_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pCursor)`
fn C.ma_decoder_get_cursor_in_pcm_frames(p_decoder &Decoder, p_cursor &u64) Result

// decoder_get_cursor_in_pcm_frames retrieves the current position of the read cursor in PCM frames.
pub fn decoder_get_cursor_in_pcm_frames(p_decoder &Decoder, p_cursor &u64) Result {
	return C.ma_decoder_get_cursor_in_pcm_frames(p_decoder, p_cursor)
}

// C: `MA_API ma_result ma_decoder_get_length_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pLength)`
fn C.ma_decoder_get_length_in_pcm_frames(p_decoder &Decoder, p_length &u64) Result

// decoder_get_length_in_pcm_frames retrieves the length of the decoder in PCM frames.
//
// Do not call this on streams of an undefined length, such as internet radio.
//
// If the length is unknown or an error occurs, 0 will be returned.
//
// This will always return 0 for Vorbis decoders. This is due to a limitation with stb_vorbis in push mode which is what miniaudio
// uses internally.
//
// For MP3's, this will decode the entire file. Do not call this in time critical scenarios.
//
// This function is not thread safe without your own synchronization.
pub fn decoder_get_length_in_pcm_frames(p_decoder &Decoder, p_length &u64) Result {
	return C.ma_decoder_get_length_in_pcm_frames(p_decoder, p_length)
}

// C: `MA_API ma_result ma_decoder_get_available_frames(ma_decoder* pDecoder, ma_uint64* pAvailableFrames)`
fn C.ma_decoder_get_available_frames(p_decoder &Decoder, p_available_frames &u64) Result

// decoder_get_available_frames retrieves the number of frames that can be read before reaching the end.
//
// This calls `ma_decoder_get_length_in_pcm_frames()` so you need to be aware of the rules for that function, in
// particular ensuring you do not call it on streams of an undefined length, such as internet radio.
//
// If the total length of the decoder cannot be retrieved, such as with Vorbis decoders, `MA_NOT_IMPLEMENTED` will be
// returned.
pub fn decoder_get_available_frames(p_decoder &Decoder, p_available_frames &u64) Result {
	return C.ma_decoder_get_available_frames(p_decoder, p_available_frames)
}

// C: `MA_API ma_result ma_decode_from_vfs(ma_vfs* pVFS, const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)`
fn C.ma_decode_from_vfs(p_vfs voidptr, const_p_file_path &char, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result

// decode_from_vfs helpers for opening and decoding a file into a heap allocated block of memory. Free the returned pointer with ma_free(). On input,
// pConfig should be set to what you want. On output it will be set to what you got.
pub fn decode_from_vfs(p_vfs voidptr, const_p_file_path &char, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result {
	return C.ma_decode_from_vfs(p_vfs, const_p_file_path, p_config, p_frame_count_out,
		pp_pcm_frames_out)
}

// C: `MA_API ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)`
fn C.ma_decode_file(const_p_file_path &char, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result

// decode_file is currently undocumented
pub fn decode_file(const_p_file_path &char, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result {
	return C.ma_decode_file(const_p_file_path, p_config, p_frame_count_out, pp_pcm_frames_out)
}

// C: `MA_API ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)`
fn C.ma_decode_memory(const_p_data voidptr, data_size usize, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result

// decode_memory is currently undocumented
pub fn decode_memory(const_p_data voidptr, data_size usize, p_config &DecoderConfig, p_frame_count_out &u64, pp_pcm_frames_out voidptr) Result {
	return C.ma_decode_memory(const_p_data, data_size, p_config, p_frame_count_out, pp_pcm_frames_out)
}

// EncoderWriteProc is currently undocumented
// C: typedef ma_result (* ma_encoder_write_proc)           (ma_encoder* pEncoder, const void* pBufferIn, size_t bytesToWrite, size_t* pBytesWritten);
pub type EncoderWriteProc = fn (p_encoder &Encoder, const_p_buffer_in voidptr, bytes_to_write usize, p_bytes_written &usize) Result

// EncoderSeekProc is currently undocumented
// C: typedef ma_result (* ma_encoder_seek_proc)            (ma_encoder* pEncoder, ma_int64 offset, ma_seek_origin origin);
pub type EncoderSeekProc = fn (p_encoder &Encoder, offset i64, origin SeekOrigin) Result

// EncoderInitProc is currently undocumented
// C: typedef ma_result (* ma_encoder_init_proc)            (ma_encoder* pEncoder);
pub type EncoderInitProc = fn (p_encoder &Encoder) Result

// EncoderUninitProc is currently undocumented
// C: typedef void      (* ma_encoder_uninit_proc)          (ma_encoder* pEncoder);
pub type EncoderUninitProc = fn (p_encoder &Encoder)

// EncoderWritePcmFramesProc is currently undocumented
// C: typedef ma_result (* ma_encoder_write_pcm_frames_proc)(ma_encoder* pEncoder, const void* pFramesIn, ma_uint64 frameCount, ma_uint64* pFramesWritten);
pub type EncoderWritePcmFramesProc = fn (p_encoder &Encoder, const_p_frames_in voidptr, frame_count u64, p_frames_written &u64) Result

@[typedef]
struct C.ma_encoder_config {
pub mut:
	encodingFormat      EncodingFormat
	format              Format
	channels            u32
	sampleRate          u32
	allocationCallbacks AllocationCallbacks
}

pub type EncoderConfig = C.ma_encoder_config

// C: `MA_API ma_encoder_config ma_encoder_config_init(ma_encoding_format encodingFormat, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)`
fn C.ma_encoder_config_init(encoding_format EncodingFormat, format Format, channels u32, sample_rate u32) EncoderConfig

// encoder_config_init is currently undocumented
pub fn encoder_config_init(encoding_format EncodingFormat, format Format, channels u32, sample_rate u32) EncoderConfig {
	return C.ma_encoder_config_init(encoding_format, format, channels, sample_rate)
}

@[typedef]
struct C.ma_encoder {
pub mut:
	config           EncoderConfig
	onWrite          EncoderWriteProc
	onSeek           EncoderSeekProc
	onInit           EncoderInitProc
	onUninit         EncoderUninitProc
	onWritePCMFrames EncoderWritePcmFramesProc
	pUserData        voidptr
	pInternalEncoder voidptr // <-- The drwav/drflac/stb_vorbis/etc. objects.
	// TODO// union {
	//  struct {
	//  ma_vfs* pVFS; ma_vfs_file file; } vfs; } data
}

pub type Encoder = C.ma_encoder

// C: `MA_API ma_result ma_encoder_init(ma_encoder_write_proc onWrite, ma_encoder_seek_proc onSeek, void* pUserData, const ma_encoder_config* pConfig, ma_encoder* pEncoder)`
fn C.ma_encoder_init(on_write EncoderWriteProc, on_seek EncoderSeekProc, p_user_data voidptr, const_p_config &EncoderConfig, p_encoder &Encoder) Result

// encoder_init is currently undocumented
pub fn encoder_init(on_write EncoderWriteProc, on_seek EncoderSeekProc, p_user_data voidptr, const_p_config &EncoderConfig, p_encoder &Encoder) Result {
	return C.ma_encoder_init(on_write, on_seek, p_user_data, const_p_config, p_encoder)
}

// C: `MA_API ma_result ma_encoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_encoder_config* pConfig, ma_encoder* pEncoder)`
fn C.ma_encoder_init_vfs(p_vfs voidptr, const_p_file_path &char, const_p_config &EncoderConfig, p_encoder &Encoder) Result

// encoder_init_vfs is currently undocumented
pub fn encoder_init_vfs(p_vfs voidptr, const_p_file_path &char, const_p_config &EncoderConfig, p_encoder &Encoder) Result {
	return C.ma_encoder_init_vfs(p_vfs, const_p_file_path, const_p_config, p_encoder)
}

// C: `MA_API ma_result ma_encoder_init_vfs_w(ma_vfs* pVFS, const wchar_t* pFilePath, const ma_encoder_config* pConfig, ma_encoder* pEncoder)`
fn C.ma_encoder_init_vfs_w(p_vfs voidptr, const_p_file_path &u16, const_p_config &EncoderConfig, p_encoder &Encoder) Result

// encoder_init_vfs_w is currently undocumented
pub fn encoder_init_vfs_w(p_vfs voidptr, const_p_file_path &u16, const_p_config &EncoderConfig, p_encoder &Encoder) Result {
	return C.ma_encoder_init_vfs_w(p_vfs, const_p_file_path, const_p_config, p_encoder)
}

// C: `MA_API ma_result ma_encoder_init_file(const char* pFilePath, const ma_encoder_config* pConfig, ma_encoder* pEncoder)`
fn C.ma_encoder_init_file(const_p_file_path &char, const_p_config &EncoderConfig, p_encoder &Encoder) Result

// encoder_init_file is currently undocumented
pub fn encoder_init_file(const_p_file_path &char, const_p_config &EncoderConfig, p_encoder &Encoder) Result {
	return C.ma_encoder_init_file(const_p_file_path, const_p_config, p_encoder)
}

// C: `MA_API ma_result ma_encoder_init_file_w(const wchar_t* pFilePath, const ma_encoder_config* pConfig, ma_encoder* pEncoder)`
fn C.ma_encoder_init_file_w(const_p_file_path &u16, const_p_config &EncoderConfig, p_encoder &Encoder) Result

// encoder_init_file_w is currently undocumented
pub fn encoder_init_file_w(const_p_file_path &u16, const_p_config &EncoderConfig, p_encoder &Encoder) Result {
	return C.ma_encoder_init_file_w(const_p_file_path, const_p_config, p_encoder)
}

// C: `MA_API void ma_encoder_uninit(ma_encoder* pEncoder)`
fn C.ma_encoder_uninit(p_encoder &Encoder)

// encoder_uninit is currently undocumented
pub fn encoder_uninit(p_encoder &Encoder) {
	C.ma_encoder_uninit(p_encoder)
}

// C: `MA_API ma_result ma_encoder_write_pcm_frames(ma_encoder* pEncoder, const void* pFramesIn, ma_uint64 frameCount, ma_uint64* pFramesWritten)`
fn C.ma_encoder_write_pcm_frames(p_encoder &Encoder, const_p_frames_in voidptr, frame_count u64, p_frames_written &u64) Result

// encoder_write_pcm_frames is currently undocumented
pub fn encoder_write_pcm_frames(p_encoder &Encoder, const_p_frames_in voidptr, frame_count u64, p_frames_written &u64) Result {
	return C.ma_encoder_write_pcm_frames(p_encoder, const_p_frames_in, frame_count, p_frames_written)
}

// WaveformType is C.ma_waveform_type
pub enum WaveformType {
	sine     = C.ma_waveform_type_sine
	square   = C.ma_waveform_type_square
	triangle = C.ma_waveform_type_triangle
	sawtooth = C.ma_waveform_type_sawtooth
}

@[typedef]
struct C.ma_waveform_config {
pub mut:
	format     Format
	channels   u32
	sampleRate u32
	@type      WaveformType
	amplitude  f64
	frequency  f64
}

pub type WaveformConfig = C.ma_waveform_config

// C: `MA_API ma_waveform_config ma_waveform_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, ma_waveform_type type, double amplitude, double frequency)`
fn C.ma_waveform_config_init(format Format, channels u32, sample_rate u32, @type WaveformType, amplitude f64, frequency f64) WaveformConfig

// waveform_config_init is currently undocumented
pub fn waveform_config_init(format Format, channels u32, sample_rate u32, @type WaveformType, amplitude f64, frequency f64) WaveformConfig {
	return C.ma_waveform_config_init(format, channels, sample_rate, @type, amplitude,
		frequency)
}

@[typedef]
struct C.ma_waveform {
pub mut:
	ds      DataSourceBase
	config  WaveformConfig
	advance f64
	time    f64
}

pub type Waveform = C.ma_waveform

// C: `MA_API ma_result ma_waveform_init(const ma_waveform_config* pConfig, ma_waveform* pWaveform)`
fn C.ma_waveform_init(const_p_config &WaveformConfig, p_waveform &Waveform) Result

// waveform_init is currently undocumented
pub fn waveform_init(const_p_config &WaveformConfig, p_waveform &Waveform) Result {
	return C.ma_waveform_init(const_p_config, p_waveform)
}

// C: `MA_API void ma_waveform_uninit(ma_waveform* pWaveform)`
fn C.ma_waveform_uninit(p_waveform &Waveform)

// waveform_uninit is currently undocumented
pub fn waveform_uninit(p_waveform &Waveform) {
	C.ma_waveform_uninit(p_waveform)
}

// C: `MA_API ma_result ma_waveform_read_pcm_frames(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_waveform_read_pcm_frames(p_waveform &Waveform, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// waveform_read_pcm_frames is currently undocumented
pub fn waveform_read_pcm_frames(p_waveform &Waveform, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_waveform_read_pcm_frames(p_waveform, p_frames_out, frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_waveform_seek_to_pcm_frame(ma_waveform* pWaveform, ma_uint64 frameIndex)`
fn C.ma_waveform_seek_to_pcm_frame(p_waveform &Waveform, frame_index u64) Result

// waveform_seek_to_pcm_frame is currently undocumented
pub fn waveform_seek_to_pcm_frame(p_waveform &Waveform, frame_index u64) Result {
	return C.ma_waveform_seek_to_pcm_frame(p_waveform, frame_index)
}

// C: `MA_API ma_result ma_waveform_set_amplitude(ma_waveform* pWaveform, double amplitude)`
fn C.ma_waveform_set_amplitude(p_waveform &Waveform, amplitude f64) Result

// waveform_set_amplitude is currently undocumented
pub fn waveform_set_amplitude(p_waveform &Waveform, amplitude f64) Result {
	return C.ma_waveform_set_amplitude(p_waveform, amplitude)
}

// C: `MA_API ma_result ma_waveform_set_frequency(ma_waveform* pWaveform, double frequency)`
fn C.ma_waveform_set_frequency(p_waveform &Waveform, frequency f64) Result

// waveform_set_frequency is currently undocumented
pub fn waveform_set_frequency(p_waveform &Waveform, frequency f64) Result {
	return C.ma_waveform_set_frequency(p_waveform, frequency)
}

// C: `MA_API ma_result ma_waveform_set_type(ma_waveform* pWaveform, ma_waveform_type type)`
fn C.ma_waveform_set_type(p_waveform &Waveform, @type WaveformType) Result

// waveform_set_type is currently undocumented
pub fn waveform_set_type(p_waveform &Waveform, @type WaveformType) Result {
	return C.ma_waveform_set_type(p_waveform, @type)
}

// C: `MA_API ma_result ma_waveform_set_sample_rate(ma_waveform* pWaveform, ma_uint32 sampleRate)`
fn C.ma_waveform_set_sample_rate(p_waveform &Waveform, sample_rate u32) Result

// waveform_set_sample_rate is currently undocumented
pub fn waveform_set_sample_rate(p_waveform &Waveform, sample_rate u32) Result {
	return C.ma_waveform_set_sample_rate(p_waveform, sample_rate)
}

// NoiseType is C.ma_noise_type
pub enum NoiseType {
	white    = C.ma_noise_type_white
	pink     = C.ma_noise_type_pink
	brownian = C.ma_noise_type_brownian
}

@[typedef]
struct C.ma_noise_config {
pub mut:
	format            Format
	channels          u32
	@type             NoiseType
	seed              int
	amplitude         f64
	duplicateChannels u32
}

pub type NoiseConfig = C.ma_noise_config

// C: `MA_API ma_noise_config ma_noise_config_init(ma_format format, ma_uint32 channels, ma_noise_type type, ma_int32 seed, double amplitude)`
fn C.ma_noise_config_init(format Format, channels u32, @type NoiseType, seed int, amplitude f64) NoiseConfig

// noise_config_init is currently undocumented
pub fn noise_config_init(format Format, channels u32, @type NoiseType, seed int, amplitude f64) NoiseConfig {
	return C.ma_noise_config_init(format, channels, @type, seed, amplitude)
}

@[typedef]
struct C.ma_noise {
pub mut:
	ds     DataSourceVtable
	config NoiseConfig
	lcg    Lcg
	// TODO// union {
	//  struct {
	//  double** bin; double* accumulation; ma_uint32* counter; } pink
	// TODO// struct {
	//  double* accumulation; } brownian; } state
	_pHeap    voidptr
	_ownsHeap u32
}

pub type Noise = C.ma_noise

// C: `MA_API ma_result ma_noise_get_heap_size(const ma_noise_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_noise_get_heap_size(const_p_config &NoiseConfig, p_heap_size_in_bytes &usize) Result

// noise_get_heap_size is currently undocumented
pub fn noise_get_heap_size(const_p_config &NoiseConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_noise_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_noise_init_preallocated(const ma_noise_config* pConfig, void* pHeap, ma_noise* pNoise)`
fn C.ma_noise_init_preallocated(const_p_config &NoiseConfig, p_heap voidptr, p_noise &Noise) Result

// noise_init_preallocated is currently undocumented
pub fn noise_init_preallocated(const_p_config &NoiseConfig, p_heap voidptr, p_noise &Noise) Result {
	return C.ma_noise_init_preallocated(const_p_config, p_heap, p_noise)
}

// C: `MA_API ma_result ma_noise_init(const ma_noise_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_noise* pNoise)`
fn C.ma_noise_init(const_p_config &NoiseConfig, const_p_allocation_callbacks &AllocationCallbacks, p_noise &Noise) Result

// noise_init is currently undocumented
pub fn noise_init(const_p_config &NoiseConfig, const_p_allocation_callbacks &AllocationCallbacks, p_noise &Noise) Result {
	return C.ma_noise_init(const_p_config, const_p_allocation_callbacks, p_noise)
}

// C: `MA_API void ma_noise_uninit(ma_noise* pNoise, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_noise_uninit(p_noise &Noise, const_p_allocation_callbacks &AllocationCallbacks)

// noise_uninit is currently undocumented
pub fn noise_uninit(p_noise &Noise, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_noise_uninit(p_noise, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_noise_read_pcm_frames(ma_noise* pNoise, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_noise_read_pcm_frames(p_noise &Noise, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// noise_read_pcm_frames is currently undocumented
pub fn noise_read_pcm_frames(p_noise &Noise, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_noise_read_pcm_frames(p_noise, p_frames_out, frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_noise_set_amplitude(ma_noise* pNoise, double amplitude)`
fn C.ma_noise_set_amplitude(p_noise &Noise, amplitude f64) Result

// noise_set_amplitude is currently undocumented
pub fn noise_set_amplitude(p_noise &Noise, amplitude f64) Result {
	return C.ma_noise_set_amplitude(p_noise, amplitude)
}

// C: `MA_API ma_result ma_noise_set_seed(ma_noise* pNoise, ma_int32 seed)`
fn C.ma_noise_set_seed(p_noise &Noise, seed int) Result

// noise_set_seed is currently undocumented
pub fn noise_set_seed(p_noise &Noise, seed int) Result {
	return C.ma_noise_set_seed(p_noise, seed)
}

// C: `MA_API ma_result ma_noise_set_type(ma_noise* pNoise, ma_noise_type type)`
fn C.ma_noise_set_type(p_noise &Noise, @type NoiseType) Result

// noise_set_type is currently undocumented
pub fn noise_set_type(p_noise &Noise, @type NoiseType) Result {
	return C.ma_noise_set_type(p_noise, @type)
}

/*
TODO Non-numerical: #define MA_NO_RESOURCE_MANAGER
*/

// ResourceManagerDataSourceFlags is C.ma_resource_manager_data_source_flags
pub enum ResourceManagerDataSourceFlags {
	stream         = C.MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM         // 0x00000001, When set, does not load the entire data source in memory. Disk I/O will happen on job threads.
	decode         = C.MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE         // 0x00000002, Decode data before storing in memory. When set, decoding is done at the resource manager level rather than the mixing thread. Results in faster mixing, but higher memory usage.
	async          = C.MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC          // 0x00000004, When set, the resource manager will load the data source asynchronously.
	wait_init      = C.MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT      // 0x00000008, When set, waits for initialization of the underlying data source before returning from ma_resource_manager_data_source_init().
	unknown_length = C.MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH // 0x00000010, Gives the resource manager a hint that the length of the data source is unknown and calling `ma_data_source_get_length_in_pcm_frames()` should be avoided.
}

@[typedef]
struct C.ma_resource_manager_pipeline_stage_notification {
pub mut:
	pNotification voidptr
	pFence        &Fence = unsafe { nil }
}

pub type ResourceManagerPipelineStageNotification = C.ma_resource_manager_pipeline_stage_notification

@[typedef]
struct C.ma_resource_manager_pipeline_notifications {
pub mut:
	init ResourceManagerPipelineStageNotification // Initialization of the decoder.
	done ResourceManagerPipelineStageNotification // Decoding fully completed.
}

pub type ResourceManagerPipelineNotifications = C.ma_resource_manager_pipeline_notifications

// C: `MA_API ma_resource_manager_pipeline_notifications ma_resource_manager_pipeline_notifications_init(void)`
fn C.ma_resource_manager_pipeline_notifications_init() ResourceManagerPipelineNotifications

// resource_manager_pipeline_notifications_init is currently undocumented
pub fn resource_manager_pipeline_notifications_init() ResourceManagerPipelineNotifications {
	return C.ma_resource_manager_pipeline_notifications_init()
}

/*
TODO Non-numerical: #define ma_resource_manager_job                         ma_job
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_init                    ma_job_init
*/

/*
TODO Non-numerical: #define MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_FLAG_NON_BLOCKING MA_JOB_QUEUE_FLAG_NON_BLOCKING
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_config            ma_job_queue_config
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_config_init       ma_job_queue_config_init
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue                   ma_job_queue
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_get_heap_size     ma_job_queue_get_heap_size
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_init_preallocated ma_job_queue_init_preallocated
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_init              ma_job_queue_init
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_uninit            ma_job_queue_uninit
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_post              ma_job_queue_post
*/

/*
TODO Non-numerical: #define ma_resource_manager_job_queue_next              ma_job_queue_next
*/

// Maximum job thread count will be restricted to this, but this may be removed later and replaced with a heap allocation thereby removing any limitation.
pub const resource_manager_max_job_thread_count = 64

// ResourceManagerFlags is C.ma_resource_manager_flags
pub enum ResourceManagerFlags {
	// 0x00000001, Indicates ma_resource_manager_next_job() should not block. Only valid when the job thread count is 0.
	non_blocking = C.MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING
	// 0x00000002, Disables any kind of multithreading. Implicitly enables MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING.
	no_threading = C.MA_RESOURCE_MANAGER_FLAG_NO_THREADING
}

@[typedef]
struct C.ma_resource_manager_data_source_config {
pub mut:
	pFilePath                   &char = unsafe { nil }
	pFilePathW                  &u16  = unsafe { nil }
	pNotifications              &ResourceManagerPipelineNotifications = unsafe { nil }
	initialSeekPointInPCMFrames u64
	rangeBegInPCMFrames         u64
	rangeEndInPCMFrames         u64
	loopPointBegInPCMFrames     u64
	loopPointEndInPCMFrames     u64
	isLooping                   u32
	flags                       u32
}

pub type ResourceManagerDataSourceConfig = C.ma_resource_manager_data_source_config

// C: `MA_API ma_resource_manager_data_source_config ma_resource_manager_data_source_config_init(void)`
fn C.ma_resource_manager_data_source_config_init() ResourceManagerDataSourceConfig

// resource_manager_data_source_config_init is currently undocumented
pub fn resource_manager_data_source_config_init() ResourceManagerDataSourceConfig {
	return C.ma_resource_manager_data_source_config_init()
}

// ResourceManagerDataSupplyType is C.ma_resource_manager_data_supply_type
pub enum ResourceManagerDataSupplyType {
	unknown       = C.ma_resource_manager_data_supply_type_unknown       // 0, Used for determining whether or the data supply has been initialized.
	encoded       = C.ma_resource_manager_data_supply_type_encoded       // Data supply is an encoded buffer. Connector is ma_decoder.
	decoded       = C.ma_resource_manager_data_supply_type_decoded       // Data supply is a decoded buffer. Connector is ma_audio_buffer.
	decoded_paged = C.ma_resource_manager_data_supply_type_decoded_paged // Data supply is a linked list of decoded buffers. Connector is ma_paged_audio_buffer.
}

@[typedef]
struct C.ma_resource_manager_data_supply {
	// TODO MA_ATOMIC(4, ma_resource_manager_data_supply_type) type
	// TODO// union {
	//  struct {
	//  const void*; pData size_t; sizeInBytes }; encoded
	// TODO// struct {
	//  const void*; pData ma_uint64; totalFrameCount ma_uint64; decodedFrameCount ma_format; format ma_uint32; channels ma_uint32; sampleRate }; decoded
	// TODO// struct {
	//  ma_paged_audio_buffer_data data; ma_uint64 decodedFrameCount; ma_uint32 sampleRate; } decodedPaged; } backend
}

pub type ResourceManagerDataSupply = C.ma_resource_manager_data_supply

@[typedef]
struct C.ma_resource_manager_data_buffer_node {
pub mut:
	hashedName32 u32 // The hashed name. This is the key.
	refCount     u32
	// TODO MA_ATOMIC(4, ma_result) result
	// TODO MA_ATOMIC(4, ma_uint32) executionCounter
	// TODO MA_ATOMIC(4, ma_uint32) executionPointer
	isDataOwnedByResourceManager u32 // Set to true when the underlying data buffer was allocated the resource manager. Set to false if it is owned by the application (via ma_resource_manager_register_*()).
	data                         ResourceManagerDataSupply
	pParent                      &ResourceManagerDataBufferNode = unsafe { nil }
	pChildLo                     &ResourceManagerDataBufferNode = unsafe { nil }
	pChildHi                     &ResourceManagerDataBufferNode = unsafe { nil }
}

pub type ResourceManagerDataBufferNode = C.ma_resource_manager_data_buffer_node

@[typedef]
struct C.ma_resource_manager_data_buffer {
pub mut:
	ds               DataSourceBase // Base data source. A data buffer is a data source.
	pResourceManager &ResourceManager               = unsafe { nil } // A pointer to the resource manager that owns this buffer.
	pNode            &ResourceManagerDataBufferNode = unsafe { nil } // The data node. This is reference counted and is what supplies the data.
	flags            u32 // The flags that were passed used to initialize the buffer.
	// TODO MA_ATOMIC(4, ma_uint32) executionCounter
	// TODO MA_ATOMIC(4, ma_uint32) executionPointer
	seekTargetInPCMFrames  u64 // Only updated by the public API. Never written nor read from the job thread.
	seekToCursorOnNextRead u32 // On the next read we need to seek to the frame cursor.
	// TODO MA_ATOMIC(4, ma_result) result
	// TODO MA_ATOMIC(4, ma_bool32) isLooping
	isConnectorInitialized u32 // Used for asynchronous loading to ensure we don't try to initialize the connector multiple times while waiting for the node to fully load.
	// TODO// union {
	//  ma_decoder decoder; ma_audio_buffer buffer; ma_paged_audio_buffer pagedBuffer; /* Supply; type is; ma_resource_manager_data_supply_type_decoded_paged*/ }; connector
}

pub type ResourceManagerDataBuffer = C.ma_resource_manager_data_buffer

@[typedef]
struct C.ma_resource_manager_data_stream {
pub mut:
	ds                     DataSourceBase // Base data source. A data stream is a data source.
	pResourceManager       &ResourceManager = unsafe { nil } // A pointer to the resource manager that owns this data stream.
	flags                  u32     // The flags that were passed used to initialize the stream.
	decoder                Decoder // Used for filling pages with data. This is only ever accessed by the job thread. The public API should never touch this.
	isDecoderInitialized   u32     // Required for determining whether or not the decoder should be uninitialized in MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM.
	totalLengthInPCMFrames u64     // This is calculated when first loaded by the MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM.
	relativeCursor         u32     // The playback cursor, relative to the current page. Only ever accessed by the public API. Never accessed by the job thread.
	// TODO MA_ATOMIC(8, ma_uint64) absoluteCursor
	currentPageIndex u32 // Toggles between 0 and 1. Index 0 is the first half of pPageData. Index 1 is the second half. Only ever accessed by the public API. Never accessed by the job thread.
	// TODO MA_ATOMIC(4, ma_uint32) executionCounter
	// TODO MA_ATOMIC(4, ma_uint32) executionPointer
	// TODO MA_ATOMIC(4, ma_bool32) isLooping
	// Written by the job thread, read by the public API.

	pPageData voidptr // Buffer containing the decoded data of each page. Allocated once at initialization time.
	// TODO MA_ATOMIC(4, ma_uint32) pageFrameCount[2]
	// TODO MA_ATOMIC(4, ma_result) result
	// TODO MA_ATOMIC(4, ma_bool32) isDecoderAtEnd
	// TODO MA_ATOMIC(4, ma_bool32) isPageValid[2]
	// TODO MA_ATOMIC(4, ma_bool32) seekCounter
}

pub type ResourceManagerDataStream = C.ma_resource_manager_data_stream

@[typedef]
struct C.ma_resource_manager_data_source {
pub mut:
	// TODO// union {
	//  ma_resource_manager_data_buffer buffer; ma_resource_manager_data_stream stream; } backend
	flags u32 // The flags that were passed in to ma_resource_manager_data_source_init().
	// TODO MA_ATOMIC(4, ma_uint32) executionCounter
	// TODO MA_ATOMIC(4, ma_uint32) executionPointer
}

pub type ResourceManagerDataSource = C.ma_resource_manager_data_source

@[typedef]
struct C.ma_resource_manager_config {
pub mut:
	allocationCallbacks            AllocationCallbacks
	pLog                           &Log = unsafe { nil }
	decodedFormat                  Format // The decoded format to use. Set to ma_format_unknown (default) to use the file's native format.
	decodedChannels                u32    // The decoded channel count to use. Set to 0 (default) to use the file's native channel count.
	decodedSampleRate              u32    // the decoded sample rate to use. Set to 0 (default) to use the file's native sample rate.
	jobThreadCount                 u32    // Set to 0 if you want to self-manage your job threads. Defaults to 1.
	jobQueueCapacity               u32    // The maximum number of jobs that can fit in the queue at a time. Defaults to MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_CAPACITY. Cannot be zero.
	flags                          u32
	pVFS                           voidptr // Can be NULL in which case defaults will be used.
	ppCustomDecodingBackendVTables &&DecodingBackendVtable = unsafe { nil }
	customDecodingBackendCount     u32
	pCustomDecodingBackendUserData voidptr
}

pub type ResourceManagerConfig = C.ma_resource_manager_config

// C: `MA_API ma_resource_manager_config ma_resource_manager_config_init(void)`
fn C.ma_resource_manager_config_init() ResourceManagerConfig

// resource_manager_config_init is currently undocumented
pub fn resource_manager_config_init() ResourceManagerConfig {
	return C.ma_resource_manager_config_init()
}

@[typedef]
struct C.ma_resource_manager {
pub mut:
	config              ResourceManagerConfig
	pRootDataBufferNode &ResourceManagerDataBufferNode = unsafe { nil } // The root buffer in the binary tree.
	// TODO 	MA_NO_THREADING C.#ifndef // ma_mutex For synchronizing access to the data buffer binary tree.
	// TODO 	jobThreads [MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT]C.ma_thread // The threads for executing jobs.
	jobQueue   JobQueue   // Multi-consumer, multi-producer job queue for managing jobs for asynchronous decoding and streaming.
	defaultVFS DefaultVfs // Only used if a custom VFS is not specified.
	log        Log        // Only used if no log was specified in the config.
}

pub type ResourceManager = C.ma_resource_manager

// C: `MA_API ma_result ma_resource_manager_init(const ma_resource_manager_config* pConfig, ma_resource_manager* pResourceManager)`
fn C.ma_resource_manager_init(const_p_config &ResourceManagerConfig, p_resource_manager &ResourceManager) Result

// resource_manager_init is currently undocumented
pub fn resource_manager_init(const_p_config &ResourceManagerConfig, p_resource_manager &ResourceManager) Result {
	return C.ma_resource_manager_init(const_p_config, p_resource_manager)
}

// C: `MA_API void ma_resource_manager_uninit(ma_resource_manager* pResourceManager)`
fn C.ma_resource_manager_uninit(p_resource_manager &ResourceManager)

// resource_manager_uninit is currently undocumented
pub fn resource_manager_uninit(p_resource_manager &ResourceManager) {
	C.ma_resource_manager_uninit(p_resource_manager)
}

// C: `MA_API ma_log* ma_resource_manager_get_log(ma_resource_manager* pResourceManager)`
fn C.ma_resource_manager_get_log(p_resource_manager &ResourceManager) &Log

// resource_manager_get_log is currently undocumented
pub fn resource_manager_get_log(p_resource_manager &ResourceManager) &Log {
	return C.ma_resource_manager_get_log(p_resource_manager)
}

// C: `MA_API ma_result ma_resource_manager_register_file(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags)`
fn C.ma_resource_manager_register_file(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32) Result

// resource_manager_register_file is currently undocumented
pub fn resource_manager_register_file(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32) Result {
	return C.ma_resource_manager_register_file(p_resource_manager, const_p_file_path,
		flags)
}

// C: `MA_API ma_result ma_resource_manager_register_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags)`
fn C.ma_resource_manager_register_file_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32) Result

// resource_manager_register_file_w is currently undocumented
pub fn resource_manager_register_file_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32) Result {
	return C.ma_resource_manager_register_file_w(p_resource_manager, const_p_file_path,
		flags)
}

// C: `MA_API ma_result ma_resource_manager_register_decoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate);/* Does not copy. Increments the reference count if already exists and returns MA_SUCCESS. */`
fn C.ma_resource_manager_register_decoded_data(p_resource_manager &ResourceManager, const_p_name &char, const_p_data voidptr, frame_count u64, format Format, channels u32, sample_rate u32) Result

// resource_manager_register_decoded_data does not copy. Increments the reference count if already exists and returns MA_SUCCESS.
pub fn resource_manager_register_decoded_data(p_resource_manager &ResourceManager, const_p_name &char, const_p_data voidptr, frame_count u64, format Format, channels u32, sample_rate u32) Result {
	return C.ma_resource_manager_register_decoded_data(p_resource_manager, const_p_name,
		const_p_data, frame_count, format, channels, sample_rate)
}

// C: `MA_API ma_result ma_resource_manager_register_decoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)`
fn C.ma_resource_manager_register_decoded_data_w(p_resource_manager &ResourceManager, const_p_name &u16, const_p_data voidptr, frame_count u64, format Format, channels u32, sample_rate u32) Result

// resource_manager_register_decoded_data_w is currently undocumented
pub fn resource_manager_register_decoded_data_w(p_resource_manager &ResourceManager, const_p_name &u16, const_p_data voidptr, frame_count u64, format Format, channels u32, sample_rate u32) Result {
	return C.ma_resource_manager_register_decoded_data_w(p_resource_manager, const_p_name,
		const_p_data, frame_count, format, channels, sample_rate)
}

// C: `MA_API ma_result ma_resource_manager_register_encoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, size_t sizeInBytes);/* Does not copy. Increments the reference count if already exists and returns MA_SUCCESS. */`
fn C.ma_resource_manager_register_encoded_data(p_resource_manager &ResourceManager, const_p_name &char, const_p_data voidptr, size_in_bytes usize) Result

// resource_manager_register_encoded_data does not copy. Increments the reference count if already exists and returns MA_SUCCESS.
pub fn resource_manager_register_encoded_data(p_resource_manager &ResourceManager, const_p_name &char, const_p_data voidptr, size_in_bytes usize) Result {
	return C.ma_resource_manager_register_encoded_data(p_resource_manager, const_p_name,
		const_p_data, size_in_bytes)
}

// C: `MA_API ma_result ma_resource_manager_register_encoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, size_t sizeInBytes)`
fn C.ma_resource_manager_register_encoded_data_w(p_resource_manager &ResourceManager, const_p_name &u16, const_p_data voidptr, size_in_bytes usize) Result

// resource_manager_register_encoded_data_w is currently undocumented
pub fn resource_manager_register_encoded_data_w(p_resource_manager &ResourceManager, const_p_name &u16, const_p_data voidptr, size_in_bytes usize) Result {
	return C.ma_resource_manager_register_encoded_data_w(p_resource_manager, const_p_name,
		const_p_data, size_in_bytes)
}

// C: `MA_API ma_result ma_resource_manager_unregister_file(ma_resource_manager* pResourceManager, const char* pFilePath)`
fn C.ma_resource_manager_unregister_file(p_resource_manager &ResourceManager, const_p_file_path &char) Result

// resource_manager_unregister_file is currently undocumented
pub fn resource_manager_unregister_file(p_resource_manager &ResourceManager, const_p_file_path &char) Result {
	return C.ma_resource_manager_unregister_file(p_resource_manager, const_p_file_path)
}

// C: `MA_API ma_result ma_resource_manager_unregister_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath)`
fn C.ma_resource_manager_unregister_file_w(p_resource_manager &ResourceManager, const_p_file_path &u16) Result

// resource_manager_unregister_file_w is currently undocumented
pub fn resource_manager_unregister_file_w(p_resource_manager &ResourceManager, const_p_file_path &u16) Result {
	return C.ma_resource_manager_unregister_file_w(p_resource_manager, const_p_file_path)
}

// C: `MA_API ma_result ma_resource_manager_unregister_data(ma_resource_manager* pResourceManager, const char* pName)`
fn C.ma_resource_manager_unregister_data(p_resource_manager &ResourceManager, const_p_name &char) Result

// resource_manager_unregister_data is currently undocumented
pub fn resource_manager_unregister_data(p_resource_manager &ResourceManager, const_p_name &char) Result {
	return C.ma_resource_manager_unregister_data(p_resource_manager, const_p_name)
}

// C: `MA_API ma_result ma_resource_manager_unregister_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName)`
fn C.ma_resource_manager_unregister_data_w(p_resource_manager &ResourceManager, const_p_name &u16) Result

// resource_manager_unregister_data_w is currently undocumented
pub fn resource_manager_unregister_data_w(p_resource_manager &ResourceManager, const_p_name &u16) Result {
	return C.ma_resource_manager_unregister_data_w(p_resource_manager, const_p_name)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_init_ex datas Buffers.
pub fn resource_manager_data_buffer_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_init_ex(p_resource_manager, const_p_config,
		p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_init(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_init is currently undocumented
pub fn resource_manager_data_buffer_init(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_init(p_resource_manager, const_p_file_path,
		flags, const_p_notifications, p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_init_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_init_w is currently undocumented
pub fn resource_manager_data_buffer_init_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_init_w(p_resource_manager, const_p_file_path,
		flags, const_p_notifications, p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_buffer* pExistingDataBuffer, ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_init_copy(p_resource_manager &ResourceManager, const_p_existing_data_buffer &ResourceManagerDataBuffer, p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_init_copy is currently undocumented
pub fn resource_manager_data_buffer_init_copy(p_resource_manager &ResourceManager, const_p_existing_data_buffer &ResourceManagerDataBuffer, p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_init_copy(p_resource_manager, const_p_existing_data_buffer,
		p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_uninit(ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_uninit(p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_uninit is currently undocumented
pub fn resource_manager_data_buffer_uninit(p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_uninit(p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_read_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_resource_manager_data_buffer_read_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// resource_manager_data_buffer_read_pcm_frames is currently undocumented
pub fn resource_manager_data_buffer_read_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_resource_manager_data_buffer_read_pcm_frames(p_data_buffer, p_frames_out,
		frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_seek_to_pcm_frame(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64 frameIndex)`
fn C.ma_resource_manager_data_buffer_seek_to_pcm_frame(p_data_buffer &ResourceManagerDataBuffer, frame_index u64) Result

// resource_manager_data_buffer_seek_to_pcm_frame is currently undocumented
pub fn resource_manager_data_buffer_seek_to_pcm_frame(p_data_buffer &ResourceManagerDataBuffer, frame_index u64) Result {
	return C.ma_resource_manager_data_buffer_seek_to_pcm_frame(p_data_buffer, frame_index)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_get_data_format(ma_resource_manager_data_buffer* pDataBuffer, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_resource_manager_data_buffer_get_data_format(p_data_buffer &ResourceManagerDataBuffer, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// resource_manager_data_buffer_get_data_format is currently undocumented
pub fn resource_manager_data_buffer_get_data_format(p_data_buffer &ResourceManagerDataBuffer, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_resource_manager_data_buffer_get_data_format(p_data_buffer, &p_format,
		p_channels, p_sample_rate, p_channel_map, channel_map_cap)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pCursor)`
fn C.ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_cursor &u64) Result

// resource_manager_data_buffer_get_cursor_in_pcm_frames is currently undocumented
pub fn resource_manager_data_buffer_get_cursor_in_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_cursor &u64) Result {
	return C.ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(p_data_buffer, p_cursor)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_get_length_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pLength)`
fn C.ma_resource_manager_data_buffer_get_length_in_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_length &u64) Result

// resource_manager_data_buffer_get_length_in_pcm_frames is currently undocumented
pub fn resource_manager_data_buffer_get_length_in_pcm_frames(p_data_buffer &ResourceManagerDataBuffer, p_length &u64) Result {
	return C.ma_resource_manager_data_buffer_get_length_in_pcm_frames(p_data_buffer, p_length)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_result(const ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_result(const_p_data_buffer &ResourceManagerDataBuffer) Result

// resource_manager_data_buffer_result is currently undocumented
pub fn resource_manager_data_buffer_result(const_p_data_buffer &ResourceManagerDataBuffer) Result {
	return C.ma_resource_manager_data_buffer_result(const_p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_set_looping(ma_resource_manager_data_buffer* pDataBuffer, ma_bool32 isLooping)`
fn C.ma_resource_manager_data_buffer_set_looping(p_data_buffer &ResourceManagerDataBuffer, is_looping u32) Result

// resource_manager_data_buffer_set_looping is currently undocumented
pub fn resource_manager_data_buffer_set_looping(p_data_buffer &ResourceManagerDataBuffer, is_looping u32) Result {
	return C.ma_resource_manager_data_buffer_set_looping(p_data_buffer, is_looping)
}

// C: `MA_API ma_bool32 ma_resource_manager_data_buffer_is_looping(const ma_resource_manager_data_buffer* pDataBuffer)`
fn C.ma_resource_manager_data_buffer_is_looping(const_p_data_buffer &ResourceManagerDataBuffer) u32

// resource_manager_data_buffer_is_looping is currently undocumented
pub fn resource_manager_data_buffer_is_looping(const_p_data_buffer &ResourceManagerDataBuffer) u32 {
	return C.ma_resource_manager_data_buffer_is_looping(const_p_data_buffer)
}

// C: `MA_API ma_result ma_resource_manager_data_buffer_get_available_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pAvailableFrames)`
fn C.ma_resource_manager_data_buffer_get_available_frames(p_data_buffer &ResourceManagerDataBuffer, p_available_frames &u64) Result

// resource_manager_data_buffer_get_available_frames is currently undocumented
pub fn resource_manager_data_buffer_get_available_frames(p_data_buffer &ResourceManagerDataBuffer, p_available_frames &u64) Result {
	return C.ma_resource_manager_data_buffer_get_available_frames(p_data_buffer, p_available_frames)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_stream &ResourceManagerDataStream) Result

// resource_manager_data_stream_init_ex datas Streams.
pub fn resource_manager_data_stream_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_stream &ResourceManagerDataStream) Result {
	return C.ma_resource_manager_data_stream_init_ex(p_resource_manager, const_p_config,
		p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_init(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_stream &ResourceManagerDataStream) Result

// resource_manager_data_stream_init is currently undocumented
pub fn resource_manager_data_stream_init(p_resource_manager &ResourceManager, const_p_file_path &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_stream &ResourceManagerDataStream) Result {
	return C.ma_resource_manager_data_stream_init(p_resource_manager, const_p_file_path,
		flags, const_p_notifications, p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_init_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_stream &ResourceManagerDataStream) Result

// resource_manager_data_stream_init_w is currently undocumented
pub fn resource_manager_data_stream_init_w(p_resource_manager &ResourceManager, const_p_file_path &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_stream &ResourceManagerDataStream) Result {
	return C.ma_resource_manager_data_stream_init_w(p_resource_manager, const_p_file_path,
		flags, const_p_notifications, p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_uninit(ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_uninit(p_data_stream &ResourceManagerDataStream) Result

// resource_manager_data_stream_uninit is currently undocumented
pub fn resource_manager_data_stream_uninit(p_data_stream &ResourceManagerDataStream) Result {
	return C.ma_resource_manager_data_stream_uninit(p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_read_pcm_frames(ma_resource_manager_data_stream* pDataStream, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_resource_manager_data_stream_read_pcm_frames(p_data_stream &ResourceManagerDataStream, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// resource_manager_data_stream_read_pcm_frames is currently undocumented
pub fn resource_manager_data_stream_read_pcm_frames(p_data_stream &ResourceManagerDataStream, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_resource_manager_data_stream_read_pcm_frames(p_data_stream, p_frames_out,
		frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_seek_to_pcm_frame(ma_resource_manager_data_stream* pDataStream, ma_uint64 frameIndex)`
fn C.ma_resource_manager_data_stream_seek_to_pcm_frame(p_data_stream &ResourceManagerDataStream, frame_index u64) Result

// resource_manager_data_stream_seek_to_pcm_frame is currently undocumented
pub fn resource_manager_data_stream_seek_to_pcm_frame(p_data_stream &ResourceManagerDataStream, frame_index u64) Result {
	return C.ma_resource_manager_data_stream_seek_to_pcm_frame(p_data_stream, frame_index)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_get_data_format(ma_resource_manager_data_stream* pDataStream, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_resource_manager_data_stream_get_data_format(p_data_stream &ResourceManagerDataStream, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// resource_manager_data_stream_get_data_format is currently undocumented
pub fn resource_manager_data_stream_get_data_format(p_data_stream &ResourceManagerDataStream, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_resource_manager_data_stream_get_data_format(p_data_stream, &p_format,
		p_channels, p_sample_rate, p_channel_map, channel_map_cap)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_get_cursor_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pCursor)`
fn C.ma_resource_manager_data_stream_get_cursor_in_pcm_frames(p_data_stream &ResourceManagerDataStream, p_cursor &u64) Result

// resource_manager_data_stream_get_cursor_in_pcm_frames is currently undocumented
pub fn resource_manager_data_stream_get_cursor_in_pcm_frames(p_data_stream &ResourceManagerDataStream, p_cursor &u64) Result {
	return C.ma_resource_manager_data_stream_get_cursor_in_pcm_frames(p_data_stream, p_cursor)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_get_length_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pLength)`
fn C.ma_resource_manager_data_stream_get_length_in_pcm_frames(p_data_stream &ResourceManagerDataStream, p_length &u64) Result

// resource_manager_data_stream_get_length_in_pcm_frames is currently undocumented
pub fn resource_manager_data_stream_get_length_in_pcm_frames(p_data_stream &ResourceManagerDataStream, p_length &u64) Result {
	return C.ma_resource_manager_data_stream_get_length_in_pcm_frames(p_data_stream, p_length)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_result(const ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_result(const_p_data_stream &ResourceManagerDataStream) Result

// resource_manager_data_stream_result is currently undocumented
pub fn resource_manager_data_stream_result(const_p_data_stream &ResourceManagerDataStream) Result {
	return C.ma_resource_manager_data_stream_result(const_p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_set_looping(ma_resource_manager_data_stream* pDataStream, ma_bool32 isLooping)`
fn C.ma_resource_manager_data_stream_set_looping(p_data_stream &ResourceManagerDataStream, is_looping u32) Result

// resource_manager_data_stream_set_looping is currently undocumented
pub fn resource_manager_data_stream_set_looping(p_data_stream &ResourceManagerDataStream, is_looping u32) Result {
	return C.ma_resource_manager_data_stream_set_looping(p_data_stream, is_looping)
}

// C: `MA_API ma_bool32 ma_resource_manager_data_stream_is_looping(const ma_resource_manager_data_stream* pDataStream)`
fn C.ma_resource_manager_data_stream_is_looping(const_p_data_stream &ResourceManagerDataStream) u32

// resource_manager_data_stream_is_looping is currently undocumented
pub fn resource_manager_data_stream_is_looping(const_p_data_stream &ResourceManagerDataStream) u32 {
	return C.ma_resource_manager_data_stream_is_looping(const_p_data_stream)
}

// C: `MA_API ma_result ma_resource_manager_data_stream_get_available_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pAvailableFrames)`
fn C.ma_resource_manager_data_stream_get_available_frames(p_data_stream &ResourceManagerDataStream, p_available_frames &u64) Result

// resource_manager_data_stream_get_available_frames is currently undocumented
pub fn resource_manager_data_stream_get_available_frames(p_data_stream &ResourceManagerDataStream, p_available_frames &u64) Result {
	return C.ma_resource_manager_data_stream_get_available_frames(p_data_stream, p_available_frames)
}

// C: `MA_API ma_result ma_resource_manager_data_source_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_init_ex datas Sources.
pub fn resource_manager_data_source_init_ex(p_resource_manager &ResourceManager, const_p_config &ResourceManagerDataSourceConfig, p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_init_ex(p_resource_manager, const_p_config,
		p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_init(ma_resource_manager* pResourceManager, const char* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_init(p_resource_manager &ResourceManager, const_p_name &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_init is currently undocumented
pub fn resource_manager_data_source_init(p_resource_manager &ResourceManager, const_p_name &char, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_init(p_resource_manager, const_p_name, flags,
		const_p_notifications, p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_init_w(ma_resource_manager* pResourceManager, const wchar_t* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_init_w(p_resource_manager &ResourceManager, const_p_name &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_init_w is currently undocumented
pub fn resource_manager_data_source_init_w(p_resource_manager &ResourceManager, const_p_name &u16, flags u32, const_p_notifications &ResourceManagerPipelineNotifications, p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_init_w(p_resource_manager, const_p_name,
		flags, const_p_notifications, p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source* pExistingDataSource, ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_init_copy(p_resource_manager &ResourceManager, const_p_existing_data_source &ResourceManagerDataSource, p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_init_copy is currently undocumented
pub fn resource_manager_data_source_init_copy(p_resource_manager &ResourceManager, const_p_existing_data_source &ResourceManagerDataSource, p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_init_copy(p_resource_manager, const_p_existing_data_source,
		p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_uninit(ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_uninit(p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_uninit is currently undocumented
pub fn resource_manager_data_source_uninit(p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_uninit(p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_read_pcm_frames(ma_resource_manager_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_resource_manager_data_source_read_pcm_frames(p_data_source &ResourceManagerDataSource, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// resource_manager_data_source_read_pcm_frames is currently undocumented
pub fn resource_manager_data_source_read_pcm_frames(p_data_source &ResourceManagerDataSource, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_resource_manager_data_source_read_pcm_frames(p_data_source, p_frames_out,
		frame_count, p_frames_read)
}

// C: `MA_API ma_result ma_resource_manager_data_source_seek_to_pcm_frame(ma_resource_manager_data_source* pDataSource, ma_uint64 frameIndex)`
fn C.ma_resource_manager_data_source_seek_to_pcm_frame(p_data_source &ResourceManagerDataSource, frame_index u64) Result

// resource_manager_data_source_seek_to_pcm_frame is currently undocumented
pub fn resource_manager_data_source_seek_to_pcm_frame(p_data_source &ResourceManagerDataSource, frame_index u64) Result {
	return C.ma_resource_manager_data_source_seek_to_pcm_frame(p_data_source, frame_index)
}

// C: `MA_API ma_result ma_resource_manager_data_source_get_data_format(ma_resource_manager_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_resource_manager_data_source_get_data_format(p_data_source &ResourceManagerDataSource, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// resource_manager_data_source_get_data_format is currently undocumented
pub fn resource_manager_data_source_get_data_format(p_data_source &ResourceManagerDataSource, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_resource_manager_data_source_get_data_format(p_data_source, &p_format,
		p_channels, p_sample_rate, p_channel_map, channel_map_cap)
}

// C: `MA_API ma_result ma_resource_manager_data_source_get_cursor_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pCursor)`
fn C.ma_resource_manager_data_source_get_cursor_in_pcm_frames(p_data_source &ResourceManagerDataSource, p_cursor &u64) Result

// resource_manager_data_source_get_cursor_in_pcm_frames is currently undocumented
pub fn resource_manager_data_source_get_cursor_in_pcm_frames(p_data_source &ResourceManagerDataSource, p_cursor &u64) Result {
	return C.ma_resource_manager_data_source_get_cursor_in_pcm_frames(p_data_source, p_cursor)
}

// C: `MA_API ma_result ma_resource_manager_data_source_get_length_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pLength)`
fn C.ma_resource_manager_data_source_get_length_in_pcm_frames(p_data_source &ResourceManagerDataSource, p_length &u64) Result

// resource_manager_data_source_get_length_in_pcm_frames is currently undocumented
pub fn resource_manager_data_source_get_length_in_pcm_frames(p_data_source &ResourceManagerDataSource, p_length &u64) Result {
	return C.ma_resource_manager_data_source_get_length_in_pcm_frames(p_data_source, p_length)
}

// C: `MA_API ma_result ma_resource_manager_data_source_result(const ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_result(const_p_data_source &ResourceManagerDataSource) Result

// resource_manager_data_source_result is currently undocumented
pub fn resource_manager_data_source_result(const_p_data_source &ResourceManagerDataSource) Result {
	return C.ma_resource_manager_data_source_result(const_p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_set_looping(ma_resource_manager_data_source* pDataSource, ma_bool32 isLooping)`
fn C.ma_resource_manager_data_source_set_looping(p_data_source &ResourceManagerDataSource, is_looping u32) Result

// resource_manager_data_source_set_looping is currently undocumented
pub fn resource_manager_data_source_set_looping(p_data_source &ResourceManagerDataSource, is_looping u32) Result {
	return C.ma_resource_manager_data_source_set_looping(p_data_source, is_looping)
}

// C: `MA_API ma_bool32 ma_resource_manager_data_source_is_looping(const ma_resource_manager_data_source* pDataSource)`
fn C.ma_resource_manager_data_source_is_looping(const_p_data_source &ResourceManagerDataSource) u32

// resource_manager_data_source_is_looping is currently undocumented
pub fn resource_manager_data_source_is_looping(const_p_data_source &ResourceManagerDataSource) u32 {
	return C.ma_resource_manager_data_source_is_looping(const_p_data_source)
}

// C: `MA_API ma_result ma_resource_manager_data_source_get_available_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pAvailableFrames)`
fn C.ma_resource_manager_data_source_get_available_frames(p_data_source &ResourceManagerDataSource, p_available_frames &u64) Result

// resource_manager_data_source_get_available_frames is currently undocumented
pub fn resource_manager_data_source_get_available_frames(p_data_source &ResourceManagerDataSource, p_available_frames &u64) Result {
	return C.ma_resource_manager_data_source_get_available_frames(p_data_source, p_available_frames)
}

// C: `MA_API ma_result ma_resource_manager_post_job(ma_resource_manager* pResourceManager, const ma_job* pJob)`
fn C.ma_resource_manager_post_job(p_resource_manager &ResourceManager, const_p_job &Job) Result

// resource_manager_post_job jobs management.
pub fn resource_manager_post_job(p_resource_manager &ResourceManager, const_p_job &Job) Result {
	return C.ma_resource_manager_post_job(p_resource_manager, const_p_job)
}

// C: `MA_API ma_result ma_resource_manager_post_job_quit(ma_resource_manager* pResourceManager);/* Helper for posting a quit job. */`
fn C.ma_resource_manager_post_job_quit(p_resource_manager &ResourceManager) Result

// resource_manager_post_job_quit helpers for posting a quit job.
pub fn resource_manager_post_job_quit(p_resource_manager &ResourceManager) Result {
	return C.ma_resource_manager_post_job_quit(p_resource_manager)
}

// C: `MA_API ma_result ma_resource_manager_next_job(ma_resource_manager* pResourceManager, ma_job* pJob)`
fn C.ma_resource_manager_next_job(p_resource_manager &ResourceManager, p_job &Job) Result

// resource_manager_next_job is currently undocumented
pub fn resource_manager_next_job(p_resource_manager &ResourceManager, p_job &Job) Result {
	return C.ma_resource_manager_next_job(p_resource_manager, p_job)
}

// C: `MA_API ma_result ma_resource_manager_process_job(ma_resource_manager* pResourceManager, ma_job* pJob);/* DEPRECATED. Use ma_job_process(). Will be removed in version 0.12. */`
fn C.ma_resource_manager_process_job(p_resource_manager &ResourceManager, p_job &Job) Result

// resource_manager_process_job deprecated.s Use ma_job_process(). Will be removed in version 0.12.
pub fn resource_manager_process_job(p_resource_manager &ResourceManager, p_job &Job) Result {
	return C.ma_resource_manager_process_job(p_resource_manager, p_job)
}

// C: `MA_API ma_result ma_resource_manager_process_next_job(ma_resource_manager* pResourceManager); /* Returns MA_CANCELLED if a MA_JOB_TYPE_QUIT job is found. In non-blocking mode, returns MA_NO_DATA_AVAILABLE if no jobs are available. */`
fn C.ma_resource_manager_process_next_job(p_resource_manager &ResourceManager) Result

// resource_manager_process_next_job returns MA_CANCELLED if a MA_JOB_TYPE_QUIT job is found. In non-blocking mode, returns MA_NO_DATA_AVAILABLE if no jobs are available.
pub fn resource_manager_process_next_job(p_resource_manager &ResourceManager) Result {
	return C.ma_resource_manager_process_next_job(p_resource_manager)
}

// Node Graph
//
// Must never exceed 254.
pub const max_node_bus_count = 254

// Used internally by miniaudio for memory management. Must never exceed MA_MAX_NODE_BUS_COUNT.
pub const max_node_local_bus_count = 2

// Use this when the bus count is determined by the node instance rather than the vtable.
pub const node_bus_count_unknown = 255

// NodeFlags is C.ma_node_flags
pub enum NodeFlags {
	passthrough                = C.MA_NODE_FLAG_PASSTHROUGH                // 0x00000001,
	continuous_processing      = C.MA_NODE_FLAG_CONTINUOUS_PROCESSING      // 0x00000002,
	allow_null_input           = C.MA_NODE_FLAG_ALLOW_NULL_INPUT           // 0x00000004,
	different_processing_rates = C.MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES // 0x00000008,
	silent_output              = C.MA_NODE_FLAG_SILENT_OUTPUT              // 0x00000010,
}

// NodeState is C.ma_node_state
pub enum NodeState {
	started = C.ma_node_state_started // 0,
	stopped = C.ma_node_state_stopped // 1,
}

@[typedef]
struct C.ma_node_vtable {
pub mut:
	// Extended processing callback. This callback is used for effects that process input and output at different rates (i.e. they perform resampling). This is similar to the simple version, only they take two seperate frame counts: one for input, and one for output. On input, `pFrameCountOut` is equal to the capacity of the output buffer for each bus, whereas `pFrameCountIn` will be equal to the number of PCM frames in each of the buffers in `ppFramesIn`. On output, set `pFrameCountOut` to the number of PCM frames that were actually output and set `pFrameCountIn` to the number of input frames that were consumed.
	onProcess                    fn (p_node voidptr, const_pp_frames_in &&f32, p_frame_count_in &u32, pp_frames_out &&f32, p_frame_count_out &u32) // onProcess)(ma_node* A callback for retrieving the number of a input frames that are required to output the specified number of output frames. You would only want to implement this when the node performs resampling. This is optional, even for nodes that perform resampling, but it does offer a small reduction in latency as it allows miniaudio to calculate the exact number of input frames to read at a time instead of having to estimate.
	onGetRequiredInputFrameCount fn (p_node voidptr, output_frame_count u32, p_input_frame_count &u32) Result // onGetRequiredInputFrameCount)(ma_node* The number of input buses. This is how many sub-buffers will be contained in the `ppFramesIn` parameters of the callbacks above.
	inputBusCount                u8 // The number of output buses. This is how many sub-buffers will be contained in the `ppFramesOut` parameters of the callbacks above.
	outputBusCount               u8 // Flags describing characteristics of the node. This is currently just a placeholder for some ideas for later on.
	flags                        u32
}

pub type NodeVtable = C.ma_node_vtable

@[typedef]
struct C.ma_node_config {
pub mut:
	vtable          &NodeVtable = unsafe { nil } // Should never be null. Initialization of the node will fail if so.
	initialState    NodeState // Defaults to ma_node_state_started.
	inputBusCount   u32       // Only used if the vtable specifies an input bus count of `MA_NODE_BUS_COUNT_UNKNOWN`, otherwise must be set to `MA_NODE_BUS_COUNT_UNKNOWN` (default).
	outputBusCount  u32       // Only used if the vtable specifies an output bus count of `MA_NODE_BUS_COUNT_UNKNOWN`, otherwise be set to `MA_NODE_BUS_COUNT_UNKNOWN` (default).
	pInputChannels  &u32 = unsafe { nil } // The number of elements are determined by the input bus count as determined by the vtable, or `inputBusCount` if the vtable specifies `MA_NODE_BUS_COUNT_UNKNOWN`.
	pOutputChannels &u32 = unsafe { nil } // The number of elements are determined by the output bus count as determined by the vtable, or `outputBusCount` if the vtable specifies `MA_NODE_BUS_COUNT_UNKNOWN`.
}

pub type NodeConfig = C.ma_node_config

// C: `MA_API ma_node_config ma_node_config_init(void)`
fn C.ma_node_config_init() NodeConfig

// node_config_init is currently undocumented
pub fn node_config_init() NodeConfig {
	return C.ma_node_config_init()
}

@[typedef]
struct C.ma_node_output_bus {
pub mut:
	// Immutable.
	pNode          voidptr // The node that owns this output bus. The input node. Will be null for dummy head and tail nodes.
	outputBusIndex u8      // The index of the output bus on pNode that this output bus represents.
	channels       u8      // The number of channels in the audio stream for this bus.
	// TODO MA_ATOMIC(1, ma_uint8) inputNodeInputBusIndex
	// TODO MA_ATOMIC(4, ma_uint32) flags
	// TODO MA_ATOMIC(4, ma_uint32) refCount
	// TODO MA_ATOMIC(4, ma_bool32) isAttached
	// TODO MA_ATOMIC(4, ma_spinlock) lock
	// TODO MA_ATOMIC(4, float) volume
	// TODO MA_ATOMIC(MA_SIZEOF_PTR, ma_node_output_bus*) pNext
	// TODO MA_ATOMIC(MA_SIZEOF_PTR, ma_node_output_bus*) pPrev
	// TODO MA_ATOMIC(MA_SIZEOF_PTR, ma_node*) pInputNode
}

pub type NodeOutputBus = C.ma_node_output_bus

@[typedef]
struct C.ma_node_input_bus {
pub mut:
	// Mutable via multiple threads.
	head NodeOutputBus // Dummy head node for simplifying some lock-free thread-safety stuff.
	// TODO MA_ATOMIC(4, ma_uint32) nextCounter
	// TODO MA_ATOMIC(4, ma_spinlock) lock
	// Set once at startup.

	channels u8 // The number of channels in the audio stream for this bus.
}

pub type NodeInputBus = C.ma_node_input_bus

@[typedef]
struct C.ma_node_base {
pub mut:
	// These variables are set once at startup.
	pNodeGraph                  &NodeGraph  = unsafe { nil } // The graph this node belongs to.
	vtable                      &NodeVtable = unsafe { nil }
	pCachedData                 &f32        = unsafe { nil } // Allocated on the heap. Fixed size. Needs to be stored on the heap because reading from output buses is done in separate function calls.
	cachedDataCapInFramesPerBus u16 // The capacity of the input data cache in frames, per bus.
	// These variables are read and written only from the audio thread.

	cachedFrameCountOut  u16
	cachedFrameCountIn   u16
	consumedFrameCountIn u16 // These variables are read and written between different threads.
	// TODO MA_ATOMIC(4, ma_node_state) state
	// TODO MA_ATOMIC(8, ma_uint64) stateTimes[2]
	// TODO MA_ATOMIC(8, ma_uint64) localTime
	inputBusCount  u32
	outputBusCount u32
	pInputBuses    &NodeInputBus  = unsafe { nil }
	pOutputBuses   &NodeOutputBus = unsafe { nil } // Memory management.
	// TODO 	_inputBuses [MA_MAX_NODE_LOCAL_BUS_COUNT]NodeInputBus
	// TODO 	_outputBuses [MA_MAX_NODE_LOCAL_BUS_COUNT]NodeOutputBus
	_pHeap    voidptr // A heap allocation for internal use only. pInputBuses and/or pOutputBuses will point to this if the bus count exceeds MA_MAX_NODE_LOCAL_BUS_COUNT.
	_ownsHeap u32     // If set to true, the node owns the heap allocation and _pHeap will be freed in ma_node_uninit().
}

pub type NodeBase = C.ma_node_base

// C: `MA_API ma_result ma_node_get_heap_size(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_node_get_heap_size(p_node_graph &NodeGraph, const_p_config &NodeConfig, p_heap_size_in_bytes &usize) Result

// node_get_heap_size is currently undocumented
pub fn node_get_heap_size(p_node_graph &NodeGraph, const_p_config &NodeConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_node_get_heap_size(p_node_graph, const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_node_init_preallocated(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, void* pHeap, ma_node* pNode)`
fn C.ma_node_init_preallocated(p_node_graph &NodeGraph, const_p_config &NodeConfig, p_heap voidptr, p_node voidptr) Result

// node_init_preallocated is currently undocumented
pub fn node_init_preallocated(p_node_graph &NodeGraph, const_p_config &NodeConfig, p_heap voidptr, p_node voidptr) Result {
	return C.ma_node_init_preallocated(p_node_graph, const_p_config, p_heap, p_node)
}

// C: `MA_API ma_result ma_node_init(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node* pNode)`
fn C.ma_node_init(p_node_graph &NodeGraph, const_p_config &NodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node voidptr) Result

// node_init is currently undocumented
pub fn node_init(p_node_graph &NodeGraph, const_p_config &NodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node voidptr) Result {
	return C.ma_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API void ma_node_uninit(ma_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_node_uninit(p_node voidptr, const_p_allocation_callbacks &AllocationCallbacks)

// node_uninit is currently undocumented
pub fn node_uninit(p_node voidptr, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_node_uninit(p_node, const_p_allocation_callbacks)
}

// C: `MA_API ma_node_graph* ma_node_get_node_graph(const ma_node* pNode)`
fn C.ma_node_get_node_graph(const_p_node voidptr) &NodeGraph

// node_get_node_graph is currently undocumented
pub fn node_get_node_graph(const_p_node voidptr) &NodeGraph {
	return C.ma_node_get_node_graph(const_p_node)
}

// C: `MA_API ma_uint32 ma_node_get_input_bus_count(const ma_node* pNode)`
fn C.ma_node_get_input_bus_count(const_p_node voidptr) u32

// node_get_input_bus_count is currently undocumented
pub fn node_get_input_bus_count(const_p_node voidptr) u32 {
	return C.ma_node_get_input_bus_count(const_p_node)
}

// C: `MA_API ma_uint32 ma_node_get_output_bus_count(const ma_node* pNode)`
fn C.ma_node_get_output_bus_count(const_p_node voidptr) u32

// node_get_output_bus_count is currently undocumented
pub fn node_get_output_bus_count(const_p_node voidptr) u32 {
	return C.ma_node_get_output_bus_count(const_p_node)
}

// C: `MA_API ma_uint32 ma_node_get_input_channels(const ma_node* pNode, ma_uint32 inputBusIndex)`
fn C.ma_node_get_input_channels(const_p_node voidptr, input_bus_index u32) u32

// node_get_input_channels is currently undocumented
pub fn node_get_input_channels(const_p_node voidptr, input_bus_index u32) u32 {
	return C.ma_node_get_input_channels(const_p_node, input_bus_index)
}

// C: `MA_API ma_uint32 ma_node_get_output_channels(const ma_node* pNode, ma_uint32 outputBusIndex)`
fn C.ma_node_get_output_channels(const_p_node voidptr, output_bus_index u32) u32

// node_get_output_channels is currently undocumented
pub fn node_get_output_channels(const_p_node voidptr, output_bus_index u32) u32 {
	return C.ma_node_get_output_channels(const_p_node, output_bus_index)
}

// C: `MA_API ma_result ma_node_attach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex, ma_node* pOtherNode, ma_uint32 otherNodeInputBusIndex)`
fn C.ma_node_attach_output_bus(p_node voidptr, output_bus_index u32, p_other_node voidptr, other_node_input_bus_index u32) Result

// node_attach_output_bus is currently undocumented
pub fn node_attach_output_bus(p_node voidptr, output_bus_index u32, p_other_node voidptr, other_node_input_bus_index u32) Result {
	return C.ma_node_attach_output_bus(p_node, output_bus_index, p_other_node, other_node_input_bus_index)
}

// C: `MA_API ma_result ma_node_detach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex)`
fn C.ma_node_detach_output_bus(p_node voidptr, output_bus_index u32) Result

// node_detach_output_bus is currently undocumented
pub fn node_detach_output_bus(p_node voidptr, output_bus_index u32) Result {
	return C.ma_node_detach_output_bus(p_node, output_bus_index)
}

// C: `MA_API ma_result ma_node_detach_all_output_buses(ma_node* pNode)`
fn C.ma_node_detach_all_output_buses(p_node voidptr) Result

// node_detach_all_output_buses is currently undocumented
pub fn node_detach_all_output_buses(p_node voidptr) Result {
	return C.ma_node_detach_all_output_buses(p_node)
}

// C: `MA_API ma_result ma_node_set_output_bus_volume(ma_node* pNode, ma_uint32 outputBusIndex, float volume)`
fn C.ma_node_set_output_bus_volume(p_node voidptr, output_bus_index u32, volume f32) Result

// node_set_output_bus_volume is currently undocumented
pub fn node_set_output_bus_volume(p_node voidptr, output_bus_index u32, volume f32) Result {
	return C.ma_node_set_output_bus_volume(p_node, output_bus_index, volume)
}

// C: `MA_API float ma_node_get_output_bus_volume(const ma_node* pNode, ma_uint32 outputBusIndex)`
fn C.ma_node_get_output_bus_volume(const_p_node voidptr, output_bus_index u32) f32

// node_get_output_bus_volume is currently undocumented
pub fn node_get_output_bus_volume(const_p_node voidptr, output_bus_index u32) f32 {
	return C.ma_node_get_output_bus_volume(const_p_node, output_bus_index)
}

// C: `MA_API ma_result ma_node_set_state(ma_node* pNode, ma_node_state state)`
fn C.ma_node_set_state(p_node voidptr, state NodeState) Result

// node_set_state is currently undocumented
pub fn node_set_state(p_node voidptr, state NodeState) Result {
	return C.ma_node_set_state(p_node, state)
}

// C: `MA_API ma_node_state ma_node_get_state(const ma_node* pNode)`
fn C.ma_node_get_state(const_p_node voidptr) NodeState

// node_get_state is currently undocumented
pub fn node_get_state(const_p_node voidptr) NodeState {
	return C.ma_node_get_state(const_p_node)
}

// C: `MA_API ma_result ma_node_set_state_time(ma_node* pNode, ma_node_state state, ma_uint64 globalTime)`
fn C.ma_node_set_state_time(p_node voidptr, state NodeState, global_time u64) Result

// node_set_state_time is currently undocumented
pub fn node_set_state_time(p_node voidptr, state NodeState, global_time u64) Result {
	return C.ma_node_set_state_time(p_node, state, global_time)
}

// C: `MA_API ma_uint64 ma_node_get_state_time(const ma_node* pNode, ma_node_state state)`
fn C.ma_node_get_state_time(const_p_node voidptr, state NodeState) u64

// node_get_state_time is currently undocumented
pub fn node_get_state_time(const_p_node voidptr, state NodeState) u64 {
	return C.ma_node_get_state_time(const_p_node, state)
}

// C: `MA_API ma_node_state ma_node_get_state_by_time(const ma_node* pNode, ma_uint64 globalTime)`
fn C.ma_node_get_state_by_time(const_p_node voidptr, global_time u64) NodeState

// node_get_state_by_time is currently undocumented
pub fn node_get_state_by_time(const_p_node voidptr, global_time u64) NodeState {
	return C.ma_node_get_state_by_time(const_p_node, global_time)
}

// C: `MA_API ma_node_state ma_node_get_state_by_time_range(const ma_node* pNode, ma_uint64 globalTimeBeg, ma_uint64 globalTimeEnd)`
fn C.ma_node_get_state_by_time_range(const_p_node voidptr, global_time_beg u64, global_time_end u64) NodeState

// node_get_state_by_time_range is currently undocumented
pub fn node_get_state_by_time_range(const_p_node voidptr, global_time_beg u64, global_time_end u64) NodeState {
	return C.ma_node_get_state_by_time_range(const_p_node, global_time_beg, global_time_end)
}

// C: `MA_API ma_uint64 ma_node_get_time(const ma_node* pNode)`
fn C.ma_node_get_time(const_p_node voidptr) u64

// node_get_time is currently undocumented
pub fn node_get_time(const_p_node voidptr) u64 {
	return C.ma_node_get_time(const_p_node)
}

// C: `MA_API ma_result ma_node_set_time(ma_node* pNode, ma_uint64 localTime)`
fn C.ma_node_set_time(p_node voidptr, local_time u64) Result

// node_set_time is currently undocumented
pub fn node_set_time(p_node voidptr, local_time u64) Result {
	return C.ma_node_set_time(p_node, local_time)
}

@[typedef]
struct C.ma_node_graph_config {
pub mut:
	channels             u32
	nodeCacheCapInFrames u16
}

pub type NodeGraphConfig = C.ma_node_graph_config

// C: `MA_API ma_node_graph_config ma_node_graph_config_init(ma_uint32 channels)`
fn C.ma_node_graph_config_init(channels u32) NodeGraphConfig

// node_graph_config_init is currently undocumented
pub fn node_graph_config_init(channels u32) NodeGraphConfig {
	return C.ma_node_graph_config_init(channels)
}

@[typedef]
struct C.ma_node_graph {
pub mut:
	// Immutable.
	base                 NodeBase // The node graph itself is a node so it can be connected as an input to different node graph. This has zero inputs and calls ma_node_graph_read_pcm_frames() to generate it's output.
	endpoint             NodeBase // Special node that all nodes eventually connect to. Data is read from this node in ma_node_graph_read_pcm_frames().
	nodeCacheCapInFrames u16      // Read and written by multiple threads.
	// TODO MA_ATOMIC(4, ma_bool32) isReading
}

pub type NodeGraph = C.ma_node_graph

// C: `MA_API ma_result ma_node_graph_init(const ma_node_graph_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node_graph* pNodeGraph)`
fn C.ma_node_graph_init(const_p_config &NodeGraphConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node_graph &NodeGraph) Result

// node_graph_init is currently undocumented
pub fn node_graph_init(const_p_config &NodeGraphConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node_graph &NodeGraph) Result {
	return C.ma_node_graph_init(const_p_config, const_p_allocation_callbacks, p_node_graph)
}

// C: `MA_API void ma_node_graph_uninit(ma_node_graph* pNodeGraph, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_node_graph_uninit(p_node_graph &NodeGraph, const_p_allocation_callbacks &AllocationCallbacks)

// node_graph_uninit is currently undocumented
pub fn node_graph_uninit(p_node_graph &NodeGraph, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_node_graph_uninit(p_node_graph, const_p_allocation_callbacks)
}

// C: `MA_API ma_node* ma_node_graph_get_endpoint(ma_node_graph* pNodeGraph)`
fn C.ma_node_graph_get_endpoint(p_node_graph &NodeGraph) voidptr

// node_graph_get_endpoint is currently undocumented
pub fn node_graph_get_endpoint(p_node_graph &NodeGraph) voidptr {
	return C.ma_node_graph_get_endpoint(p_node_graph)
}

// C: `MA_API ma_result ma_node_graph_read_pcm_frames(ma_node_graph* pNodeGraph, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_node_graph_read_pcm_frames(p_node_graph &NodeGraph, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// node_graph_read_pcm_frames is currently undocumented
pub fn node_graph_read_pcm_frames(p_node_graph &NodeGraph, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_node_graph_read_pcm_frames(p_node_graph, p_frames_out, frame_count, p_frames_read)
}

// C: `MA_API ma_uint32 ma_node_graph_get_channels(const ma_node_graph* pNodeGraph)`
fn C.ma_node_graph_get_channels(const_p_node_graph &NodeGraph) u32

// node_graph_get_channels is currently undocumented
pub fn node_graph_get_channels(const_p_node_graph &NodeGraph) u32 {
	return C.ma_node_graph_get_channels(const_p_node_graph)
}

// C: `MA_API ma_uint64 ma_node_graph_get_time(const ma_node_graph* pNodeGraph)`
fn C.ma_node_graph_get_time(const_p_node_graph &NodeGraph) u64

// node_graph_get_time is currently undocumented
pub fn node_graph_get_time(const_p_node_graph &NodeGraph) u64 {
	return C.ma_node_graph_get_time(const_p_node_graph)
}

// C: `MA_API ma_result ma_node_graph_set_time(ma_node_graph* pNodeGraph, ma_uint64 globalTime)`
fn C.ma_node_graph_set_time(p_node_graph &NodeGraph, global_time u64) Result

// node_graph_set_time is currently undocumented
pub fn node_graph_set_time(p_node_graph &NodeGraph, global_time u64) Result {
	return C.ma_node_graph_set_time(p_node_graph, global_time)
}

@[typedef]
struct C.ma_data_source_node_config {
pub mut:
	nodeConfig  NodeConfig
	pDataSource voidptr
}

pub type DataSourceNodeConfig = C.ma_data_source_node_config

// C: `MA_API ma_data_source_node_config ma_data_source_node_config_init(ma_data_source* pDataSource)`
fn C.ma_data_source_node_config_init(p_data_source voidptr) DataSourceNodeConfig

// data_source_node_config_init is currently undocumented
pub fn data_source_node_config_init(p_data_source voidptr) DataSourceNodeConfig {
	return C.ma_data_source_node_config_init(p_data_source)
}

@[typedef]
struct C.ma_data_source_node {
pub mut:
	base        NodeBase
	pDataSource voidptr
}

pub type DataSourceNode = C.ma_data_source_node

// C: `MA_API ma_result ma_data_source_node_init(ma_node_graph* pNodeGraph, const ma_data_source_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source_node* pDataSourceNode)`
fn C.ma_data_source_node_init(p_node_graph &NodeGraph, const_p_config &DataSourceNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_data_source_node &DataSourceNode) Result

// data_source_node_init is currently undocumented
pub fn data_source_node_init(p_node_graph &NodeGraph, const_p_config &DataSourceNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_data_source_node &DataSourceNode) Result {
	return C.ma_data_source_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_data_source_node)
}

// C: `MA_API void ma_data_source_node_uninit(ma_data_source_node* pDataSourceNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_data_source_node_uninit(p_data_source_node &DataSourceNode, const_p_allocation_callbacks &AllocationCallbacks)

// data_source_node_uninit is currently undocumented
pub fn data_source_node_uninit(p_data_source_node &DataSourceNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_data_source_node_uninit(p_data_source_node, const_p_allocation_callbacks)
}

// C: `MA_API ma_result ma_data_source_node_set_looping(ma_data_source_node* pDataSourceNode, ma_bool32 isLooping)`
fn C.ma_data_source_node_set_looping(p_data_source_node &DataSourceNode, is_looping u32) Result

// data_source_node_set_looping is currently undocumented
pub fn data_source_node_set_looping(p_data_source_node &DataSourceNode, is_looping u32) Result {
	return C.ma_data_source_node_set_looping(p_data_source_node, is_looping)
}

// C: `MA_API ma_bool32 ma_data_source_node_is_looping(ma_data_source_node* pDataSourceNode)`
fn C.ma_data_source_node_is_looping(p_data_source_node &DataSourceNode) u32

// data_source_node_is_looping is currently undocumented
pub fn data_source_node_is_looping(p_data_source_node &DataSourceNode) u32 {
	return C.ma_data_source_node_is_looping(p_data_source_node)
}

@[typedef]
struct C.ma_splitter_node_config {
pub mut:
	nodeConfig     NodeConfig
	channels       u32
	outputBusCount u32
}

pub type SplitterNodeConfig = C.ma_splitter_node_config

// C: `MA_API ma_splitter_node_config ma_splitter_node_config_init(ma_uint32 channels)`
fn C.ma_splitter_node_config_init(channels u32) SplitterNodeConfig

// splitter_node_config_init is currently undocumented
pub fn splitter_node_config_init(channels u32) SplitterNodeConfig {
	return C.ma_splitter_node_config_init(channels)
}

@[typedef]
struct C.ma_splitter_node {
pub mut:
	base NodeBase
}

pub type SplitterNode = C.ma_splitter_node

// C: `MA_API ma_result ma_splitter_node_init(ma_node_graph* pNodeGraph, const ma_splitter_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_splitter_node* pSplitterNode)`
fn C.ma_splitter_node_init(p_node_graph &NodeGraph, const_p_config &SplitterNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_splitter_node &SplitterNode) Result

// splitter_node_init is currently undocumented
pub fn splitter_node_init(p_node_graph &NodeGraph, const_p_config &SplitterNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_splitter_node &SplitterNode) Result {
	return C.ma_splitter_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_splitter_node)
}

// C: `MA_API void ma_splitter_node_uninit(ma_splitter_node* pSplitterNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_splitter_node_uninit(p_splitter_node &SplitterNode, const_p_allocation_callbacks &AllocationCallbacks)

// splitter_node_uninit is currently undocumented
pub fn splitter_node_uninit(p_splitter_node &SplitterNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_splitter_node_uninit(p_splitter_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_biquad_node_config {
pub mut:
	nodeConfig NodeConfig
	biquad     BiquadConfig
}

pub type BiquadNodeConfig = C.ma_biquad_node_config

// C: `MA_API ma_biquad_node_config ma_biquad_node_config_init(ma_uint32 channels, float b0, float b1, float b2, float a0, float a1, float a2)`
fn C.ma_biquad_node_config_init(channels u32, b0 f32, b1 f32, b2 f32, a0 f32, a1 f32, a2 f32) BiquadNodeConfig

// biquad_node_config_init is currently undocumented
pub fn biquad_node_config_init(channels u32, b0 f32, b1 f32, b2 f32, a0 f32, a1 f32, a2 f32) BiquadNodeConfig {
	return C.ma_biquad_node_config_init(channels, b0, b1, b2, a0, a1, a2)
}

@[typedef]
struct C.ma_biquad_node {
pub mut:
	baseNode NodeBase
	biquad   Biquad
}

pub type BiquadNode = C.ma_biquad_node

// C: `MA_API ma_result ma_biquad_node_init(ma_node_graph* pNodeGraph, const ma_biquad_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad_node* pNode)`
fn C.ma_biquad_node_init(p_node_graph &NodeGraph, const_p_config &BiquadNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &BiquadNode) Result

// biquad_node_init is currently undocumented
pub fn biquad_node_init(p_node_graph &NodeGraph, const_p_config &BiquadNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &BiquadNode) Result {
	return C.ma_biquad_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_biquad_node_reinit(const ma_biquad_config* pConfig, ma_biquad_node* pNode)`
fn C.ma_biquad_node_reinit(const_p_config &BiquadConfig, p_node &BiquadNode) Result

// biquad_node_reinit is currently undocumented
pub fn biquad_node_reinit(const_p_config &BiquadConfig, p_node &BiquadNode) Result {
	return C.ma_biquad_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_biquad_node_uninit(ma_biquad_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_biquad_node_uninit(p_node &BiquadNode, const_p_allocation_callbacks &AllocationCallbacks)

// biquad_node_uninit is currently undocumented
pub fn biquad_node_uninit(p_node &BiquadNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_biquad_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_lpf_node_config {
pub mut:
	nodeConfig NodeConfig
	lpf        LpfConfig
}

pub type LpfNodeConfig = C.ma_lpf_node_config

// C: `MA_API ma_lpf_node_config ma_lpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_lpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) LpfNodeConfig

// lpf_node_config_init is currently undocumented
pub fn lpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) LpfNodeConfig {
	return C.ma_lpf_node_config_init(channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_lpf_node {
pub mut:
	baseNode NodeBase
	lpf      Lpf
}

pub type LpfNode = C.ma_lpf_node

// C: `MA_API ma_result ma_lpf_node_init(ma_node_graph* pNodeGraph, const ma_lpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf_node* pNode)`
fn C.ma_lpf_node_init(p_node_graph &NodeGraph, const_p_config &LpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &LpfNode) Result

// lpf_node_init is currently undocumented
pub fn lpf_node_init(p_node_graph &NodeGraph, const_p_config &LpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &LpfNode) Result {
	return C.ma_lpf_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_lpf_node_reinit(const ma_lpf_config* pConfig, ma_lpf_node* pNode)`
fn C.ma_lpf_node_reinit(const_p_config &LpfConfig, p_node &LpfNode) Result

// lpf_node_reinit is currently undocumented
pub fn lpf_node_reinit(const_p_config &LpfConfig, p_node &LpfNode) Result {
	return C.ma_lpf_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_lpf_node_uninit(ma_lpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_lpf_node_uninit(p_node &LpfNode, const_p_allocation_callbacks &AllocationCallbacks)

// lpf_node_uninit is currently undocumented
pub fn lpf_node_uninit(p_node &LpfNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_lpf_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_hpf_node_config {
pub mut:
	nodeConfig NodeConfig
	hpf        HpfConfig
}

pub type HpfNodeConfig = C.ma_hpf_node_config

// C: `MA_API ma_hpf_node_config ma_hpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_hpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) HpfNodeConfig

// hpf_node_config_init is currently undocumented
pub fn hpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) HpfNodeConfig {
	return C.ma_hpf_node_config_init(channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_hpf_node {
pub mut:
	baseNode NodeBase
	hpf      Hpf
}

pub type HpfNode = C.ma_hpf_node

// C: `MA_API ma_result ma_hpf_node_init(ma_node_graph* pNodeGraph, const ma_hpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf_node* pNode)`
fn C.ma_hpf_node_init(p_node_graph &NodeGraph, const_p_config &HpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &HpfNode) Result

// hpf_node_init is currently undocumented
pub fn hpf_node_init(p_node_graph &NodeGraph, const_p_config &HpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &HpfNode) Result {
	return C.ma_hpf_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_hpf_node_reinit(const ma_hpf_config* pConfig, ma_hpf_node* pNode)`
fn C.ma_hpf_node_reinit(const_p_config &HpfConfig, p_node &HpfNode) Result

// hpf_node_reinit is currently undocumented
pub fn hpf_node_reinit(const_p_config &HpfConfig, p_node &HpfNode) Result {
	return C.ma_hpf_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_hpf_node_uninit(ma_hpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hpf_node_uninit(p_node &HpfNode, const_p_allocation_callbacks &AllocationCallbacks)

// hpf_node_uninit is currently undocumented
pub fn hpf_node_uninit(p_node &HpfNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hpf_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_bpf_node_config {
pub mut:
	nodeConfig NodeConfig
	bpf        BpfConfig
}

pub type BpfNodeConfig = C.ma_bpf_node_config

// C: `MA_API ma_bpf_node_config ma_bpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)`
fn C.ma_bpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) BpfNodeConfig

// bpf_node_config_init is currently undocumented
pub fn bpf_node_config_init(channels u32, sample_rate u32, cutoff_frequency f64, order u32) BpfNodeConfig {
	return C.ma_bpf_node_config_init(channels, sample_rate, cutoff_frequency, order)
}

@[typedef]
struct C.ma_bpf_node {
pub mut:
	baseNode NodeBase
	bpf      Bpf
}

pub type BpfNode = C.ma_bpf_node

// C: `MA_API ma_result ma_bpf_node_init(ma_node_graph* pNodeGraph, const ma_bpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf_node* pNode)`
fn C.ma_bpf_node_init(p_node_graph &NodeGraph, const_p_config &BpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &BpfNode) Result

// bpf_node_init is currently undocumented
pub fn bpf_node_init(p_node_graph &NodeGraph, const_p_config &BpfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &BpfNode) Result {
	return C.ma_bpf_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_bpf_node_reinit(const ma_bpf_config* pConfig, ma_bpf_node* pNode)`
fn C.ma_bpf_node_reinit(const_p_config &BpfConfig, p_node &BpfNode) Result

// bpf_node_reinit is currently undocumented
pub fn bpf_node_reinit(const_p_config &BpfConfig, p_node &BpfNode) Result {
	return C.ma_bpf_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_bpf_node_uninit(ma_bpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_bpf_node_uninit(p_node &BpfNode, const_p_allocation_callbacks &AllocationCallbacks)

// bpf_node_uninit is currently undocumented
pub fn bpf_node_uninit(p_node &BpfNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_bpf_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_notch_node_config {
pub mut:
	nodeConfig NodeConfig
	notch      NotchConfig
}

pub type NotchNodeConfig = C.ma_notch_node_config

// C: `MA_API ma_notch_node_config ma_notch_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency)`
fn C.ma_notch_node_config_init(channels u32, sample_rate u32, q f64, frequency f64) NotchNodeConfig

// notch_node_config_init is currently undocumented
pub fn notch_node_config_init(channels u32, sample_rate u32, q f64, frequency f64) NotchNodeConfig {
	return C.ma_notch_node_config_init(channels, sample_rate, q, frequency)
}

@[typedef]
struct C.ma_notch_node {
pub mut:
	baseNode NodeBase
	notch    Notch2
}

pub type NotchNode = C.ma_notch_node

// C: `MA_API ma_result ma_notch_node_init(ma_node_graph* pNodeGraph, const ma_notch_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch_node* pNode)`
fn C.ma_notch_node_init(p_node_graph &NodeGraph, const_p_config &NotchNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &NotchNode) Result

// notch_node_init is currently undocumented
pub fn notch_node_init(p_node_graph &NodeGraph, const_p_config &NotchNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &NotchNode) Result {
	return C.ma_notch_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_notch_node_reinit(const ma_notch_config* pConfig, ma_notch_node* pNode)`
fn C.ma_notch_node_reinit(const_p_config &NotchConfig, p_node &NotchNode) Result

// notch_node_reinit is currently undocumented
pub fn notch_node_reinit(const_p_config &NotchConfig, p_node &NotchNode) Result {
	return C.ma_notch_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_notch_node_uninit(ma_notch_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_notch_node_uninit(p_node &NotchNode, const_p_allocation_callbacks &AllocationCallbacks)

// notch_node_uninit is currently undocumented
pub fn notch_node_uninit(p_node &NotchNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_notch_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_peak_node_config {
pub mut:
	nodeConfig NodeConfig
	peak       PeakConfig
}

pub type PeakNodeConfig = C.ma_peak_node_config

// C: `MA_API ma_peak_node_config ma_peak_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)`
fn C.ma_peak_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) PeakNodeConfig

// peak_node_config_init is currently undocumented
pub fn peak_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) PeakNodeConfig {
	return C.ma_peak_node_config_init(channels, sample_rate, gain_db, q, frequency)
}

@[typedef]
struct C.ma_peak_node {
pub mut:
	baseNode NodeBase
	peak     Peak2
}

pub type PeakNode = C.ma_peak_node

// C: `MA_API ma_result ma_peak_node_init(ma_node_graph* pNodeGraph, const ma_peak_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak_node* pNode)`
fn C.ma_peak_node_init(p_node_graph &NodeGraph, const_p_config &PeakNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &PeakNode) Result

// peak_node_init is currently undocumented
pub fn peak_node_init(p_node_graph &NodeGraph, const_p_config &PeakNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &PeakNode) Result {
	return C.ma_peak_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_peak_node_reinit(const ma_peak_config* pConfig, ma_peak_node* pNode)`
fn C.ma_peak_node_reinit(const_p_config &PeakConfig, p_node &PeakNode) Result

// peak_node_reinit is currently undocumented
pub fn peak_node_reinit(const_p_config &PeakConfig, p_node &PeakNode) Result {
	return C.ma_peak_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_peak_node_uninit(ma_peak_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_peak_node_uninit(p_node &PeakNode, const_p_allocation_callbacks &AllocationCallbacks)

// peak_node_uninit is currently undocumented
pub fn peak_node_uninit(p_node &PeakNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_peak_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_loshelf_node_config {
pub mut:
	nodeConfig NodeConfig
	loshelf    LoshelfConfig
}

pub type LoshelfNodeConfig = C.ma_loshelf_node_config

// C: `MA_API ma_loshelf_node_config ma_loshelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)`
fn C.ma_loshelf_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) LoshelfNodeConfig

// loshelf_node_config_init is currently undocumented
pub fn loshelf_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) LoshelfNodeConfig {
	return C.ma_loshelf_node_config_init(channels, sample_rate, gain_db, q, frequency)
}

@[typedef]
struct C.ma_loshelf_node {
pub mut:
	baseNode NodeBase
	loshelf  Loshelf2
}

pub type LoshelfNode = C.ma_loshelf_node

// C: `MA_API ma_result ma_loshelf_node_init(ma_node_graph* pNodeGraph, const ma_loshelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf_node* pNode)`
fn C.ma_loshelf_node_init(p_node_graph &NodeGraph, const_p_config &LoshelfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &LoshelfNode) Result

// loshelf_node_init is currently undocumented
pub fn loshelf_node_init(p_node_graph &NodeGraph, const_p_config &LoshelfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &LoshelfNode) Result {
	return C.ma_loshelf_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_loshelf_node_reinit(const ma_loshelf_config* pConfig, ma_loshelf_node* pNode)`
fn C.ma_loshelf_node_reinit(const_p_config &LoshelfConfig, p_node &LoshelfNode) Result

// loshelf_node_reinit is currently undocumented
pub fn loshelf_node_reinit(const_p_config &LoshelfConfig, p_node &LoshelfNode) Result {
	return C.ma_loshelf_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_loshelf_node_uninit(ma_loshelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_loshelf_node_uninit(p_node &LoshelfNode, const_p_allocation_callbacks &AllocationCallbacks)

// loshelf_node_uninit is currently undocumented
pub fn loshelf_node_uninit(p_node &LoshelfNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_loshelf_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_hishelf_node_config {
pub mut:
	nodeConfig NodeConfig
	hishelf    HishelfConfig
}

pub type HishelfNodeConfig = C.ma_hishelf_node_config

// C: `MA_API ma_hishelf_node_config ma_hishelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)`
fn C.ma_hishelf_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) HishelfNodeConfig

// hishelf_node_config_init is currently undocumented
pub fn hishelf_node_config_init(channels u32, sample_rate u32, gain_db f64, q f64, frequency f64) HishelfNodeConfig {
	return C.ma_hishelf_node_config_init(channels, sample_rate, gain_db, q, frequency)
}

@[typedef]
struct C.ma_hishelf_node {
pub mut:
	baseNode NodeBase
	hishelf  Hishelf2
}

pub type HishelfNode = C.ma_hishelf_node

// C: `MA_API ma_result ma_hishelf_node_init(ma_node_graph* pNodeGraph, const ma_hishelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf_node* pNode)`
fn C.ma_hishelf_node_init(p_node_graph &NodeGraph, const_p_config &HishelfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &HishelfNode) Result

// hishelf_node_init is currently undocumented
pub fn hishelf_node_init(p_node_graph &NodeGraph, const_p_config &HishelfNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_node &HishelfNode) Result {
	return C.ma_hishelf_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_node)
}

// C: `MA_API ma_result ma_hishelf_node_reinit(const ma_hishelf_config* pConfig, ma_hishelf_node* pNode)`
fn C.ma_hishelf_node_reinit(const_p_config &HishelfConfig, p_node &HishelfNode) Result

// hishelf_node_reinit is currently undocumented
pub fn hishelf_node_reinit(const_p_config &HishelfConfig, p_node &HishelfNode) Result {
	return C.ma_hishelf_node_reinit(const_p_config, p_node)
}

// C: `MA_API void ma_hishelf_node_uninit(ma_hishelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_hishelf_node_uninit(p_node &HishelfNode, const_p_allocation_callbacks &AllocationCallbacks)

// hishelf_node_uninit is currently undocumented
pub fn hishelf_node_uninit(p_node &HishelfNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_hishelf_node_uninit(p_node, const_p_allocation_callbacks)
}

@[typedef]
struct C.ma_delay_node_config {
pub mut:
	nodeConfig NodeConfig
	delay      DelayConfig
}

pub type DelayNodeConfig = C.ma_delay_node_config

// C: `MA_API ma_delay_node_config ma_delay_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay)`
fn C.ma_delay_node_config_init(channels u32, sample_rate u32, delay_in_frames u32, decay f32) DelayNodeConfig

// delay_node_config_init is currently undocumented
pub fn delay_node_config_init(channels u32, sample_rate u32, delay_in_frames u32, decay f32) DelayNodeConfig {
	return C.ma_delay_node_config_init(channels, sample_rate, delay_in_frames, decay)
}

@[typedef]
struct C.ma_delay_node {
pub mut:
	baseNode NodeBase
	delay    Delay
}

pub type DelayNode = C.ma_delay_node

// C: `MA_API ma_result ma_delay_node_init(ma_node_graph* pNodeGraph, const ma_delay_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay_node* pDelayNode)`
fn C.ma_delay_node_init(p_node_graph &NodeGraph, const_p_config &DelayNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_delay_node &DelayNode) Result

// delay_node_init is currently undocumented
pub fn delay_node_init(p_node_graph &NodeGraph, const_p_config &DelayNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_delay_node &DelayNode) Result {
	return C.ma_delay_node_init(p_node_graph, const_p_config, const_p_allocation_callbacks,
		p_delay_node)
}

// C: `MA_API void ma_delay_node_uninit(ma_delay_node* pDelayNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_delay_node_uninit(p_delay_node &DelayNode, const_p_allocation_callbacks &AllocationCallbacks)

// delay_node_uninit is currently undocumented
pub fn delay_node_uninit(p_delay_node &DelayNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_delay_node_uninit(p_delay_node, const_p_allocation_callbacks)
}

// C: `MA_API void ma_delay_node_set_wet(ma_delay_node* pDelayNode, float value)`
fn C.ma_delay_node_set_wet(p_delay_node &DelayNode, value f32)

// delay_node_set_wet is currently undocumented
pub fn delay_node_set_wet(p_delay_node &DelayNode, value f32) {
	C.ma_delay_node_set_wet(p_delay_node, value)
}

// C: `MA_API float ma_delay_node_get_wet(const ma_delay_node* pDelayNode)`
fn C.ma_delay_node_get_wet(const_p_delay_node &DelayNode) f32

// delay_node_get_wet is currently undocumented
pub fn delay_node_get_wet(const_p_delay_node &DelayNode) f32 {
	return C.ma_delay_node_get_wet(const_p_delay_node)
}

// C: `MA_API void ma_delay_node_set_dry(ma_delay_node* pDelayNode, float value)`
fn C.ma_delay_node_set_dry(p_delay_node &DelayNode, value f32)

// delay_node_set_dry is currently undocumented
pub fn delay_node_set_dry(p_delay_node &DelayNode, value f32) {
	C.ma_delay_node_set_dry(p_delay_node, value)
}

// C: `MA_API float ma_delay_node_get_dry(const ma_delay_node* pDelayNode)`
fn C.ma_delay_node_get_dry(const_p_delay_node &DelayNode) f32

// delay_node_get_dry is currently undocumented
pub fn delay_node_get_dry(const_p_delay_node &DelayNode) f32 {
	return C.ma_delay_node_get_dry(const_p_delay_node)
}

// C: `MA_API void ma_delay_node_set_decay(ma_delay_node* pDelayNode, float value)`
fn C.ma_delay_node_set_decay(p_delay_node &DelayNode, value f32)

// delay_node_set_decay is currently undocumented
pub fn delay_node_set_decay(p_delay_node &DelayNode, value f32) {
	C.ma_delay_node_set_decay(p_delay_node, value)
}

// C: `MA_API float ma_delay_node_get_decay(const ma_delay_node* pDelayNode)`
fn C.ma_delay_node_get_decay(const_p_delay_node &DelayNode) f32

// delay_node_get_decay is currently undocumented
pub fn delay_node_get_decay(const_p_delay_node &DelayNode) f32 {
	return C.ma_delay_node_get_decay(const_p_delay_node)
}

// SoundFlags is C.ma_sound_flags
pub enum SoundFlags {
	stream                = C.MA_SOUND_FLAG_STREAM                // 0x00000001, MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM
	decode                = C.MA_SOUND_FLAG_DECODE                // 0x00000002, MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE
	async                 = C.MA_SOUND_FLAG_ASYNC                 // 0x00000004, MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC
	wait_init             = C.MA_SOUND_FLAG_WAIT_INIT             // 0x00000008, MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT
	no_default_attachment = C.MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT // 0x00000010, Do not attach to the endpoint by default. Useful for when setting up nodes in a complex graph system.
	no_pitch              = C.MA_SOUND_FLAG_NO_PITCH              // 0x00000020, Disable pitch shifting with ma_sound_set_pitch() and ma_sound_group_set_pitch(). This is an optimization.
	no_spatialization     = C.MA_SOUND_FLAG_NO_SPATIALIZATION     // 0x00000040, Disable spatialization.
}

pub const engine_max_listeners = 4

/*
TODO Function: #define MA_LISTENER_INDEX_CLOSEST           ((ma_uint8)-1)
*/

// EngineNodeType is C.ma_engine_node_type
pub enum EngineNodeType {
	sound = C.ma_engine_node_type_sound
	group = C.ma_engine_node_type_group
}

@[typedef]
struct C.ma_engine_node_config {
pub mut:
	pEngine                  &Engine = unsafe { nil }
	@type                    EngineNodeType
	channelsIn               u32
	channelsOut              u32
	sampleRate               u32 // Only used when the type is set to ma_engine_node_type_sound.
	monoExpansionMode        MonoExpansionMode
	isPitchDisabled          u8 // Pitching can be explicitly disable with MA_SOUND_FLAG_NO_PITCH to optimize processing.
	isSpatializationDisabled u8 // Spatialization can be explicitly disabled with MA_SOUND_FLAG_NO_SPATIALIZATION.
	pinnedListenerIndex      u8 // The index of the listener this node should always use for spatialization. If set to MA_LISTENER_INDEX_CLOSEST the engine will use the closest listener.
}

pub type EngineNodeConfig = C.ma_engine_node_config

// C: `MA_API ma_engine_node_config ma_engine_node_config_init(ma_engine* pEngine, ma_engine_node_type type, ma_uint32 flags)`
fn C.ma_engine_node_config_init(p_engine &Engine, @type EngineNodeType, flags u32) EngineNodeConfig

// engine_node_config_init is currently undocumented
pub fn engine_node_config_init(p_engine &Engine, @type EngineNodeType, flags u32) EngineNodeConfig {
	return C.ma_engine_node_config_init(p_engine, @type, flags)
}

@[typedef]
struct C.ma_engine_node {
pub mut:
	baseNode          NodeBase // Must be the first member for compatiblity with the ma_node API.
	pEngine           &Engine = unsafe { nil } // A pointer to the engine. Set based on the value from the config.
	sampleRate        u32 // The sample rate of the input data. For sounds backed by a data source, this will be the data source's sample rate. Otherwise it'll be the engine's sample rate.
	monoExpansionMode MonoExpansionMode
	fader             Fader
	resampler         LinearResampler // For pitch shift.
	spatializer       Spatializer
	panner            Panner
	// TODO MA_ATOMIC(4, float) pitch
	oldPitch        f32 // For determining whether or not the resampler needs to be updated to reflect the new pitch. The resampler will be updated on the mixing thread.
	oldDopplerPitch f32 // For determining whether or not the resampler needs to be updated to take a new doppler pitch into account.
	// TODO MA_ATOMIC(4, ma_bool32) isPitchDisabled
	// TODO MA_ATOMIC(4, ma_bool32) isSpatializationDisabled
	// TODO MA_ATOMIC(4, ma_uint32) pinnedListenerIndex
	// Memory management.

	_ownsHeap u8
	_pHeap    voidptr
}

pub type EngineNode = C.ma_engine_node

// C: `MA_API ma_result ma_engine_node_get_heap_size(const ma_engine_node_config* pConfig, size_t* pHeapSizeInBytes)`
fn C.ma_engine_node_get_heap_size(const_p_config &EngineNodeConfig, p_heap_size_in_bytes &usize) Result

// engine_node_get_heap_size is currently undocumented
pub fn engine_node_get_heap_size(const_p_config &EngineNodeConfig, p_heap_size_in_bytes &usize) Result {
	return C.ma_engine_node_get_heap_size(const_p_config, p_heap_size_in_bytes)
}

// C: `MA_API ma_result ma_engine_node_init_preallocated(const ma_engine_node_config* pConfig, void* pHeap, ma_engine_node* pEngineNode)`
fn C.ma_engine_node_init_preallocated(const_p_config &EngineNodeConfig, p_heap voidptr, p_engine_node &EngineNode) Result

// engine_node_init_preallocated is currently undocumented
pub fn engine_node_init_preallocated(const_p_config &EngineNodeConfig, p_heap voidptr, p_engine_node &EngineNode) Result {
	return C.ma_engine_node_init_preallocated(const_p_config, p_heap, p_engine_node)
}

// C: `MA_API ma_result ma_engine_node_init(const ma_engine_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_engine_node* pEngineNode)`
fn C.ma_engine_node_init(const_p_config &EngineNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_engine_node &EngineNode) Result

// engine_node_init is currently undocumented
pub fn engine_node_init(const_p_config &EngineNodeConfig, const_p_allocation_callbacks &AllocationCallbacks, p_engine_node &EngineNode) Result {
	return C.ma_engine_node_init(const_p_config, const_p_allocation_callbacks, p_engine_node)
}

// C: `MA_API void ma_engine_node_uninit(ma_engine_node* pEngineNode, const ma_allocation_callbacks* pAllocationCallbacks)`
fn C.ma_engine_node_uninit(p_engine_node &EngineNode, const_p_allocation_callbacks &AllocationCallbacks)

// engine_node_uninit is currently undocumented
pub fn engine_node_uninit(p_engine_node &EngineNode, const_p_allocation_callbacks &AllocationCallbacks) {
	C.ma_engine_node_uninit(p_engine_node, const_p_allocation_callbacks)
}

pub const sound_source_channel_count = u32(0xFFFFFFFF)

@[typedef]
struct C.ma_sound_config {
pub mut:
	pFilePath                      &char = unsafe { nil } // Set this to load from the resource manager.
	pFilePathW                     &u16  = unsafe { nil } // Set this to load from the resource manager.
	pDataSource                    voidptr           // Set this to load from an existing data source.
	pInitialAttachment             voidptr           // If set, the sound will be attached to an input of this node. This can be set to a ma_sound. If set to NULL, the sound will be attached directly to the endpoint unless MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT is set in `flags`.
	initialAttachmentInputBusIndex u32               // The index of the input bus of pInitialAttachment to attach the sound to.
	channelsIn                     u32               // Ignored if using a data source as input (the data source's channel count will be used always). Otherwise, setting to 0 will cause the engine's channel count to be used.
	channelsOut                    u32               // Set this to 0 (default) to use the engine's channel count. Set to MA_SOUND_SOURCE_CHANNEL_COUNT to use the data source's channel count (only used if using a data source as input).
	monoExpansionMode              MonoExpansionMode // Controls how the mono channel should be expanded to other channels when spatialization is disabled on a sound.
	flags                          u32               // A combination of MA_SOUND_FLAG_* flags.
	initialSeekPointInPCMFrames    u64               // Initializes the sound such that it's seeked to this location by default.
	rangeBegInPCMFrames            u64
	rangeEndInPCMFrames            u64
	loopPointBegInPCMFrames        u64
	loopPointEndInPCMFrames        u64
	isLooping                      u32
	pDoneFence                     &Fence = unsafe { nil } // Released when the resource manager has finished decoding the entire sound. Not used with streams.
}

pub type SoundConfig = C.ma_sound_config

// C: `MA_API ma_sound_config ma_sound_config_init(void);/* Deprecated. Will be removed in version 0.12. Use ma_sound_config_2() instead. */`
fn C.ma_sound_config_init() SoundConfig

// sound_config_init deprecated.s Will be removed in version 0.12. Use ma_sound_config_2() instead.
pub fn sound_config_init() SoundConfig {
	return C.ma_sound_config_init()
}

// C: `MA_API ma_sound_config ma_sound_config_init_2(ma_engine* pEngine);/* Will be renamed to ma_sound_config_init() in version 0.12. */`
fn C.ma_sound_config_init_2(p_engine &Engine) SoundConfig

// sound_config_init_2 wills be renamed to ma_sound_config_init() in version 0.12.
pub fn sound_config_init_2(p_engine &Engine) SoundConfig {
	return C.ma_sound_config_init_2(p_engine)
}

@[typedef]
struct C.ma_sound {
pub mut:
	engineNode  EngineNode // Must be the first member for compatibility with the ma_node API.
	pDataSource voidptr
	// TODO MA_ATOMIC(8, ma_uint64) seekTarget
	// TODO MA_ATOMIC(4, ma_bool32) atEnd
	ownsDataSource u8 // We're declaring a resource manager data source object here to save us a malloc when loading a sound via the resource manager, which I* think* will be the most common scenario.
	// TODO 	MA_NO_RESOURCE_MANAGER C.#ifndef // ma_resource_manager_data_source*
}

pub type Sound = C.ma_sound

@[typedef]
struct C.ma_sound_inlined {
pub mut:
	sound Sound
	pNext &SoundInlined = unsafe { nil }
	pPrev &SoundInlined = unsafe { nil }
}

pub type SoundInlined = C.ma_sound_inlined

// C: `MA_API ma_sound_group_config ma_sound_group_config_init(void);/* Deprecated. Will be removed in version 0.12. Use ma_sound_config_2() instead. */`
fn C.ma_sound_group_config_init() C.ma_sound_group_config

// sound_group_config_init deprecated.s Will be removed in version 0.12. Use ma_sound_config_2() instead.
pub fn sound_group_config_init() C.ma_sound_group_config {
	return C.ma_sound_group_config_init()
}

// C: `MA_API ma_sound_group_config ma_sound_group_config_init_2(ma_engine* pEngine);/* Will be renamed to ma_sound_config_init() in version 0.12. */`
fn C.ma_sound_group_config_init_2(p_engine &Engine) C.ma_sound_group_config

// sound_group_config_init_2 wills be renamed to ma_sound_config_init() in version 0.12.
pub fn sound_group_config_init_2(p_engine &Engine) C.ma_sound_group_config {
	return C.ma_sound_group_config_init_2(p_engine)
}

@[typedef]
struct C.ma_engine_config {
pub mut:
	// TODO #if !defined(MA_NO_RESOURCE_MANAGER) ma_resource_manager* pResourceManager
	// TODO #if !defined(MA_NO_DEVICE_IO) ma_context* pContext
	pDevice                      &Device   = unsafe { nil } // If set, the caller is responsible for calling ma_engine_data_callback() in the device's data callback.
	pPlaybackDeviceID            &DeviceId = unsafe { nil } // The ID of the playback device to use with the default listener.
	notificationCallback         DeviceNotificationProc
	pLog                         &Log = unsafe { nil } // When set to NULL, will use the context's log.
	listenerCount                u32 // Must be between 1 and MA_ENGINE_MAX_LISTENERS.
	channels                     u32 // The number of channels to use when mixing and spatializing. When set to 0, will use the native channel count of the device.
	sampleRate                   u32 // The sample rate. When set to 0 will use the native channel count of the device.
	periodSizeInFrames           u32 // If set to something other than 0, updates will always be exactly this size. The underlying device may be a different size, but from the perspective of the mixer that won't matter.
	periodSizeInMilliseconds     u32 // Used if periodSizeInFrames is unset.
	gainSmoothTimeInFrames       u32 // The number of frames to interpolate the gain of spatialized sounds across. If set to 0, will use gainSmoothTimeInMilliseconds.
	gainSmoothTimeInMilliseconds u32 // When set to 0, gainSmoothTimeInFrames will be used. If both are set to 0, a default value will be used.
	allocationCallbacks          AllocationCallbacks
	noAutoStart                  u32               // When set to true, requires an explicit call to ma_engine_start(). This is false by default, meaning the engine will be started automatically in ma_engine_init().
	noDevice                     u32               // When set to true, don't create a default device. ma_engine_read_pcm_frames() can be called manually to read data.
	monoExpansionMode            MonoExpansionMode // Controls how the mono channel should be expanded to other channels when spatialization is disabled on a sound.
	pResourceManagerVFS          voidptr           // A pointer to a pre-allocated VFS object to use with the resource manager. This is ignored if pResourceManager is not NULL.
}

pub type EngineConfig = C.ma_engine_config

// C: `MA_API ma_engine_config ma_engine_config_init(void)`
fn C.ma_engine_config_init() EngineConfig

// engine_config_init is currently undocumented
pub fn engine_config_init() EngineConfig {
	return C.ma_engine_config_init()
}

@[typedef]
struct C.ma_engine {
pub mut:
	nodeGraph NodeGraph // An engine is a node graph. It should be able to be plugged into any ma_node_graph API (with a cast) which means this must be the first member of this struct.
	// TODO #if !defined(MA_NO_RESOURCE_MANAGER) ma_resource_manager* pResourceManager
	// TODO #if !defined(MA_NO_DEVICE_IO) ma_device* pDevice
	pLog          &Log = unsafe { nil }
	sampleRate    u32
	listenerCount u32
	// TODO 	listeners [MA_ENGINE_MAX_LISTENERS]SpatializerListener
	allocationCallbacks AllocationCallbacks
	ownsResourceManager u8
	ownsDevice          u8
	inlinedSoundLock    u32 // For synchronizing access so the inlined sound list.
	pInlinedSoundHead   &SoundInlined = unsafe { nil } // The first inlined sound. Inlined sounds are tracked in a linked list.
	// TODO MA_ATOMIC(4, ma_uint32) inlinedSoundCount
	gainSmoothTimeInFrames u32 // The number of frames to interpolate the gain of spatialized sounds across.
	monoExpansionMode      MonoExpansionMode
}

pub type Engine = C.ma_engine

// C: `MA_API ma_result ma_engine_init(const ma_engine_config* pConfig, ma_engine* pEngine)`
fn C.ma_engine_init(const_p_config &EngineConfig, p_engine &Engine) Result

// engine_init is currently undocumented
pub fn engine_init(const_p_config &EngineConfig, p_engine &Engine) Result {
	return C.ma_engine_init(const_p_config, p_engine)
}

// C: `MA_API void ma_engine_uninit(ma_engine* pEngine)`
fn C.ma_engine_uninit(p_engine &Engine)

// engine_uninit is currently undocumented
pub fn engine_uninit(p_engine &Engine) {
	C.ma_engine_uninit(p_engine)
}

// C: `MA_API ma_result ma_engine_read_pcm_frames(ma_engine* pEngine, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)`
fn C.ma_engine_read_pcm_frames(p_engine &Engine, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result

// engine_read_pcm_frames is currently undocumented
pub fn engine_read_pcm_frames(p_engine &Engine, p_frames_out voidptr, frame_count u64, p_frames_read &u64) Result {
	return C.ma_engine_read_pcm_frames(p_engine, p_frames_out, frame_count, p_frames_read)
}

// C: `MA_API ma_node_graph* ma_engine_get_node_graph(ma_engine* pEngine)`
fn C.ma_engine_get_node_graph(p_engine &Engine) &NodeGraph

// engine_get_node_graph is currently undocumented
pub fn engine_get_node_graph(p_engine &Engine) &NodeGraph {
	return C.ma_engine_get_node_graph(p_engine)
}

// C: `MA_API ma_resource_manager* ma_engine_get_resource_manager(ma_engine* pEngine)`
fn C.ma_engine_get_resource_manager(p_engine &Engine) &ResourceManager

// engine_get_resource_manager is currently undocumented
pub fn engine_get_resource_manager(p_engine &Engine) &ResourceManager {
	return C.ma_engine_get_resource_manager(p_engine)
}

// C: `MA_API ma_device* ma_engine_get_device(ma_engine* pEngine)`
fn C.ma_engine_get_device(p_engine &Engine) &Device

// engine_get_device is currently undocumented
pub fn engine_get_device(p_engine &Engine) &Device {
	return C.ma_engine_get_device(p_engine)
}

// C: `MA_API ma_log* ma_engine_get_log(ma_engine* pEngine)`
fn C.ma_engine_get_log(p_engine &Engine) &Log

// engine_get_log is currently undocumented
pub fn engine_get_log(p_engine &Engine) &Log {
	return C.ma_engine_get_log(p_engine)
}

// C: `MA_API ma_node* ma_engine_get_endpoint(ma_engine* pEngine)`
fn C.ma_engine_get_endpoint(p_engine &Engine) voidptr

// engine_get_endpoint is currently undocumented
pub fn engine_get_endpoint(p_engine &Engine) voidptr {
	return C.ma_engine_get_endpoint(p_engine)
}

// C: `MA_API ma_uint64 ma_engine_get_time(const ma_engine* pEngine)`
fn C.ma_engine_get_time(const_p_engine &Engine) u64

// engine_get_time is currently undocumented
pub fn engine_get_time(const_p_engine &Engine) u64 {
	return C.ma_engine_get_time(const_p_engine)
}

// C: `MA_API ma_result ma_engine_set_time(ma_engine* pEngine, ma_uint64 globalTime)`
fn C.ma_engine_set_time(p_engine &Engine, global_time u64) Result

// engine_set_time is currently undocumented
pub fn engine_set_time(p_engine &Engine, global_time u64) Result {
	return C.ma_engine_set_time(p_engine, global_time)
}

// C: `MA_API ma_uint32 ma_engine_get_channels(const ma_engine* pEngine)`
fn C.ma_engine_get_channels(const_p_engine &Engine) u32

// engine_get_channels is currently undocumented
pub fn engine_get_channels(const_p_engine &Engine) u32 {
	return C.ma_engine_get_channels(const_p_engine)
}

// C: `MA_API ma_uint32 ma_engine_get_sample_rate(const ma_engine* pEngine)`
fn C.ma_engine_get_sample_rate(const_p_engine &Engine) u32

// engine_get_sample_rate is currently undocumented
pub fn engine_get_sample_rate(const_p_engine &Engine) u32 {
	return C.ma_engine_get_sample_rate(const_p_engine)
}

// C: `MA_API ma_result ma_engine_start(ma_engine* pEngine)`
fn C.ma_engine_start(p_engine &Engine) Result

// engine_start is currently undocumented
pub fn engine_start(p_engine &Engine) Result {
	return C.ma_engine_start(p_engine)
}

// C: `MA_API ma_result ma_engine_stop(ma_engine* pEngine)`
fn C.ma_engine_stop(p_engine &Engine) Result

// engine_stop is currently undocumented
pub fn engine_stop(p_engine &Engine) Result {
	return C.ma_engine_stop(p_engine)
}

// C: `MA_API ma_result ma_engine_set_volume(ma_engine* pEngine, float volume)`
fn C.ma_engine_set_volume(p_engine &Engine, volume f32) Result

// engine_set_volume is currently undocumented
pub fn engine_set_volume(p_engine &Engine, volume f32) Result {
	return C.ma_engine_set_volume(p_engine, volume)
}

// C: `MA_API ma_result ma_engine_set_gain_db(ma_engine* pEngine, float gainDB)`
fn C.ma_engine_set_gain_db(p_engine &Engine, gain_db f32) Result

// engine_set_gain_db is currently undocumented
pub fn engine_set_gain_db(p_engine &Engine, gain_db f32) Result {
	return C.ma_engine_set_gain_db(p_engine, gain_db)
}

// C: `MA_API ma_uint32 ma_engine_get_listener_count(const ma_engine* pEngine)`
fn C.ma_engine_get_listener_count(const_p_engine &Engine) u32

// engine_get_listener_count is currently undocumented
pub fn engine_get_listener_count(const_p_engine &Engine) u32 {
	return C.ma_engine_get_listener_count(const_p_engine)
}

// C: `MA_API ma_uint32 ma_engine_find_closest_listener(const ma_engine* pEngine, float absolutePosX, float absolutePosY, float absolutePosZ)`
fn C.ma_engine_find_closest_listener(const_p_engine &Engine, absolute_pos_x f32, absolute_pos_y f32, absolute_pos_z f32) u32

// engine_find_closest_listener is currently undocumented
pub fn engine_find_closest_listener(const_p_engine &Engine, absolute_pos_x f32, absolute_pos_y f32, absolute_pos_z f32) u32 {
	return C.ma_engine_find_closest_listener(const_p_engine, absolute_pos_x, absolute_pos_y,
		absolute_pos_z)
}

// C: `MA_API void ma_engine_listener_set_position(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)`
fn C.ma_engine_listener_set_position(p_engine &Engine, listener_index u32, x f32, y f32, z f32)

// engine_listener_set_position is currently undocumented
pub fn engine_listener_set_position(p_engine &Engine, listener_index u32, x f32, y f32, z f32) {
	C.ma_engine_listener_set_position(p_engine, listener_index, x, y, z)
}

// C: `MA_API ma_vec3f ma_engine_listener_get_position(const ma_engine* pEngine, ma_uint32 listenerIndex)`
fn C.ma_engine_listener_get_position(const_p_engine &Engine, listener_index u32) Vec3f

// engine_listener_get_position is currently undocumented
pub fn engine_listener_get_position(const_p_engine &Engine, listener_index u32) Vec3f {
	return C.ma_engine_listener_get_position(const_p_engine, listener_index)
}

// C: `MA_API void ma_engine_listener_set_direction(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)`
fn C.ma_engine_listener_set_direction(p_engine &Engine, listener_index u32, x f32, y f32, z f32)

// engine_listener_set_direction is currently undocumented
pub fn engine_listener_set_direction(p_engine &Engine, listener_index u32, x f32, y f32, z f32) {
	C.ma_engine_listener_set_direction(p_engine, listener_index, x, y, z)
}

// C: `MA_API ma_vec3f ma_engine_listener_get_direction(const ma_engine* pEngine, ma_uint32 listenerIndex)`
fn C.ma_engine_listener_get_direction(const_p_engine &Engine, listener_index u32) Vec3f

// engine_listener_get_direction is currently undocumented
pub fn engine_listener_get_direction(const_p_engine &Engine, listener_index u32) Vec3f {
	return C.ma_engine_listener_get_direction(const_p_engine, listener_index)
}

// C: `MA_API void ma_engine_listener_set_velocity(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)`
fn C.ma_engine_listener_set_velocity(p_engine &Engine, listener_index u32, x f32, y f32, z f32)

// engine_listener_set_velocity is currently undocumented
pub fn engine_listener_set_velocity(p_engine &Engine, listener_index u32, x f32, y f32, z f32) {
	C.ma_engine_listener_set_velocity(p_engine, listener_index, x, y, z)
}

// C: `MA_API ma_vec3f ma_engine_listener_get_velocity(const ma_engine* pEngine, ma_uint32 listenerIndex)`
fn C.ma_engine_listener_get_velocity(const_p_engine &Engine, listener_index u32) Vec3f

// engine_listener_get_velocity is currently undocumented
pub fn engine_listener_get_velocity(const_p_engine &Engine, listener_index u32) Vec3f {
	return C.ma_engine_listener_get_velocity(const_p_engine, listener_index)
}

// C: `MA_API void ma_engine_listener_set_cone(ma_engine* pEngine, ma_uint32 listenerIndex, float innerAngleInRadians, float outerAngleInRadians, float outerGain)`
fn C.ma_engine_listener_set_cone(p_engine &Engine, listener_index u32, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32)

// engine_listener_set_cone is currently undocumented
pub fn engine_listener_set_cone(p_engine &Engine, listener_index u32, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32) {
	C.ma_engine_listener_set_cone(p_engine, listener_index, inner_angle_in_radians, outer_angle_in_radians,
		outer_gain)
}

// C: `MA_API void ma_engine_listener_get_cone(const ma_engine* pEngine, ma_uint32 listenerIndex, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)`
fn C.ma_engine_listener_get_cone(const_p_engine &Engine, listener_index u32, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32)

// engine_listener_get_cone is currently undocumented
pub fn engine_listener_get_cone(const_p_engine &Engine, listener_index u32, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32) {
	C.ma_engine_listener_get_cone(const_p_engine, listener_index, p_inner_angle_in_radians,
		p_outer_angle_in_radians, p_outer_gain)
}

// C: `MA_API void ma_engine_listener_set_world_up(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)`
fn C.ma_engine_listener_set_world_up(p_engine &Engine, listener_index u32, x f32, y f32, z f32)

// engine_listener_set_world_up is currently undocumented
pub fn engine_listener_set_world_up(p_engine &Engine, listener_index u32, x f32, y f32, z f32) {
	C.ma_engine_listener_set_world_up(p_engine, listener_index, x, y, z)
}

// C: `MA_API ma_vec3f ma_engine_listener_get_world_up(const ma_engine* pEngine, ma_uint32 listenerIndex)`
fn C.ma_engine_listener_get_world_up(const_p_engine &Engine, listener_index u32) Vec3f

// engine_listener_get_world_up is currently undocumented
pub fn engine_listener_get_world_up(const_p_engine &Engine, listener_index u32) Vec3f {
	return C.ma_engine_listener_get_world_up(const_p_engine, listener_index)
}

// C: `MA_API void ma_engine_listener_set_enabled(ma_engine* pEngine, ma_uint32 listenerIndex, ma_bool32 isEnabled)`
fn C.ma_engine_listener_set_enabled(p_engine &Engine, listener_index u32, is_enabled u32)

// engine_listener_set_enabled is currently undocumented
pub fn engine_listener_set_enabled(p_engine &Engine, listener_index u32, is_enabled u32) {
	C.ma_engine_listener_set_enabled(p_engine, listener_index, is_enabled)
}

// C: `MA_API ma_bool32 ma_engine_listener_is_enabled(const ma_engine* pEngine, ma_uint32 listenerIndex)`
fn C.ma_engine_listener_is_enabled(const_p_engine &Engine, listener_index u32) u32

// engine_listener_is_enabled is currently undocumented
pub fn engine_listener_is_enabled(const_p_engine &Engine, listener_index u32) u32 {
	return C.ma_engine_listener_is_enabled(const_p_engine, listener_index)
}

// C: `MA_API ma_result ma_engine_play_sound_ex(ma_engine* pEngine, const char* pFilePath, ma_node* pNode, ma_uint32 nodeInputBusIndex)`
fn C.ma_engine_play_sound_ex(p_engine &Engine, const_p_file_path &char, p_node voidptr, node_input_bus_index u32) Result

// engine_play_sound_ex is currently undocumented
pub fn engine_play_sound_ex(p_engine &Engine, const_p_file_path &char, p_node voidptr, node_input_bus_index u32) Result {
	return C.ma_engine_play_sound_ex(p_engine, const_p_file_path, p_node, node_input_bus_index)
}

// C: `MA_API ma_result ma_engine_play_sound(ma_engine* pEngine, const char* pFilePath, ma_sound_group* pGroup); /* Fire and forget. */`
fn C.ma_engine_play_sound(p_engine &Engine, const_p_file_path &char, p_group &C.ma_sound_group) Result

// engine_play_sound fires and forget.
pub fn engine_play_sound(p_engine &Engine, const_p_file_path &char, p_group &C.ma_sound_group) Result {
	return C.ma_engine_play_sound(p_engine, const_p_file_path, p_group)
}

// C: `MA_API ma_result ma_sound_init_from_file(ma_engine* pEngine, const char* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound)`
fn C.ma_sound_init_from_file(p_engine &Engine, const_p_file_path &char, flags u32, p_group &C.ma_sound_group, p_done_fence &Fence, p_sound &Sound) Result

// sound_init_from_file is currently undocumented
pub fn sound_init_from_file(p_engine &Engine, const_p_file_path &char, flags u32, p_group &C.ma_sound_group, p_done_fence &Fence, p_sound &Sound) Result {
	return C.ma_sound_init_from_file(p_engine, const_p_file_path, flags, p_group, p_done_fence,
		p_sound)
}

// C: `MA_API ma_result ma_sound_init_from_file_w(ma_engine* pEngine, const wchar_t* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound)`
fn C.ma_sound_init_from_file_w(p_engine &Engine, const_p_file_path &u16, flags u32, p_group &C.ma_sound_group, p_done_fence &Fence, p_sound &Sound) Result

// sound_init_from_file_w is currently undocumented
pub fn sound_init_from_file_w(p_engine &Engine, const_p_file_path &u16, flags u32, p_group &C.ma_sound_group, p_done_fence &Fence, p_sound &Sound) Result {
	return C.ma_sound_init_from_file_w(p_engine, const_p_file_path, flags, p_group, p_done_fence,
		p_sound)
}

// C: `MA_API ma_result ma_sound_init_copy(ma_engine* pEngine, const ma_sound* pExistingSound, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound)`
fn C.ma_sound_init_copy(p_engine &Engine, const_p_existing_sound &Sound, flags u32, p_group &C.ma_sound_group, p_sound &Sound) Result

// sound_init_copy is currently undocumented
pub fn sound_init_copy(p_engine &Engine, const_p_existing_sound &Sound, flags u32, p_group &C.ma_sound_group, p_sound &Sound) Result {
	return C.ma_sound_init_copy(p_engine, const_p_existing_sound, flags, p_group, p_sound)
}

// C: `MA_API ma_result ma_sound_init_from_data_source(ma_engine* pEngine, ma_data_source* pDataSource, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound)`
fn C.ma_sound_init_from_data_source(p_engine &Engine, p_data_source voidptr, flags u32, p_group &C.ma_sound_group, p_sound &Sound) Result

// sound_init_from_data_source is currently undocumented
pub fn sound_init_from_data_source(p_engine &Engine, p_data_source voidptr, flags u32, p_group &C.ma_sound_group, p_sound &Sound) Result {
	return C.ma_sound_init_from_data_source(p_engine, p_data_source, flags, p_group, p_sound)
}

// C: `MA_API ma_result ma_sound_init_ex(ma_engine* pEngine, const ma_sound_config* pConfig, ma_sound* pSound)`
fn C.ma_sound_init_ex(p_engine &Engine, const_p_config &SoundConfig, p_sound &Sound) Result

// sound_init_ex is currently undocumented
pub fn sound_init_ex(p_engine &Engine, const_p_config &SoundConfig, p_sound &Sound) Result {
	return C.ma_sound_init_ex(p_engine, const_p_config, p_sound)
}

// C: `MA_API void ma_sound_uninit(ma_sound* pSound)`
fn C.ma_sound_uninit(p_sound &Sound)

// sound_uninit is currently undocumented
pub fn sound_uninit(p_sound &Sound) {
	C.ma_sound_uninit(p_sound)
}

// C: `MA_API ma_engine* ma_sound_get_engine(const ma_sound* pSound)`
fn C.ma_sound_get_engine(const_p_sound &Sound) &Engine

// sound_get_engine is currently undocumented
pub fn sound_get_engine(const_p_sound &Sound) &Engine {
	return C.ma_sound_get_engine(const_p_sound)
}

// C: `MA_API ma_data_source* ma_sound_get_data_source(const ma_sound* pSound)`
fn C.ma_sound_get_data_source(const_p_sound &Sound) voidptr

// sound_get_data_source is currently undocumented
pub fn sound_get_data_source(const_p_sound &Sound) voidptr {
	return C.ma_sound_get_data_source(const_p_sound)
}

// C: `MA_API ma_result ma_sound_start(ma_sound* pSound)`
fn C.ma_sound_start(p_sound &Sound) Result

// sound_start is currently undocumented
pub fn sound_start(p_sound &Sound) Result {
	return C.ma_sound_start(p_sound)
}

// C: `MA_API ma_result ma_sound_stop(ma_sound* pSound)`
fn C.ma_sound_stop(p_sound &Sound) Result

// sound_stop is currently undocumented
pub fn sound_stop(p_sound &Sound) Result {
	return C.ma_sound_stop(p_sound)
}

// C: `MA_API void ma_sound_set_volume(ma_sound* pSound, float volume)`
fn C.ma_sound_set_volume(p_sound &Sound, volume f32)

// sound_set_volume is currently undocumented
pub fn sound_set_volume(p_sound &Sound, volume f32) {
	C.ma_sound_set_volume(p_sound, volume)
}

// C: `MA_API float ma_sound_get_volume(const ma_sound* pSound)`
fn C.ma_sound_get_volume(const_p_sound &Sound) f32

// sound_get_volume is currently undocumented
pub fn sound_get_volume(const_p_sound &Sound) f32 {
	return C.ma_sound_get_volume(const_p_sound)
}

// C: `MA_API void ma_sound_set_pan(ma_sound* pSound, float pan)`
fn C.ma_sound_set_pan(p_sound &Sound, pan f32)

// sound_set_pan is currently undocumented
pub fn sound_set_pan(p_sound &Sound, pan f32) {
	C.ma_sound_set_pan(p_sound, pan)
}

// C: `MA_API float ma_sound_get_pan(const ma_sound* pSound)`
fn C.ma_sound_get_pan(const_p_sound &Sound) f32

// sound_get_pan is currently undocumented
pub fn sound_get_pan(const_p_sound &Sound) f32 {
	return C.ma_sound_get_pan(const_p_sound)
}

// C: `MA_API void ma_sound_set_pan_mode(ma_sound* pSound, ma_pan_mode panMode)`
fn C.ma_sound_set_pan_mode(p_sound &Sound, pan_mode PanMode)

// sound_set_pan_mode is currently undocumented
pub fn sound_set_pan_mode(p_sound &Sound, pan_mode PanMode) {
	C.ma_sound_set_pan_mode(p_sound, pan_mode)
}

// C: `MA_API ma_pan_mode ma_sound_get_pan_mode(const ma_sound* pSound)`
fn C.ma_sound_get_pan_mode(const_p_sound &Sound) PanMode

// sound_get_pan_mode is currently undocumented
pub fn sound_get_pan_mode(const_p_sound &Sound) PanMode {
	return C.ma_sound_get_pan_mode(const_p_sound)
}

// C: `MA_API void ma_sound_set_pitch(ma_sound* pSound, float pitch)`
fn C.ma_sound_set_pitch(p_sound &Sound, pitch f32)

// sound_set_pitch is currently undocumented
pub fn sound_set_pitch(p_sound &Sound, pitch f32) {
	C.ma_sound_set_pitch(p_sound, pitch)
}

// C: `MA_API float ma_sound_get_pitch(const ma_sound* pSound)`
fn C.ma_sound_get_pitch(const_p_sound &Sound) f32

// sound_get_pitch is currently undocumented
pub fn sound_get_pitch(const_p_sound &Sound) f32 {
	return C.ma_sound_get_pitch(const_p_sound)
}

// C: `MA_API void ma_sound_set_spatialization_enabled(ma_sound* pSound, ma_bool32 enabled)`
fn C.ma_sound_set_spatialization_enabled(p_sound &Sound, enabled u32)

// sound_set_spatialization_enabled is currently undocumented
pub fn sound_set_spatialization_enabled(p_sound &Sound, enabled u32) {
	C.ma_sound_set_spatialization_enabled(p_sound, enabled)
}

// C: `MA_API ma_bool32 ma_sound_is_spatialization_enabled(const ma_sound* pSound)`
fn C.ma_sound_is_spatialization_enabled(const_p_sound &Sound) u32

// sound_is_spatialization_enabled is currently undocumented
pub fn sound_is_spatialization_enabled(const_p_sound &Sound) u32 {
	return C.ma_sound_is_spatialization_enabled(const_p_sound)
}

// C: `MA_API void ma_sound_set_pinned_listener_index(ma_sound* pSound, ma_uint32 listenerIndex)`
fn C.ma_sound_set_pinned_listener_index(p_sound &Sound, listener_index u32)

// sound_set_pinned_listener_index is currently undocumented
pub fn sound_set_pinned_listener_index(p_sound &Sound, listener_index u32) {
	C.ma_sound_set_pinned_listener_index(p_sound, listener_index)
}

// C: `MA_API ma_uint32 ma_sound_get_pinned_listener_index(const ma_sound* pSound)`
fn C.ma_sound_get_pinned_listener_index(const_p_sound &Sound) u32

// sound_get_pinned_listener_index is currently undocumented
pub fn sound_get_pinned_listener_index(const_p_sound &Sound) u32 {
	return C.ma_sound_get_pinned_listener_index(const_p_sound)
}

// C: `MA_API ma_uint32 ma_sound_get_listener_index(const ma_sound* pSound)`
fn C.ma_sound_get_listener_index(const_p_sound &Sound) u32

// sound_get_listener_index is currently undocumented
pub fn sound_get_listener_index(const_p_sound &Sound) u32 {
	return C.ma_sound_get_listener_index(const_p_sound)
}

// C: `MA_API ma_vec3f ma_sound_get_direction_to_listener(const ma_sound* pSound)`
fn C.ma_sound_get_direction_to_listener(const_p_sound &Sound) Vec3f

// sound_get_direction_to_listener is currently undocumented
pub fn sound_get_direction_to_listener(const_p_sound &Sound) Vec3f {
	return C.ma_sound_get_direction_to_listener(const_p_sound)
}

// C: `MA_API void ma_sound_set_position(ma_sound* pSound, float x, float y, float z)`
fn C.ma_sound_set_position(p_sound &Sound, x f32, y f32, z f32)

// sound_set_position is currently undocumented
pub fn sound_set_position(p_sound &Sound, x f32, y f32, z f32) {
	C.ma_sound_set_position(p_sound, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_get_position(const ma_sound* pSound)`
fn C.ma_sound_get_position(const_p_sound &Sound) Vec3f

// sound_get_position is currently undocumented
pub fn sound_get_position(const_p_sound &Sound) Vec3f {
	return C.ma_sound_get_position(const_p_sound)
}

// C: `MA_API void ma_sound_set_direction(ma_sound* pSound, float x, float y, float z)`
fn C.ma_sound_set_direction(p_sound &Sound, x f32, y f32, z f32)

// sound_set_direction is currently undocumented
pub fn sound_set_direction(p_sound &Sound, x f32, y f32, z f32) {
	C.ma_sound_set_direction(p_sound, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_get_direction(const ma_sound* pSound)`
fn C.ma_sound_get_direction(const_p_sound &Sound) Vec3f

// sound_get_direction is currently undocumented
pub fn sound_get_direction(const_p_sound &Sound) Vec3f {
	return C.ma_sound_get_direction(const_p_sound)
}

// C: `MA_API void ma_sound_set_velocity(ma_sound* pSound, float x, float y, float z)`
fn C.ma_sound_set_velocity(p_sound &Sound, x f32, y f32, z f32)

// sound_set_velocity is currently undocumented
pub fn sound_set_velocity(p_sound &Sound, x f32, y f32, z f32) {
	C.ma_sound_set_velocity(p_sound, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_get_velocity(const ma_sound* pSound)`
fn C.ma_sound_get_velocity(const_p_sound &Sound) Vec3f

// sound_get_velocity is currently undocumented
pub fn sound_get_velocity(const_p_sound &Sound) Vec3f {
	return C.ma_sound_get_velocity(const_p_sound)
}

// C: `MA_API void ma_sound_set_attenuation_model(ma_sound* pSound, ma_attenuation_model attenuationModel)`
fn C.ma_sound_set_attenuation_model(p_sound &Sound, attenuation_model AttenuationModel)

// sound_set_attenuation_model is currently undocumented
pub fn sound_set_attenuation_model(p_sound &Sound, attenuation_model AttenuationModel) {
	C.ma_sound_set_attenuation_model(p_sound, attenuation_model)
}

// C: `MA_API ma_attenuation_model ma_sound_get_attenuation_model(const ma_sound* pSound)`
fn C.ma_sound_get_attenuation_model(const_p_sound &Sound) AttenuationModel

// sound_get_attenuation_model is currently undocumented
pub fn sound_get_attenuation_model(const_p_sound &Sound) AttenuationModel {
	return C.ma_sound_get_attenuation_model(const_p_sound)
}

// C: `MA_API void ma_sound_set_positioning(ma_sound* pSound, ma_positioning positioning)`
fn C.ma_sound_set_positioning(p_sound &Sound, positioning Positioning)

// sound_set_positioning is currently undocumented
pub fn sound_set_positioning(p_sound &Sound, positioning Positioning) {
	C.ma_sound_set_positioning(p_sound, positioning)
}

// C: `MA_API ma_positioning ma_sound_get_positioning(const ma_sound* pSound)`
fn C.ma_sound_get_positioning(const_p_sound &Sound) Positioning

// sound_get_positioning is currently undocumented
pub fn sound_get_positioning(const_p_sound &Sound) Positioning {
	return C.ma_sound_get_positioning(const_p_sound)
}

// C: `MA_API void ma_sound_set_rolloff(ma_sound* pSound, float rolloff)`
fn C.ma_sound_set_rolloff(p_sound &Sound, rolloff f32)

// sound_set_rolloff is currently undocumented
pub fn sound_set_rolloff(p_sound &Sound, rolloff f32) {
	C.ma_sound_set_rolloff(p_sound, rolloff)
}

// C: `MA_API float ma_sound_get_rolloff(const ma_sound* pSound)`
fn C.ma_sound_get_rolloff(const_p_sound &Sound) f32

// sound_get_rolloff is currently undocumented
pub fn sound_get_rolloff(const_p_sound &Sound) f32 {
	return C.ma_sound_get_rolloff(const_p_sound)
}

// C: `MA_API void ma_sound_set_min_gain(ma_sound* pSound, float minGain)`
fn C.ma_sound_set_min_gain(p_sound &Sound, min_gain f32)

// sound_set_min_gain is currently undocumented
pub fn sound_set_min_gain(p_sound &Sound, min_gain f32) {
	C.ma_sound_set_min_gain(p_sound, min_gain)
}

// C: `MA_API float ma_sound_get_min_gain(const ma_sound* pSound)`
fn C.ma_sound_get_min_gain(const_p_sound &Sound) f32

// sound_get_min_gain is currently undocumented
pub fn sound_get_min_gain(const_p_sound &Sound) f32 {
	return C.ma_sound_get_min_gain(const_p_sound)
}

// C: `MA_API void ma_sound_set_max_gain(ma_sound* pSound, float maxGain)`
fn C.ma_sound_set_max_gain(p_sound &Sound, max_gain f32)

// sound_set_max_gain is currently undocumented
pub fn sound_set_max_gain(p_sound &Sound, max_gain f32) {
	C.ma_sound_set_max_gain(p_sound, max_gain)
}

// C: `MA_API float ma_sound_get_max_gain(const ma_sound* pSound)`
fn C.ma_sound_get_max_gain(const_p_sound &Sound) f32

// sound_get_max_gain is currently undocumented
pub fn sound_get_max_gain(const_p_sound &Sound) f32 {
	return C.ma_sound_get_max_gain(const_p_sound)
}

// C: `MA_API void ma_sound_set_min_distance(ma_sound* pSound, float minDistance)`
fn C.ma_sound_set_min_distance(p_sound &Sound, min_distance f32)

// sound_set_min_distance is currently undocumented
pub fn sound_set_min_distance(p_sound &Sound, min_distance f32) {
	C.ma_sound_set_min_distance(p_sound, min_distance)
}

// C: `MA_API float ma_sound_get_min_distance(const ma_sound* pSound)`
fn C.ma_sound_get_min_distance(const_p_sound &Sound) f32

// sound_get_min_distance is currently undocumented
pub fn sound_get_min_distance(const_p_sound &Sound) f32 {
	return C.ma_sound_get_min_distance(const_p_sound)
}

// C: `MA_API void ma_sound_set_max_distance(ma_sound* pSound, float maxDistance)`
fn C.ma_sound_set_max_distance(p_sound &Sound, max_distance f32)

// sound_set_max_distance is currently undocumented
pub fn sound_set_max_distance(p_sound &Sound, max_distance f32) {
	C.ma_sound_set_max_distance(p_sound, max_distance)
}

// C: `MA_API float ma_sound_get_max_distance(const ma_sound* pSound)`
fn C.ma_sound_get_max_distance(const_p_sound &Sound) f32

// sound_get_max_distance is currently undocumented
pub fn sound_get_max_distance(const_p_sound &Sound) f32 {
	return C.ma_sound_get_max_distance(const_p_sound)
}

// C: `MA_API void ma_sound_set_cone(ma_sound* pSound, float innerAngleInRadians, float outerAngleInRadians, float outerGain)`
fn C.ma_sound_set_cone(p_sound &Sound, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32)

// sound_set_cone is currently undocumented
pub fn sound_set_cone(p_sound &Sound, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32) {
	C.ma_sound_set_cone(p_sound, inner_angle_in_radians, outer_angle_in_radians, outer_gain)
}

// C: `MA_API void ma_sound_get_cone(const ma_sound* pSound, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)`
fn C.ma_sound_get_cone(const_p_sound &Sound, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32)

// sound_get_cone is currently undocumented
pub fn sound_get_cone(const_p_sound &Sound, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32) {
	C.ma_sound_get_cone(const_p_sound, p_inner_angle_in_radians, p_outer_angle_in_radians,
		p_outer_gain)
}

// C: `MA_API void ma_sound_set_doppler_factor(ma_sound* pSound, float dopplerFactor)`
fn C.ma_sound_set_doppler_factor(p_sound &Sound, doppler_factor f32)

// sound_set_doppler_factor is currently undocumented
pub fn sound_set_doppler_factor(p_sound &Sound, doppler_factor f32) {
	C.ma_sound_set_doppler_factor(p_sound, doppler_factor)
}

// C: `MA_API float ma_sound_get_doppler_factor(const ma_sound* pSound)`
fn C.ma_sound_get_doppler_factor(const_p_sound &Sound) f32

// sound_get_doppler_factor is currently undocumented
pub fn sound_get_doppler_factor(const_p_sound &Sound) f32 {
	return C.ma_sound_get_doppler_factor(const_p_sound)
}

// C: `MA_API void ma_sound_set_directional_attenuation_factor(ma_sound* pSound, float directionalAttenuationFactor)`
fn C.ma_sound_set_directional_attenuation_factor(p_sound &Sound, directional_attenuation_factor f32)

// sound_set_directional_attenuation_factor is currently undocumented
pub fn sound_set_directional_attenuation_factor(p_sound &Sound, directional_attenuation_factor f32) {
	C.ma_sound_set_directional_attenuation_factor(p_sound, directional_attenuation_factor)
}

// C: `MA_API float ma_sound_get_directional_attenuation_factor(const ma_sound* pSound)`
fn C.ma_sound_get_directional_attenuation_factor(const_p_sound &Sound) f32

// sound_get_directional_attenuation_factor is currently undocumented
pub fn sound_get_directional_attenuation_factor(const_p_sound &Sound) f32 {
	return C.ma_sound_get_directional_attenuation_factor(const_p_sound)
}

// C: `MA_API void ma_sound_set_fade_in_pcm_frames(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames)`
fn C.ma_sound_set_fade_in_pcm_frames(p_sound &Sound, volume_beg f32, volume_end f32, fade_length_in_frames u64)

// sound_set_fade_in_pcm_frames is currently undocumented
pub fn sound_set_fade_in_pcm_frames(p_sound &Sound, volume_beg f32, volume_end f32, fade_length_in_frames u64) {
	C.ma_sound_set_fade_in_pcm_frames(p_sound, volume_beg, volume_end, fade_length_in_frames)
}

// C: `MA_API void ma_sound_set_fade_in_milliseconds(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds)`
fn C.ma_sound_set_fade_in_milliseconds(p_sound &Sound, volume_beg f32, volume_end f32, fade_length_in_milliseconds u64)

// sound_set_fade_in_milliseconds is currently undocumented
pub fn sound_set_fade_in_milliseconds(p_sound &Sound, volume_beg f32, volume_end f32, fade_length_in_milliseconds u64) {
	C.ma_sound_set_fade_in_milliseconds(p_sound, volume_beg, volume_end, fade_length_in_milliseconds)
}

// C: `MA_API float ma_sound_get_current_fade_volume(ma_sound* pSound)`
fn C.ma_sound_get_current_fade_volume(p_sound &Sound) f32

// sound_get_current_fade_volume is currently undocumented
pub fn sound_get_current_fade_volume(p_sound &Sound) f32 {
	return C.ma_sound_get_current_fade_volume(p_sound)
}

// C: `MA_API void ma_sound_set_start_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames)`
fn C.ma_sound_set_start_time_in_pcm_frames(p_sound &Sound, absolute_global_time_in_frames u64)

// sound_set_start_time_in_pcm_frames is currently undocumented
pub fn sound_set_start_time_in_pcm_frames(p_sound &Sound, absolute_global_time_in_frames u64) {
	C.ma_sound_set_start_time_in_pcm_frames(p_sound, absolute_global_time_in_frames)
}

// C: `MA_API void ma_sound_set_start_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds)`
fn C.ma_sound_set_start_time_in_milliseconds(p_sound &Sound, absolute_global_time_in_milliseconds u64)

// sound_set_start_time_in_milliseconds is currently undocumented
pub fn sound_set_start_time_in_milliseconds(p_sound &Sound, absolute_global_time_in_milliseconds u64) {
	C.ma_sound_set_start_time_in_milliseconds(p_sound, absolute_global_time_in_milliseconds)
}

// C: `MA_API void ma_sound_set_stop_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames)`
fn C.ma_sound_set_stop_time_in_pcm_frames(p_sound &Sound, absolute_global_time_in_frames u64)

// sound_set_stop_time_in_pcm_frames is currently undocumented
pub fn sound_set_stop_time_in_pcm_frames(p_sound &Sound, absolute_global_time_in_frames u64) {
	C.ma_sound_set_stop_time_in_pcm_frames(p_sound, absolute_global_time_in_frames)
}

// C: `MA_API void ma_sound_set_stop_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds)`
fn C.ma_sound_set_stop_time_in_milliseconds(p_sound &Sound, absolute_global_time_in_milliseconds u64)

// sound_set_stop_time_in_milliseconds is currently undocumented
pub fn sound_set_stop_time_in_milliseconds(p_sound &Sound, absolute_global_time_in_milliseconds u64) {
	C.ma_sound_set_stop_time_in_milliseconds(p_sound, absolute_global_time_in_milliseconds)
}

// C: `MA_API ma_bool32 ma_sound_is_playing(const ma_sound* pSound)`
fn C.ma_sound_is_playing(const_p_sound &Sound) u32

// sound_is_playing is currently undocumented
pub fn sound_is_playing(const_p_sound &Sound) u32 {
	return C.ma_sound_is_playing(const_p_sound)
}

// C: `MA_API ma_uint64 ma_sound_get_time_in_pcm_frames(const ma_sound* pSound)`
fn C.ma_sound_get_time_in_pcm_frames(const_p_sound &Sound) u64

// sound_get_time_in_pcm_frames is currently undocumented
pub fn sound_get_time_in_pcm_frames(const_p_sound &Sound) u64 {
	return C.ma_sound_get_time_in_pcm_frames(const_p_sound)
}

// C: `MA_API void ma_sound_set_looping(ma_sound* pSound, ma_bool32 isLooping)`
fn C.ma_sound_set_looping(p_sound &Sound, is_looping u32)

// sound_set_looping is currently undocumented
pub fn sound_set_looping(p_sound &Sound, is_looping u32) {
	C.ma_sound_set_looping(p_sound, is_looping)
}

// C: `MA_API ma_bool32 ma_sound_is_looping(const ma_sound* pSound)`
fn C.ma_sound_is_looping(const_p_sound &Sound) u32

// sound_is_looping is currently undocumented
pub fn sound_is_looping(const_p_sound &Sound) u32 {
	return C.ma_sound_is_looping(const_p_sound)
}

// C: `MA_API ma_bool32 ma_sound_at_end(const ma_sound* pSound)`
fn C.ma_sound_at_end(const_p_sound &Sound) u32

// sound_at_end is currently undocumented
pub fn sound_at_end(const_p_sound &Sound) u32 {
	return C.ma_sound_at_end(const_p_sound)
}

// C: `MA_API ma_result ma_sound_seek_to_pcm_frame(ma_sound* pSound, ma_uint64 frameIndex); /* Just a wrapper around ma_data_source_seek_to_pcm_frame(). */`
fn C.ma_sound_seek_to_pcm_frame(p_sound &Sound, frame_index u64) Result

// sound_seek_to_pcm_frame justs a wrapper around ma_data_source_seek_to_pcm_frame().
pub fn sound_seek_to_pcm_frame(p_sound &Sound, frame_index u64) Result {
	return C.ma_sound_seek_to_pcm_frame(p_sound, frame_index)
}

// C: `MA_API ma_result ma_sound_get_data_format(ma_sound* pSound, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)`
fn C.ma_sound_get_data_format(p_sound &Sound, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result

// sound_get_data_format is currently undocumented
pub fn sound_get_data_format(p_sound &Sound, p_format &Format, p_channels &u32, p_sample_rate &u32, p_channel_map &u8, channel_map_cap usize) Result {
	return C.ma_sound_get_data_format(p_sound, &p_format, p_channels, p_sample_rate, p_channel_map,
		channel_map_cap)
}

// C: `MA_API ma_result ma_sound_get_cursor_in_pcm_frames(ma_sound* pSound, ma_uint64* pCursor)`
fn C.ma_sound_get_cursor_in_pcm_frames(p_sound &Sound, p_cursor &u64) Result

// sound_get_cursor_in_pcm_frames is currently undocumented
pub fn sound_get_cursor_in_pcm_frames(p_sound &Sound, p_cursor &u64) Result {
	return C.ma_sound_get_cursor_in_pcm_frames(p_sound, p_cursor)
}

// C: `MA_API ma_result ma_sound_get_length_in_pcm_frames(ma_sound* pSound, ma_uint64* pLength)`
fn C.ma_sound_get_length_in_pcm_frames(p_sound &Sound, p_length &u64) Result

// sound_get_length_in_pcm_frames is currently undocumented
pub fn sound_get_length_in_pcm_frames(p_sound &Sound, p_length &u64) Result {
	return C.ma_sound_get_length_in_pcm_frames(p_sound, p_length)
}

// C: `MA_API ma_result ma_sound_get_cursor_in_seconds(ma_sound* pSound, float* pCursor)`
fn C.ma_sound_get_cursor_in_seconds(p_sound &Sound, p_cursor &f32) Result

// sound_get_cursor_in_seconds is currently undocumented
pub fn sound_get_cursor_in_seconds(p_sound &Sound, p_cursor &f32) Result {
	return C.ma_sound_get_cursor_in_seconds(p_sound, p_cursor)
}

// C: `MA_API ma_result ma_sound_get_length_in_seconds(ma_sound* pSound, float* pLength)`
fn C.ma_sound_get_length_in_seconds(p_sound &Sound, p_length &f32) Result

// sound_get_length_in_seconds is currently undocumented
pub fn sound_get_length_in_seconds(p_sound &Sound, p_length &f32) Result {
	return C.ma_sound_get_length_in_seconds(p_sound, p_length)
}

// C: `MA_API ma_result ma_sound_group_init(ma_engine* pEngine, ma_uint32 flags, ma_sound_group* pParentGroup, ma_sound_group* pGroup)`
fn C.ma_sound_group_init(p_engine &Engine, flags u32, p_parent_group &C.ma_sound_group, p_group &C.ma_sound_group) Result

// sound_group_init is currently undocumented
pub fn sound_group_init(p_engine &Engine, flags u32, p_parent_group &C.ma_sound_group, p_group &C.ma_sound_group) Result {
	return C.ma_sound_group_init(p_engine, flags, p_parent_group, p_group)
}

// C: `MA_API ma_result ma_sound_group_init_ex(ma_engine* pEngine, const ma_sound_group_config* pConfig, ma_sound_group* pGroup)`
fn C.ma_sound_group_init_ex(p_engine &Engine, const_p_config &C.ma_sound_group_config, p_group &C.ma_sound_group) Result

// sound_group_init_ex is currently undocumented
pub fn sound_group_init_ex(p_engine &Engine, const_p_config &C.ma_sound_group_config, p_group &C.ma_sound_group) Result {
	return C.ma_sound_group_init_ex(p_engine, const_p_config, p_group)
}

// C: `MA_API void ma_sound_group_uninit(ma_sound_group* pGroup)`
fn C.ma_sound_group_uninit(p_group &C.ma_sound_group)

// sound_group_uninit is currently undocumented
pub fn sound_group_uninit(p_group &C.ma_sound_group) {
	C.ma_sound_group_uninit(p_group)
}

// C: `MA_API ma_engine* ma_sound_group_get_engine(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_engine(const_p_group &C.ma_sound_group) &Engine

// sound_group_get_engine is currently undocumented
pub fn sound_group_get_engine(const_p_group &C.ma_sound_group) &Engine {
	return C.ma_sound_group_get_engine(const_p_group)
}

// C: `MA_API ma_result ma_sound_group_start(ma_sound_group* pGroup)`
fn C.ma_sound_group_start(p_group &C.ma_sound_group) Result

// sound_group_start is currently undocumented
pub fn sound_group_start(p_group &C.ma_sound_group) Result {
	return C.ma_sound_group_start(p_group)
}

// C: `MA_API ma_result ma_sound_group_stop(ma_sound_group* pGroup)`
fn C.ma_sound_group_stop(p_group &C.ma_sound_group) Result

// sound_group_stop is currently undocumented
pub fn sound_group_stop(p_group &C.ma_sound_group) Result {
	return C.ma_sound_group_stop(p_group)
}

// C: `MA_API void ma_sound_group_set_volume(ma_sound_group* pGroup, float volume)`
fn C.ma_sound_group_set_volume(p_group &C.ma_sound_group, volume f32)

// sound_group_set_volume is currently undocumented
pub fn sound_group_set_volume(p_group &C.ma_sound_group, volume f32) {
	C.ma_sound_group_set_volume(p_group, volume)
}

// C: `MA_API float ma_sound_group_get_volume(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_volume(const_p_group &C.ma_sound_group) f32

// sound_group_get_volume is currently undocumented
pub fn sound_group_get_volume(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_volume(const_p_group)
}

// C: `MA_API void ma_sound_group_set_pan(ma_sound_group* pGroup, float pan)`
fn C.ma_sound_group_set_pan(p_group &C.ma_sound_group, pan f32)

// sound_group_set_pan is currently undocumented
pub fn sound_group_set_pan(p_group &C.ma_sound_group, pan f32) {
	C.ma_sound_group_set_pan(p_group, pan)
}

// C: `MA_API float ma_sound_group_get_pan(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_pan(const_p_group &C.ma_sound_group) f32

// sound_group_get_pan is currently undocumented
pub fn sound_group_get_pan(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_pan(const_p_group)
}

// C: `MA_API void ma_sound_group_set_pan_mode(ma_sound_group* pGroup, ma_pan_mode panMode)`
fn C.ma_sound_group_set_pan_mode(p_group &C.ma_sound_group, pan_mode PanMode)

// sound_group_set_pan_mode is currently undocumented
pub fn sound_group_set_pan_mode(p_group &C.ma_sound_group, pan_mode PanMode) {
	C.ma_sound_group_set_pan_mode(p_group, pan_mode)
}

// C: `MA_API ma_pan_mode ma_sound_group_get_pan_mode(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_pan_mode(const_p_group &C.ma_sound_group) PanMode

// sound_group_get_pan_mode is currently undocumented
pub fn sound_group_get_pan_mode(const_p_group &C.ma_sound_group) PanMode {
	return C.ma_sound_group_get_pan_mode(const_p_group)
}

// C: `MA_API void ma_sound_group_set_pitch(ma_sound_group* pGroup, float pitch)`
fn C.ma_sound_group_set_pitch(p_group &C.ma_sound_group, pitch f32)

// sound_group_set_pitch is currently undocumented
pub fn sound_group_set_pitch(p_group &C.ma_sound_group, pitch f32) {
	C.ma_sound_group_set_pitch(p_group, pitch)
}

// C: `MA_API float ma_sound_group_get_pitch(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_pitch(const_p_group &C.ma_sound_group) f32

// sound_group_get_pitch is currently undocumented
pub fn sound_group_get_pitch(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_pitch(const_p_group)
}

// C: `MA_API void ma_sound_group_set_spatialization_enabled(ma_sound_group* pGroup, ma_bool32 enabled)`
fn C.ma_sound_group_set_spatialization_enabled(p_group &C.ma_sound_group, enabled u32)

// sound_group_set_spatialization_enabled is currently undocumented
pub fn sound_group_set_spatialization_enabled(p_group &C.ma_sound_group, enabled u32) {
	C.ma_sound_group_set_spatialization_enabled(p_group, enabled)
}

// C: `MA_API ma_bool32 ma_sound_group_is_spatialization_enabled(const ma_sound_group* pGroup)`
fn C.ma_sound_group_is_spatialization_enabled(const_p_group &C.ma_sound_group) u32

// sound_group_is_spatialization_enabled is currently undocumented
pub fn sound_group_is_spatialization_enabled(const_p_group &C.ma_sound_group) u32 {
	return C.ma_sound_group_is_spatialization_enabled(const_p_group)
}

// C: `MA_API void ma_sound_group_set_pinned_listener_index(ma_sound_group* pGroup, ma_uint32 listenerIndex)`
fn C.ma_sound_group_set_pinned_listener_index(p_group &C.ma_sound_group, listener_index u32)

// sound_group_set_pinned_listener_index is currently undocumented
pub fn sound_group_set_pinned_listener_index(p_group &C.ma_sound_group, listener_index u32) {
	C.ma_sound_group_set_pinned_listener_index(p_group, listener_index)
}

// C: `MA_API ma_uint32 ma_sound_group_get_pinned_listener_index(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_pinned_listener_index(const_p_group &C.ma_sound_group) u32

// sound_group_get_pinned_listener_index is currently undocumented
pub fn sound_group_get_pinned_listener_index(const_p_group &C.ma_sound_group) u32 {
	return C.ma_sound_group_get_pinned_listener_index(const_p_group)
}

// C: `MA_API ma_uint32 ma_sound_group_get_listener_index(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_listener_index(const_p_group &C.ma_sound_group) u32

// sound_group_get_listener_index is currently undocumented
pub fn sound_group_get_listener_index(const_p_group &C.ma_sound_group) u32 {
	return C.ma_sound_group_get_listener_index(const_p_group)
}

// C: `MA_API ma_vec3f ma_sound_group_get_direction_to_listener(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_direction_to_listener(const_p_group &C.ma_sound_group) Vec3f

// sound_group_get_direction_to_listener is currently undocumented
pub fn sound_group_get_direction_to_listener(const_p_group &C.ma_sound_group) Vec3f {
	return C.ma_sound_group_get_direction_to_listener(const_p_group)
}

// C: `MA_API void ma_sound_group_set_position(ma_sound_group* pGroup, float x, float y, float z)`
fn C.ma_sound_group_set_position(p_group &C.ma_sound_group, x f32, y f32, z f32)

// sound_group_set_position is currently undocumented
pub fn sound_group_set_position(p_group &C.ma_sound_group, x f32, y f32, z f32) {
	C.ma_sound_group_set_position(p_group, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_group_get_position(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_position(const_p_group &C.ma_sound_group) Vec3f

// sound_group_get_position is currently undocumented
pub fn sound_group_get_position(const_p_group &C.ma_sound_group) Vec3f {
	return C.ma_sound_group_get_position(const_p_group)
}

// C: `MA_API void ma_sound_group_set_direction(ma_sound_group* pGroup, float x, float y, float z)`
fn C.ma_sound_group_set_direction(p_group &C.ma_sound_group, x f32, y f32, z f32)

// sound_group_set_direction is currently undocumented
pub fn sound_group_set_direction(p_group &C.ma_sound_group, x f32, y f32, z f32) {
	C.ma_sound_group_set_direction(p_group, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_group_get_direction(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_direction(const_p_group &C.ma_sound_group) Vec3f

// sound_group_get_direction is currently undocumented
pub fn sound_group_get_direction(const_p_group &C.ma_sound_group) Vec3f {
	return C.ma_sound_group_get_direction(const_p_group)
}

// C: `MA_API void ma_sound_group_set_velocity(ma_sound_group* pGroup, float x, float y, float z)`
fn C.ma_sound_group_set_velocity(p_group &C.ma_sound_group, x f32, y f32, z f32)

// sound_group_set_velocity is currently undocumented
pub fn sound_group_set_velocity(p_group &C.ma_sound_group, x f32, y f32, z f32) {
	C.ma_sound_group_set_velocity(p_group, x, y, z)
}

// C: `MA_API ma_vec3f ma_sound_group_get_velocity(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_velocity(const_p_group &C.ma_sound_group) Vec3f

// sound_group_get_velocity is currently undocumented
pub fn sound_group_get_velocity(const_p_group &C.ma_sound_group) Vec3f {
	return C.ma_sound_group_get_velocity(const_p_group)
}

// C: `MA_API void ma_sound_group_set_attenuation_model(ma_sound_group* pGroup, ma_attenuation_model attenuationModel)`
fn C.ma_sound_group_set_attenuation_model(p_group &C.ma_sound_group, attenuation_model AttenuationModel)

// sound_group_set_attenuation_model is currently undocumented
pub fn sound_group_set_attenuation_model(p_group &C.ma_sound_group, attenuation_model AttenuationModel) {
	C.ma_sound_group_set_attenuation_model(p_group, attenuation_model)
}

// C: `MA_API ma_attenuation_model ma_sound_group_get_attenuation_model(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_attenuation_model(const_p_group &C.ma_sound_group) AttenuationModel

// sound_group_get_attenuation_model is currently undocumented
pub fn sound_group_get_attenuation_model(const_p_group &C.ma_sound_group) AttenuationModel {
	return C.ma_sound_group_get_attenuation_model(const_p_group)
}

// C: `MA_API void ma_sound_group_set_positioning(ma_sound_group* pGroup, ma_positioning positioning)`
fn C.ma_sound_group_set_positioning(p_group &C.ma_sound_group, positioning Positioning)

// sound_group_set_positioning is currently undocumented
pub fn sound_group_set_positioning(p_group &C.ma_sound_group, positioning Positioning) {
	C.ma_sound_group_set_positioning(p_group, positioning)
}

// C: `MA_API ma_positioning ma_sound_group_get_positioning(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_positioning(const_p_group &C.ma_sound_group) Positioning

// sound_group_get_positioning is currently undocumented
pub fn sound_group_get_positioning(const_p_group &C.ma_sound_group) Positioning {
	return C.ma_sound_group_get_positioning(const_p_group)
}

// C: `MA_API void ma_sound_group_set_rolloff(ma_sound_group* pGroup, float rolloff)`
fn C.ma_sound_group_set_rolloff(p_group &C.ma_sound_group, rolloff f32)

// sound_group_set_rolloff is currently undocumented
pub fn sound_group_set_rolloff(p_group &C.ma_sound_group, rolloff f32) {
	C.ma_sound_group_set_rolloff(p_group, rolloff)
}

// C: `MA_API float ma_sound_group_get_rolloff(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_rolloff(const_p_group &C.ma_sound_group) f32

// sound_group_get_rolloff is currently undocumented
pub fn sound_group_get_rolloff(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_rolloff(const_p_group)
}

// C: `MA_API void ma_sound_group_set_min_gain(ma_sound_group* pGroup, float minGain)`
fn C.ma_sound_group_set_min_gain(p_group &C.ma_sound_group, min_gain f32)

// sound_group_set_min_gain is currently undocumented
pub fn sound_group_set_min_gain(p_group &C.ma_sound_group, min_gain f32) {
	C.ma_sound_group_set_min_gain(p_group, min_gain)
}

// C: `MA_API float ma_sound_group_get_min_gain(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_min_gain(const_p_group &C.ma_sound_group) f32

// sound_group_get_min_gain is currently undocumented
pub fn sound_group_get_min_gain(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_min_gain(const_p_group)
}

// C: `MA_API void ma_sound_group_set_max_gain(ma_sound_group* pGroup, float maxGain)`
fn C.ma_sound_group_set_max_gain(p_group &C.ma_sound_group, max_gain f32)

// sound_group_set_max_gain is currently undocumented
pub fn sound_group_set_max_gain(p_group &C.ma_sound_group, max_gain f32) {
	C.ma_sound_group_set_max_gain(p_group, max_gain)
}

// C: `MA_API float ma_sound_group_get_max_gain(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_max_gain(const_p_group &C.ma_sound_group) f32

// sound_group_get_max_gain is currently undocumented
pub fn sound_group_get_max_gain(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_max_gain(const_p_group)
}

// C: `MA_API void ma_sound_group_set_min_distance(ma_sound_group* pGroup, float minDistance)`
fn C.ma_sound_group_set_min_distance(p_group &C.ma_sound_group, min_distance f32)

// sound_group_set_min_distance is currently undocumented
pub fn sound_group_set_min_distance(p_group &C.ma_sound_group, min_distance f32) {
	C.ma_sound_group_set_min_distance(p_group, min_distance)
}

// C: `MA_API float ma_sound_group_get_min_distance(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_min_distance(const_p_group &C.ma_sound_group) f32

// sound_group_get_min_distance is currently undocumented
pub fn sound_group_get_min_distance(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_min_distance(const_p_group)
}

// C: `MA_API void ma_sound_group_set_max_distance(ma_sound_group* pGroup, float maxDistance)`
fn C.ma_sound_group_set_max_distance(p_group &C.ma_sound_group, max_distance f32)

// sound_group_set_max_distance is currently undocumented
pub fn sound_group_set_max_distance(p_group &C.ma_sound_group, max_distance f32) {
	C.ma_sound_group_set_max_distance(p_group, max_distance)
}

// C: `MA_API float ma_sound_group_get_max_distance(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_max_distance(const_p_group &C.ma_sound_group) f32

// sound_group_get_max_distance is currently undocumented
pub fn sound_group_get_max_distance(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_max_distance(const_p_group)
}

// C: `MA_API void ma_sound_group_set_cone(ma_sound_group* pGroup, float innerAngleInRadians, float outerAngleInRadians, float outerGain)`
fn C.ma_sound_group_set_cone(p_group &C.ma_sound_group, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32)

// sound_group_set_cone is currently undocumented
pub fn sound_group_set_cone(p_group &C.ma_sound_group, inner_angle_in_radians f32, outer_angle_in_radians f32, outer_gain f32) {
	C.ma_sound_group_set_cone(p_group, inner_angle_in_radians, outer_angle_in_radians,
		outer_gain)
}

// C: `MA_API void ma_sound_group_get_cone(const ma_sound_group* pGroup, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)`
fn C.ma_sound_group_get_cone(const_p_group &C.ma_sound_group, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32)

// sound_group_get_cone is currently undocumented
pub fn sound_group_get_cone(const_p_group &C.ma_sound_group, p_inner_angle_in_radians &f32, p_outer_angle_in_radians &f32, p_outer_gain &f32) {
	C.ma_sound_group_get_cone(const_p_group, p_inner_angle_in_radians, p_outer_angle_in_radians,
		p_outer_gain)
}

// C: `MA_API void ma_sound_group_set_doppler_factor(ma_sound_group* pGroup, float dopplerFactor)`
fn C.ma_sound_group_set_doppler_factor(p_group &C.ma_sound_group, doppler_factor f32)

// sound_group_set_doppler_factor is currently undocumented
pub fn sound_group_set_doppler_factor(p_group &C.ma_sound_group, doppler_factor f32) {
	C.ma_sound_group_set_doppler_factor(p_group, doppler_factor)
}

// C: `MA_API float ma_sound_group_get_doppler_factor(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_doppler_factor(const_p_group &C.ma_sound_group) f32

// sound_group_get_doppler_factor is currently undocumented
pub fn sound_group_get_doppler_factor(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_doppler_factor(const_p_group)
}

// C: `MA_API void ma_sound_group_set_directional_attenuation_factor(ma_sound_group* pGroup, float directionalAttenuationFactor)`
fn C.ma_sound_group_set_directional_attenuation_factor(p_group &C.ma_sound_group, directional_attenuation_factor f32)

// sound_group_set_directional_attenuation_factor is currently undocumented
pub fn sound_group_set_directional_attenuation_factor(p_group &C.ma_sound_group, directional_attenuation_factor f32) {
	C.ma_sound_group_set_directional_attenuation_factor(p_group, directional_attenuation_factor)
}

// C: `MA_API float ma_sound_group_get_directional_attenuation_factor(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_directional_attenuation_factor(const_p_group &C.ma_sound_group) f32

// sound_group_get_directional_attenuation_factor is currently undocumented
pub fn sound_group_get_directional_attenuation_factor(const_p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_directional_attenuation_factor(const_p_group)
}

// C: `MA_API void ma_sound_group_set_fade_in_pcm_frames(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames)`
fn C.ma_sound_group_set_fade_in_pcm_frames(p_group &C.ma_sound_group, volume_beg f32, volume_end f32, fade_length_in_frames u64)

// sound_group_set_fade_in_pcm_frames is currently undocumented
pub fn sound_group_set_fade_in_pcm_frames(p_group &C.ma_sound_group, volume_beg f32, volume_end f32, fade_length_in_frames u64) {
	C.ma_sound_group_set_fade_in_pcm_frames(p_group, volume_beg, volume_end, fade_length_in_frames)
}

// C: `MA_API void ma_sound_group_set_fade_in_milliseconds(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds)`
fn C.ma_sound_group_set_fade_in_milliseconds(p_group &C.ma_sound_group, volume_beg f32, volume_end f32, fade_length_in_milliseconds u64)

// sound_group_set_fade_in_milliseconds is currently undocumented
pub fn sound_group_set_fade_in_milliseconds(p_group &C.ma_sound_group, volume_beg f32, volume_end f32, fade_length_in_milliseconds u64) {
	C.ma_sound_group_set_fade_in_milliseconds(p_group, volume_beg, volume_end, fade_length_in_milliseconds)
}

// C: `MA_API float ma_sound_group_get_current_fade_volume(ma_sound_group* pGroup)`
fn C.ma_sound_group_get_current_fade_volume(p_group &C.ma_sound_group) f32

// sound_group_get_current_fade_volume is currently undocumented
pub fn sound_group_get_current_fade_volume(p_group &C.ma_sound_group) f32 {
	return C.ma_sound_group_get_current_fade_volume(p_group)
}

// C: `MA_API void ma_sound_group_set_start_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames)`
fn C.ma_sound_group_set_start_time_in_pcm_frames(p_group &C.ma_sound_group, absolute_global_time_in_frames u64)

// sound_group_set_start_time_in_pcm_frames is currently undocumented
pub fn sound_group_set_start_time_in_pcm_frames(p_group &C.ma_sound_group, absolute_global_time_in_frames u64) {
	C.ma_sound_group_set_start_time_in_pcm_frames(p_group, absolute_global_time_in_frames)
}

// C: `MA_API void ma_sound_group_set_start_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds)`
fn C.ma_sound_group_set_start_time_in_milliseconds(p_group &C.ma_sound_group, absolute_global_time_in_milliseconds u64)

// sound_group_set_start_time_in_milliseconds is currently undocumented
pub fn sound_group_set_start_time_in_milliseconds(p_group &C.ma_sound_group, absolute_global_time_in_milliseconds u64) {
	C.ma_sound_group_set_start_time_in_milliseconds(p_group, absolute_global_time_in_milliseconds)
}

// C: `MA_API void ma_sound_group_set_stop_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames)`
fn C.ma_sound_group_set_stop_time_in_pcm_frames(p_group &C.ma_sound_group, absolute_global_time_in_frames u64)

// sound_group_set_stop_time_in_pcm_frames is currently undocumented
pub fn sound_group_set_stop_time_in_pcm_frames(p_group &C.ma_sound_group, absolute_global_time_in_frames u64) {
	C.ma_sound_group_set_stop_time_in_pcm_frames(p_group, absolute_global_time_in_frames)
}

// C: `MA_API void ma_sound_group_set_stop_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds)`
fn C.ma_sound_group_set_stop_time_in_milliseconds(p_group &C.ma_sound_group, absolute_global_time_in_milliseconds u64)

// sound_group_set_stop_time_in_milliseconds is currently undocumented
pub fn sound_group_set_stop_time_in_milliseconds(p_group &C.ma_sound_group, absolute_global_time_in_milliseconds u64) {
	C.ma_sound_group_set_stop_time_in_milliseconds(p_group, absolute_global_time_in_milliseconds)
}

// C: `MA_API ma_bool32 ma_sound_group_is_playing(const ma_sound_group* pGroup)`
fn C.ma_sound_group_is_playing(const_p_group &C.ma_sound_group) u32

// sound_group_is_playing is currently undocumented
pub fn sound_group_is_playing(const_p_group &C.ma_sound_group) u32 {
	return C.ma_sound_group_is_playing(const_p_group)
}

// C: `MA_API ma_uint64 ma_sound_group_get_time_in_pcm_frames(const ma_sound_group* pGroup)`
fn C.ma_sound_group_get_time_in_pcm_frames(const_p_group &C.ma_sound_group) u64

// sound_group_get_time_in_pcm_frames is currently undocumented
pub fn sound_group_get_time_in_pcm_frames(const_p_group &C.ma_sound_group) u64 {
	return C.ma_sound_group_get_time_in_pcm_frames(const_p_group)
}
